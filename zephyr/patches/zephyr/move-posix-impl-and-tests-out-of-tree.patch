diff --git a/include/zephyr/posix/aio.h b/include/zephyr/posix/aio.h
deleted file mode 100644
index 1faa7fc036c..00000000000
--- a/include/zephyr/posix/aio.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright 2024 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_ZEPHYR_POSIX_AIO_H_
-#define ZEPHYR_INCLUDE_ZEPHYR_POSIX_AIO_H_
-
-/* size_t must be defined by the libc stddef.h */
-#include <stddef.h>
-#include <stdint.h>
-#include <signal.h>
-
-#include <zephyr/toolchain.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(_OFF_T_DECLARED) && !defined(__off_t_defined)
-typedef long off_t;
-#define _OFF_T_DECLARED
-#define __off_t_defined
-#endif
-
-#ifndef __SIZE_TYPE__
-#define __SIZE_TYPE__ unsigned long
-#endif
-
-#if !defined(_SSIZE_T_DECLARED) && !defined(__ssize_t_defined)
-#define unsigned signed /* parasoft-suppress MISRAC2012-RULE_20_4-a MISRAC2012-RULE_20_4-b */
-typedef __SIZE_TYPE__ ssize_t;
-#undef unsigned
-#define _SSIZE_T_DECLARED
-#define __ssize_t_defined
-#endif
-
-/* time_t must be defined by the libc time.h */
-#include <time.h>
-
-#if __STDC_VERSION__ >= 201112L
-/* struct timespec must be defined in the libc time.h */
-#else
-#if !defined(_TIMESPEC_DECLARED) && !defined(__timespec_defined)
-struct timespec {
-	time_t tv_sec;
-	long tv_nsec;
-};
-#define _TIMESPEC_DECLARED
-#define __timespec_defined
-#endif
-#endif
-
-struct aiocb {
-	int aio_fildes;
-	off_t aio_offset;
-	volatile void *aio_buf;
-	size_t aio_nbytes;
-	int aio_reqprio;
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-	struct sigevent aio_sigevent;
-#endif /* defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__) */
-	int aio_lio_opcode;
-};
-
-#if _POSIX_C_SOURCE >= 200112L
-
-int aio_cancel(int fildes, struct aiocb *aiocbp);
-int aio_error(const struct aiocb *aiocbp);
-int aio_fsync(int filedes, struct aiocb *aiocbp);
-int aio_read(struct aiocb *aiocbp);
-ssize_t aio_return(struct aiocb *aiocbp);
-int aio_suspend(const struct aiocb *const list[], int nent, const struct timespec *timeout);
-int aio_write(struct aiocb *aiocbp);
-int lio_listio(int mode, struct aiocb *const ZRESTRICT list[], int nent,
-	       struct sigevent *ZRESTRICT sig);
-
-#endif /* _POSIX_C_SOURCE >= 200112L */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_ZEPHYR_POSIX_AIO_H_ */
diff --git a/include/zephyr/posix/arpa/inet.h b/include/zephyr/posix/arpa/inet.h
deleted file mode 100644
index 3b8cd49d28f..00000000000
--- a/include/zephyr/posix/arpa/inet.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_ARPA_INET_H_
-#define ZEPHYR_INCLUDE_POSIX_ARPA_INET_H_
-
-#include <stddef.h>
-
-#include <netinet/in.h>
-#include <sys/socket.h>
-
-#include <zephyr/net/socket.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef uint32_t in_addr_t;
-
-in_addr_t inet_addr(const char *cp);
-char *inet_ntoa(struct in_addr in);
-char *inet_ntop(sa_family_t family, const void *src, char *dst, size_t size);
-int inet_pton(sa_family_t family, const char *src, void *dst);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_ARPA_INET_H_ */
diff --git a/include/zephyr/posix/dirent.h b/include/zephyr/posix/dirent.h
deleted file mode 100644
index 7db41373b9c..00000000000
--- a/include/zephyr/posix/dirent.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2024 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_DIRENT_H_
-#define ZEPHYR_INCLUDE_POSIX_DIRENT_H_
-
-#include <limits.h>
-
-#include <zephyr/toolchain.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(NAME_MAX) && defined(_XOPEN_SOURCE)
-#define NAME_MAX _XOPEN_NAME_MAX
-#endif
-
-#if !defined(NAME_MAX) && defined(_POSIX_C_SOURCE)
-#define NAME_MAX _POSIX_NAME_MAX
-#endif
-
-typedef void DIR;
-
-struct dirent {
-	unsigned int d_ino;
-	char d_name[NAME_MAX + 1];
-};
-
-#if (_POSIX_C_SOURCE >= 200809L) || (_XOPEN_SOURCE >= 700)
-int alphasort(const struct dirent **d1, const struct dirent **d2);
-#endif
-int closedir(DIR *dirp);
-#if (_POSIX_C_SOURCE >= 200809L) || (_XOPEN_SOURCE >= 700)
-int dirfd(DIR *dirp);
-#endif
-DIR *fdopendir(int fd);
-DIR *opendir(const char *dirname);
-struct dirent *readdir(DIR *dirp);
-#if (_POSIX_C_SOURCE >= 199506L) || (_XOPEN_SOURCE >= 500)
-int readdir_r(DIR *ZRESTRICT dirp, struct dirent *ZRESTRICT entry,
-	      struct dirent **ZRESTRICT result);
-#endif
-void rewinddir(DIR *dirp);
-#if (_POSIX_C_SOURCE >= 200809L) || (_XOPEN_SOURCE >= 700)
-int scandir(const char *dir, struct dirent ***namelist, int (*sel)(const struct dirent *),
-	    int (*compar)(const struct dirent **, const struct dirent **));
-#endif
-#if defined(_XOPEN_SOURCE)
-void seekdir(DIR *dirp, long loc);
-long telldir(DIR *dirp);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_DIRENT_H_ */
diff --git a/include/zephyr/posix/fcntl.h b/include/zephyr/posix/fcntl.h
deleted file mode 100644
index 599e96f2245..00000000000
--- a/include/zephyr/posix/fcntl.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2018 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_POSIX_FCNTL_H_
-#define ZEPHYR_POSIX_FCNTL_H_
-
-#include <zephyr/sys/fdtable.h>
-
-#define O_APPEND   ZVFS_O_APPEND
-#define O_CREAT    ZVFS_O_CREAT
-#define O_EXCL     ZVFS_O_EXCL
-#define O_NONBLOCK ZVFS_O_NONBLOCK
-#define O_TRUNC    ZVFS_O_TRUNC
-
-#define O_ACCMODE (ZVFS_O_RDONLY | ZVFS_O_RDWR | ZVFS_O_WRONLY)
-
-#define O_RDONLY ZVFS_O_RDONLY
-#define O_RDWR   ZVFS_O_RDWR
-#define O_WRONLY ZVFS_O_WRONLY
-
-#define F_DUPFD ZVFS_F_DUPFD
-#define F_GETFL ZVFS_F_GETFL
-#define F_SETFL ZVFS_F_SETFL
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int open(const char *name, int flags, ...);
-int fcntl(int fildes, int cmd, ...);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_POSIX_FCNTL_H_ */
diff --git a/include/zephyr/posix/fnmatch.h b/include/zephyr/posix/fnmatch.h
deleted file mode 100644
index dda85a55a85..00000000000
--- a/include/zephyr/posix/fnmatch.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright The Zephyr Project Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_FNMATCH_H_
-#define ZEPHYR_INCLUDE_POSIX_FNMATCH_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define FNM_NOMATCH  1
-#define FNM_NOESCAPE 0x01
-#define FNM_PATHNAME 0x02
-#define FNM_PERIOD   0x04
-#if defined(_GNU_SOURCE)
-#define FNM_LEADING_DIR 0x08
-#define FNM_CASEFOLD    0x10
-#define FNM_EXTMATCH    0x20
-#endif
-#define FNM_IGNORECASE FNM_CASEFOLD
-
-int fnmatch(const char *pattern, const char *string, int flags);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_FNMATCH_H_ */
diff --git a/include/zephyr/posix/grp.h b/include/zephyr/posix/grp.h
deleted file mode 100644
index 464fdaf1853..00000000000
--- a/include/zephyr/posix/grp.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2024 Meta Platforms
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_GRP_H_
-#define ZEPHYR_INCLUDE_POSIX_GRP_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <sys/stat.h>
-
-/**
- * @brief Group structure
- */
-struct group {
-	/**< the name of the group */
-	char *gr_name;
-	/**< numerical group ID */
-	gid_t gr_gid;
-	/**< pointer to a null-terminated array of character pointers to member names */
-	char **gr_mem;
-};
-
-int getgrnam_r(const char *name, struct group *grp, char *buffer, size_t bufsize,
-	       struct group **result);
-int getgrgid_r(gid_t gid, struct group *grp, char *buffer, size_t bufsize, struct group **result);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_GRP_H_ */
diff --git a/include/zephyr/posix/mqueue.h b/include/zephyr/posix/mqueue.h
deleted file mode 100644
index 879a939a98a..00000000000
--- a/include/zephyr/posix/mqueue.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_MESSAGE_PASSING_H_
-#define ZEPHYR_INCLUDE_POSIX_MESSAGE_PASSING_H_
-
-#include <time.h>
-#include <signal.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void *mqd_t;
-
-struct mq_attr {
-	long mq_flags;
-	long mq_maxmsg;
-	long mq_msgsize;
-	long mq_curmsgs;	/* Number of messages currently queued. */
-};
-
-mqd_t mq_open(const char *name, int oflags, ...);
-int mq_close(mqd_t mqdes);
-int mq_unlink(const char *name);
-int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat);
-int mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
-		   unsigned int *msg_prio);
-int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
-	    unsigned int msg_prio);
-int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat,
-	       struct mq_attr *omqstat);
-int mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
-			unsigned int *msg_prio, const struct timespec *abstime);
-int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
-		 unsigned int msg_prio, const struct timespec *abstime);
-int mq_notify(mqd_t mqdes, const struct sigevent *notification);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* ZEPHYR_INCLUDE_POSIX_MESSAGE_PASSING_H_ */
diff --git a/include/zephyr/posix/net/if.h b/include/zephyr/posix/net/if.h
deleted file mode 100644
index 80360a69604..00000000000
--- a/include/zephyr/posix/net/if.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_NET_IF_H_
-#define ZEPHYR_INCLUDE_POSIX_NET_IF_H_
-
-#ifdef CONFIG_NET_INTERFACE_NAME_LEN
-#define IF_NAMESIZE CONFIG_NET_INTERFACE_NAME_LEN
-#else
-#define IF_NAMESIZE 1
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct if_nameindex {
-	unsigned int if_index;
-	char *if_name;
-};
-
-char *if_indextoname(unsigned int ifindex, char *ifname);
-void if_freenameindex(struct if_nameindex *ptr);
-struct if_nameindex *if_nameindex(void);
-unsigned int if_nametoindex(const char *ifname);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_NET_IF_H_ */
diff --git a/include/zephyr/posix/netdb.h b/include/zephyr/posix/netdb.h
deleted file mode 100644
index 5a094428e22..00000000000
--- a/include/zephyr/posix/netdb.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_NETDB_H_
-#define ZEPHYR_INCLUDE_POSIX_NETDB_H_
-
-#include <zephyr/net/socket.h>
-
-#ifndef NI_MAXSERV
-/** Provide a reasonable size for apps using getnameinfo */
-#define NI_MAXSERV 32
-#endif
-
-#define EAI_BADFLAGS DNS_EAI_BADFLAGS
-#define EAI_NONAME DNS_EAI_NONAME
-#define EAI_AGAIN DNS_EAI_AGAIN
-#define EAI_FAIL DNS_EAI_FAIL
-#define EAI_NODATA DNS_EAI_NODATA
-#define EAI_MEMORY DNS_EAI_MEMORY
-#define EAI_SYSTEM DNS_EAI_SYSTEM
-#define EAI_SERVICE DNS_EAI_SERVICE
-#define EAI_SOCKTYPE DNS_EAI_SOCKTYPE
-#define EAI_FAMILY DNS_EAI_FAMILY
-#define EAI_OVERFLOW DNS_EAI_OVERFLOW
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct hostent {
-	char *h_name;
-	char **h_aliases;
-	int h_addrtype;
-	int h_length;
-	char **h_addr_list;
-};
-
-struct netent {
-	char *n_name;
-	char **n_aliases;
-	int n_addrtype;
-	uint32_t n_net;
-};
-
-struct protoent {
-	char *p_name;
-	char **p_aliases;
-	int p_proto;
-};
-
-struct servent {
-	char *s_name;
-	char **s_aliases;
-	int s_port;
-	char *s_proto;
-};
-
-#define addrinfo zsock_addrinfo
-
-void endhostent(void);
-void endnetent(void);
-void endprotoent(void);
-void endservent(void);
-void freeaddrinfo(struct zsock_addrinfo *ai);
-const char *gai_strerror(int errcode);
-int getaddrinfo(const char *host, const char *service, const struct zsock_addrinfo *hints,
-		struct zsock_addrinfo **res);
-struct hostent *gethostent(void);
-int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen,
-		char *serv, socklen_t servlen, int flags);
-struct netent *getnetbyaddr(uint32_t net, int type);
-struct netent *getnetbyname(const char *name);
-struct netent *getnetent(void);
-struct protoent *getprotobyname(const char *name);
-struct protoent *getprotobynumber(int proto);
-struct protoent *getprotoent(void);
-struct servent *getservbyname(const char *name, const char *proto);
-struct servent *getservbyport(int port, const char *proto);
-struct servent *getservent(void);
-void sethostent(int stayopen);
-void setnetent(int stayopen);
-void setprotoent(int stayopen);
-void setservent(int stayopen);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* ZEPHYR_INCLUDE_POSIX_NETDB_H_ */
diff --git a/include/zephyr/posix/netinet/in.h b/include/zephyr/posix/netinet/in.h
deleted file mode 100644
index 1134aaac123..00000000000
--- a/include/zephyr/posix/netinet/in.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_NETINET_IN_H_
-#define ZEPHYR_INCLUDE_POSIX_NETINET_IN_H_
-
-#include <stdint.h>
-
-#include <zephyr/net/socket.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef uint16_t in_port_t;
-typedef uint32_t in_addr_t;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_NETINET_IN_H_ */
diff --git a/include/zephyr/posix/netinet/tcp.h b/include/zephyr/posix/netinet/tcp.h
deleted file mode 100644
index 775fe992b02..00000000000
--- a/include/zephyr/posix/netinet/tcp.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_NETINET_TCP_H_
-#define ZEPHYR_INCLUDE_POSIX_NETINET_TCP_H_
-
-#include <zephyr/net/socket.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_NETINET_TCP_H_ */
diff --git a/include/zephyr/posix/poll.h b/include/zephyr/posix/poll.h
deleted file mode 100644
index aa2c89210dd..00000000000
--- a/include/zephyr/posix/poll.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_POLL_H_
-#define ZEPHYR_INCLUDE_POSIX_POLL_H_
-
-#include <zephyr/net/socket.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef	unsigned int nfds_t;
-
-#define pollfd zsock_pollfd
-
-#define POLLIN ZSOCK_POLLIN
-#define POLLPRI ZSOCK_POLLPRI
-#define POLLOUT ZSOCK_POLLOUT
-#define POLLERR ZSOCK_POLLERR
-#define POLLHUP ZSOCK_POLLHUP
-#define POLLNVAL ZSOCK_POLLNVAL
-
-int poll(struct pollfd *fds, int nfds, int timeout);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* ZEPHYR_INCLUDE_POSIX_POLL_H_ */
diff --git a/include/zephyr/posix/posix_features.h b/include/zephyr/posix/posix_features.h
deleted file mode 100644
index 99064a18af1..00000000000
--- a/include/zephyr/posix/posix_features.h
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (c) 2024 BayLibre SAS
- * Copyright (c) 2024 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef INCLUDE_ZEPHYR_POSIX_POSIX_FEATURES_H_
-#define INCLUDE_ZEPHYR_POSIX_POSIX_FEATURES_H_
-
-/*
- * Note: this header is included (currently) via
- * `-imacros ${ZEPHYR_BASE}/include/zephyr/posix/posix_features.h`.
- *
- * It is not appropriate to place anything other than "symbolic constants" in this file. In this
- * context, "symbolic constants" refers to those listed in the section "Constants for Options and
- * Option Groups", in the POSIX specification.
- * https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html
- *
- * If there is a better alternative, to ensure that the contents of this file are available to
- * every compilation unit, for arbitrary C compilers, C libraries, toolchains, and so on, it is
- * to be investigated as part of the issue below.
- *
- * https://github.com/zephyrproject-rtos/zephyr/issues/98525
- */
-#if defined(_POSIX_C_SOURCE) && defined(CONFIG_POSIX_SYSTEM_INTERFACES)
-
-/*
- * POSIX Application Environment Profiles (AEP - IEEE Std 1003.13-2003)
- */
-
-#undef _POSIX_AEP_REALTIME_MINIMAL
-#ifdef CONFIG_POSIX_AEP_REALTIME_MINIMAL
-#define _POSIX_AEP_REALTIME_MINIMAL 200312L
-#endif
-
-#undef _POSIX_AEP_REALTIME_CONTROLLER
-#ifdef CONFIG_POSIX_AEP_REALTIME_CONTROLLER
-#define _POSIX_AEP_REALTIME_CONTROLLER 200312L
-#endif
-
-#undef _POSIX_AEP_REALTIME_DEDICATED
-#ifdef CONFIG_POSIX_AEP_REALTIME_DEDICATED
-#define _POSIX_AEP_REALTIME_DEDICATED 200312L
-#endif
-
-/*
- * Subprofiling Considerations
- */
-#define _POSIX_SUBPROFILE 1
-
-/*
- * POSIX System Interfaces
- */
-
-#define _POSIX_VERSION 200809L
-
-#undef _POSIX_CHOWN_RESTRICTED
-#define _POSIX_CHOWN_RESTRICTED (0)
-#undef _POSIX_NO_TRUNC
-#define _POSIX_NO_TRUNC (0)
-#undef _POSIX_VDISABLE
-#define _POSIX_VDISABLE ('\0')
-
-/* #define _POSIX_ADVISORY_INFO (-1L) */
-
-#undef _POSIX_ASYNCHRONOUS_IO
-#ifdef CONFIG_POSIX_ASYNCHRONOUS_IO
-#define _POSIX_ASYNCHRONOUS_IO _POSIX_VERSION
-#endif
-
-#undef _POSIX_BARRIERS
-#ifdef CONFIG_POSIX_BARRIERS
-#define _POSIX_BARRIERS _POSIX_VERSION
-#endif
-
-#undef _POSIX_CLOCK_SELECTION
-#ifdef CONFIG_POSIX_CLOCK_SELECTION
-#define _POSIX_CLOCK_SELECTION _POSIX_VERSION
-#endif
-
-#undef _POSIX_CPUTIME
-#ifdef CONFIG_POSIX_CPUTIME
-#define _POSIX_CPUTIME _POSIX_VERSION
-#endif
-
-#undef _POSIX_FSYNC
-#ifdef CONFIG_POSIX_FSYNC
-#define _POSIX_FSYNC _POSIX_VERSION
-#endif
-
-#undef _POSIX_IPV6
-#ifdef CONFIG_POSIX_IPV6
-#define _POSIX_IPV6 _POSIX_VERSION
-#endif
-
-/* #define _POSIX_JOB_CONTROL (-1L) */
-
-#undef _POSIX_MAPPED_FILES
-#ifdef CONFIG_POSIX_MAPPED_FILES
-#define _POSIX_MAPPED_FILES _POSIX_VERSION
-#endif
-
-#ifdef CONFIG_POSIX_MEMLOCK
-#define _POSIX_MEMLOCK _POSIX_VERSION
-#endif
-
-#undef _POSIX_MEMLOCK_RANGE
-#ifdef CONFIG_POSIX_MEMLOCK_RANGE
-#define _POSIX_MEMLOCK_RANGE _POSIX_VERSION
-#endif
-
-#undef _POSIX_MEMORY_PROTECTION
-#ifdef CONFIG_POSIX_MEMORY_PROTECTION
-#define _POSIX_MEMORY_PROTECTION _POSIX_VERSION
-#endif
-
-#undef _POSIX_MESSAGE_PASSING
-#ifdef CONFIG_POSIX_MESSAGE_PASSING
-#define _POSIX_MESSAGE_PASSING _POSIX_VERSION
-#endif
-
-#undef _POSIX_MONOTONIC_CLOCK
-#ifdef CONFIG_POSIX_MONOTONIC_CLOCK
-#define _POSIX_MONOTONIC_CLOCK _POSIX_VERSION
-#endif
-
-/* #define _POSIX_PRIORITIZED_IO (-1L) */
-
-#undef _POSIX_PRIORITY_SCHEDULING
-#ifdef CONFIG_POSIX_PRIORITY_SCHEDULING
-#define _POSIX_PRIORITY_SCHEDULING _POSIX_VERSION
-#endif
-
-#undef _POSIX_RAW_SOCKETS
-#ifdef CONFIG_POSIX_RAW_SOCKETS
-#define _POSIX_RAW_SOCKETS _POSIX_VERSION
-#endif
-
-#undef _POSIX_READER_WRITER_LOCKS
-#ifdef CONFIG_POSIX_RW_LOCKS
-#define _POSIX_READER_WRITER_LOCKS _POSIX_VERSION
-#endif
-
-#undef _POSIX_REALTIME_SIGNALS
-#ifdef CONFIG_POSIX_REALTIME_SIGNALS
-#define _POSIX_REALTIME_SIGNALS _POSIX_VERSION
-#endif
-
-/* #define _POSIX_REGEXP (-1L) */
-/* #define _POSIX_SAVED_IDS (-1L) */
-
-#undef _POSIX_SEMAPHORES
-#ifdef CONFIG_POSIX_SEMAPHORES
-#define _POSIX_SEMAPHORES _POSIX_VERSION
-#endif
-
-#undef _POSIX_SHARED_MEMORY_OBJECTS
-#ifdef CONFIG_POSIX_SHARED_MEMORY_OBJECTS
-#define _POSIX_SHARED_MEMORY_OBJECTS _POSIX_VERSION
-#endif
-
-/* #define _POSIX_SHELL (-1L) */
-/* #define _POSIX_SPAWN (-1L) */
-
-#undef _POSIX_SPIN_LOCKS
-#ifdef CONFIG_POSIX_SPIN_LOCKS
-#define _POSIX_SPIN_LOCKS _POSIX_VERSION
-#endif
-
-/* #define _POSIX_SPORADIC_SERVER (-1L) */
-
-#undef _POSIX_SYNCHRONIZED_IO
-#ifdef CONFIG_POSIX_SYNCHRONIZED_IO
-#define _POSIX_SYNCHRONIZED_IO _POSIX_VERSION
-#endif
-
-#undef _POSIX_THREADS
-#undef _POSIX_THREAD_PROCESS_SHARED
-#undef _POSIX_PRIORITY_SCHEDULING
-#undef _POSIX_THREAD_PRIORITY_SCHEDULING
-#ifdef CONFIG_POSIX_THREADS
-#define _POSIX_THREADS                    _POSIX_VERSION
-#define _POSIX_THREAD_PROCESS_SHARED      _POSIX_VERSION
-#define _POSIX_PRIORITY_SCHEDULING        _POSIX_VERSION
-#define _POSIX_THREAD_PRIORITY_SCHEDULING _POSIX_VERSION
-#endif
-
-#undef _POSIX_THREAD_ATTR_STACKADDR
-#ifdef CONFIG_POSIX_THREAD_ATTR_STACKADDR
-#define _POSIX_THREAD_ATTR_STACKADDR _POSIX_VERSION
-#endif
-
-#undef _POSIX_THREAD_ATTR_STACKSIZE
-#ifdef CONFIG_POSIX_THREAD_ATTR_STACKSIZE
-#define _POSIX_THREAD_ATTR_STACKSIZE _POSIX_VERSION
-#endif
-
-#undef _POSIX_THREAD_CPUTIME
-#ifdef CONFIG_POSIX_THREAD_CPUTIME
-#define _POSIX_THREAD_CPUTIME _POSIX_VERSION
-#endif
-
-#undef _POSIX_THREAD_PRIO_INHERIT
-#ifdef CONFIG_POSIX_THREAD_PRIO_INHERIT
-#define _POSIX_THREAD_PRIO_INHERIT _POSIX_VERSION
-#endif
-
-#undef _POSIX_THREAD_PRIO_PROTECT
-#ifdef CONFIG_POSIX_THREAD_PRIO_PROTECT
-#define _POSIX_THREAD_PRIO_PROTECT _POSIX_VERSION
-#endif
-
-#undef _POSIX_THREAD_PRIORITY_SCHEDULING
-#ifdef CONFIG_POSIX_THREAD_PRIORITY_SCHEDULING
-#define _POSIX_THREAD_PRIORITY_SCHEDULING _POSIX_VERSION
-#endif
-
-/* #define _POSIX_THREAD_PROCESS_SHARED (-1L) */
-/* #define _POSIX_THREAD_ROBUST_PRIO_INHERIT (-1L) */
-/* #define _POSIX_THREAD_ROBUST_PRIO_PROTECT (-1L) */
-
-#undef _POSIX_THREAD_SAFE_FUNCTIONS
-#if defined(CONFIG_POSIX_FILE_SYSTEM_R) && defined(CONFIG_POSIX_C_LANG_SUPPORT_R)
-#define _POSIX_THREAD_SAFE_FUNCTIONS _POSIX_VERSION
-#endif
-
-/* #define _POSIX_THREAD_SPORADIC_SERVER (-1L) */
-
-#undef _POSIX_THREADS
-#undef _POSIX_THREAD_PROCESS_SHARED
-#undef _POSIX_PRIORITY_SCHEDULING
-#undef _POSIX_THREAD_PRIORITY_SCHEDULING
-#ifdef CONFIG_POSIX_THREADS
-#define _POSIX_THREADS                    _POSIX_VERSION
-#define _POSIX_THREAD_PROCESS_SHARED      _POSIX_VERSION
-#define _POSIX_PRIORITY_SCHEDULING        _POSIX_VERSION
-#define _POSIX_THREAD_PRIORITY_SCHEDULING _POSIX_VERSION
-#endif
-
-#undef _POSIX_TIMEOUTS
-#ifdef CONFIG_POSIX_TIMEOUTS
-#define _POSIX_TIMEOUTS _POSIX_VERSION
-#endif
-
-#undef _POSIX_CPUTIME
-#undef _POSIX_MONOTONIC_CLOCK
-#undef _POSIX_TIMEOUTS
-#undef _POSIX_TIMERS
-#ifdef CONFIG_POSIX_TIMERS
-#define _POSIX_TIMERS          _POSIX_VERSION
-#define _POSIX_TIMEOUTS        _POSIX_VERSION
-/*
- * FIXME: Until we have a Kconfig for XSI_ADVANCED_REALTIME, define _POSIX_CPUTIME and
- * _POSIX_MONOTONIC_CLOCK with _POSIX_TIMERS.
- * For more information on the Advanced Realtime Option Group, please see
- * https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html
- */
-#define _POSIX_CPUTIME         _POSIX_VERSION
-#define _POSIX_MONOTONIC_CLOCK _POSIX_VERSION
-#endif
-
-/* #define _POSIX_TRACE (-1L) */
-/* #define _POSIX_TRACE_EVENT_FILTER (-1L) */
-/* #define _POSIX_TRACE_INHERIT (-1L) */
-/* #define _POSIX_TRACE_LOG (-1L) */
-/* #define _POSIX_TYPED_MEMORY_OBJECTS (-1L) */
-
-/*
- * POSIX v6 Options
- */
-/* #define _POSIX_V6_ILP32_OFF32 (-1L) */
-/* #define _POSIX_V6_ILP32_OFFBIG (-1L) */
-/* #define _POSIX_V6_LP64_OFF64 (-1L) */
-/* #define _POSIX_V6_LPBIG_OFFBIG (-1L) */
-
-/*
- * POSIX v7 Options
- */
-/* #define _POSIX_V7_ILP32_OFF32 (-1L) */
-/* #define _POSIX_V7_ILP32_OFFBIG (-1L) */
-/* #define _POSIX_V7_LP64_OFF64 (-1L) */
-/* #define _POSIX_V7_LPBIG_OFFBIG (-1L) */
-
-/*
- * POSIX2 Options
- */
-#undef _POSIX2_C_BIND
-#define _POSIX2_C_BIND _POSIX_VERSION
-/* #define _POSIX2_C_DEV (-1) */
-/* #define _POSIX2_CHAR_TERM (-1L) */
-/* #define _POSIX2_FORT_DEV (-1L) */
-/* #define _POSIX2_FORT_RUN (-1L) */
-/* #define _POSIX2_LOCALEDEF (-1L) */
-/* #define _POSIX2_PBS (-1L) */
-/* #define _POSIX2_PBS_ACCOUNTING (-1L) */
-/* #define _POSIX2_PBS_CHECKPOINT (-1L) */
-/* #define _POSIX2_PBS_LOCATE (-1L) */
-/* #define _POSIX2_PBS_MESSAGE (-1L) */
-/* #define _POSIX2_PBS_TRACK (-1L) */
-/* #define _POSIX2_SW_DEV (-1L) */
-/* #define _POSIX2_UPE (-1L) */
-
-/*
- * X/Open System Interfaces
- */
-
-#undef _XOPEN_VERSION
-#ifdef CONFIG_XSI
-#define _XOPEN_VERSION 700
-#endif
-
-/* #define _XOPEN_CRYPT (-1L) */
-/* #define _XOPEN_ENH_I18N (-1L) */
-#if defined(CONFIG_XSI_REALTIME) ||                                                                \
-	(defined(CONFIG_POSIX_FSYNC) && defined(CONFIG_POSIX_MEMLOCK) &&                           \
-	 defined(CONFIG_POSIX_MEMLOCK_RANGE) && defined(CONFIG_POSIX_MESSAGE_PASSING) &&           \
-	 defined(CONFIG_POSIX_PRIORITY_SCHEDULING) &&                                              \
-	 defined(CONFIG_POSIX_SHARED_MEMORY_OBJECTS) && defined(CONFIG_POSIX_SYNCHRONIZED_IO))
-#define _XOPEN_REALTIME _XOPEN_VERSION
-#endif
-/* #define _XOPEN_REALTIME_THREADS (-1L) */
-/* #define _XOPEN_SHM (-1L) */
-
-#undef _XOPEN_STREAMS
-#ifdef CONFIG_XSI_STREAMS
-#define _XOPEN_STREAMS _XOPEN_VERSION
-#endif
-
-#undef _XOPEN_UNIX
-#ifdef CONFIG_XSI
-#define _XOPEN_UNIX _XOPEN_VERSION
-#endif
-
-/* #define _XOPEN_UUCP (-1L) */
-
-#endif /* defined(_POSIX_C_SOURCE) || defined(CONFIG_POSIX_SYSTEM_INTERFACES) */
-
-#endif /* INCLUDE_ZEPHYR_POSIX_POSIX_FEATURES_H_ */
diff --git a/include/zephyr/posix/posix_limits.h b/include/zephyr/posix/posix_limits.h
deleted file mode 100644
index 9c225b4b4d4..00000000000
--- a/include/zephyr/posix/posix_limits.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright The Zephyr Project Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_ZEPHYR_POSIX_POSIX_LIMITS_H_
-#define ZEPHYR_INCLUDE_ZEPHYR_POSIX_POSIX_LIMITS_H_
-
-#if defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__)
-
-/*
- * clang-format and checkpatch disagree on formatting here, so rely on checkpatch and disable
- * clang-format since checkpatch cannot be selectively disabled.
- */
-
-/* clang-format off */
-
-/* Maximum values */
-#define _POSIX_CLOCKRES_MIN (20000000L)
-
-/* Minimum values */
-#define _POSIX_AIO_LISTIO_MAX               (2)
-#define _POSIX_AIO_MAX                      (1)
-#define _POSIX_ARG_MAX                      (4096)
-#define _POSIX_CHILD_MAX                    (25)
-#define _POSIX_DELAYTIMER_MAX               (32)
-#define _POSIX_HOST_NAME_MAX                (255)
-#define _POSIX_LINK_MAX                     (8)
-#define _POSIX_LOGIN_NAME_MAX               (9)
-#define _POSIX_MAX_CANON                    (255)
-#define _POSIX_MAX_INPUT                    (255)
-#define _POSIX_MQ_OPEN_MAX                  (8)
-#define _POSIX_MQ_PRIO_MAX                  (32)
-#define _POSIX_NAME_MAX                     (14)
-#define _POSIX_NGROUPS_MAX                  (8)
-#define _POSIX_OPEN_MAX                     (20)
-#define _POSIX_PATH_MAX                     (256)
-#define _POSIX_PIPE_BUF                     (512)
-#define _POSIX_RE_DUP_MAX                   (255)
-#define _POSIX_RTSIG_MAX                    (8)
-#define _POSIX_SEM_NSEMS_MAX                (256)
-#define _POSIX_SEM_VALUE_MAX                (32767)
-#define _POSIX_SIGQUEUE_MAX                 (32)
-#define _POSIX_SSIZE_MAX                    (32767)
-#define _POSIX_SS_REPL_MAX                  (4)
-#define _POSIX_STREAM_MAX                   (8)
-#define _POSIX_SYMLINK_MAX                  (255)
-#define _POSIX_SYMLOOP_MAX                  (8)
-#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS (4)
-#define _POSIX_THREAD_KEYS_MAX              (128)
-#define _POSIX_THREAD_THREADS_MAX           (64)
-#define _POSIX_TIMER_MAX                    (32)
-#define _POSIX_TRACE_EVENT_NAME_MAX         (30)
-#define _POSIX_TRACE_NAME_MAX               (8)
-#define _POSIX_TRACE_SYS_MAX                (8)
-#define _POSIX_TRACE_USER_EVENT_MAX         (32)
-#define _POSIX_TTY_NAME_MAX                 (9)
-#define _POSIX_TZNAME_MAX                   (6)
-#define _POSIX2_BC_BASE_MAX                 (99)
-#define _POSIX2_BC_DIM_MAX                  (2048)
-#define _POSIX2_BC_SCALE_MAX                (99)
-#define _POSIX2_BC_STRING_MAX               (1000)
-#define _POSIX2_CHARCLASS_NAME_MAX          (14)
-#define _POSIX2_COLL_WEIGHTS_MAX            (2)
-#define _POSIX2_EXPR_NEST_MAX               (32)
-#define _POSIX2_LINE_MAX                    (2048)
-#define _XOPEN_IOV_MAX                      (16)
-#define _XOPEN_NAME_MAX                     (255)
-#define _XOPEN_PATH_MAX                     (1024)
-
-/* Other invariant values */
-#define NL_LANGMAX (14)
-#define NL_MSGMAX  (32767)
-#define NL_SETMAX  (255)
-#define NL_TEXTMAX (_POSIX2_LINE_MAX)
-#define NZERO      (20)
-
-/* Runtime invariant values */
-#define AIO_LISTIO_MAX                _POSIX_AIO_LISTIO_MAX
-#define AIO_MAX                       _POSIX_AIO_MAX
-#define AIO_PRIO_DELTA_MAX            (0)
-#define ARG_MAX                       _POSIX_ARG_MAX
-#define ATEXIT_MAX                    (32)
-#define DELAYTIMER_MAX \
-	COND_CODE_1(CONFIG_POSIX_TIMERS, (CONFIG_POSIX_DELAYTIMER_MAX), (0))
-#define HOST_NAME_MAX \
-	COND_CODE_1(CONFIG_POSIX_NETWORKING, (CONFIG_POSIX_HOST_NAME_MAX), (0))
-#define LOGIN_NAME_MAX                _POSIX_LOGIN_NAME_MAX
-#define MQ_OPEN_MAX \
-	COND_CODE_1(CONFIG_POSIX_MESSAGE_PASSING, (CONFIG_POSIX_MQ_OPEN_MAX), (0))
-#define MQ_PRIO_MAX                   _POSIX_MQ_PRIO_MAX
-#define OPEN_MAX                      CONFIG_POSIX_OPEN_MAX
-#define PAGE_SIZE                     CONFIG_POSIX_PAGE_SIZE
-#define PAGESIZE                      CONFIG_POSIX_PAGE_SIZE
-#define PATH_MAX                      _POSIX_PATH_MAX
-#define PTHREAD_DESTRUCTOR_ITERATIONS _POSIX_THREAD_DESTRUCTOR_ITERATIONS
-#define PTHREAD_KEYS_MAX \
-	COND_CODE_1(CONFIG_POSIX_THREADS, (CONFIG_POSIX_THREAD_KEYS_MAX), (0))
-#define PTHREAD_THREADS_MAX \
-	COND_CODE_1(CONFIG_POSIX_THREADS, (CONFIG_POSIX_THREAD_THREADS_MAX), (0))
-#define RTSIG_MAX \
-	COND_CODE_1(CONFIG_POSIX_REALTIME_SIGNALS, (CONFIG_POSIX_RTSIG_MAX), (0))
-#define SEM_NSEMS_MAX \
-	COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (CONFIG_POSIX_SEM_NSEMS_MAX), (0))
-#define SEM_VALUE_MAX \
-	COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (CONFIG_POSIX_SEM_VALUE_MAX), (0))
-#define SIGQUEUE_MAX                  _POSIX_SIGQUEUE_MAX
-#define STREAM_MAX                    _POSIX_STREAM_MAX
-#define SYMLOOP_MAX                   _POSIX_SYMLOOP_MAX
-#define TIMER_MAX \
-	COND_CODE_1(CONFIG_POSIX_TIMERS, (CONFIG_POSIX_TIMER_MAX), (0))
-#define TTY_NAME_MAX                  _POSIX_TTY_NAME_MAX
-#define TZNAME_MAX                    _POSIX_TZNAME_MAX
-
-/* Pathname variable values */
-#define FILESIZEBITS             (32)
-#define POSIX_ALLOC_SIZE_MIN     (256)
-#define POSIX_REC_INCR_XFER_SIZE (1024)
-#define POSIX_REC_MAX_XFER_SIZE  (32767)
-#define POSIX_REC_MIN_XFER_SIZE  (1)
-#define POSIX_REC_XFER_ALIGN     (4)
-#define SYMLINK_MAX              _POSIX_SYMLINK_MAX
-
-/* clang-format on */
-
-#endif
-
-#endif /* ZEPHYR_INCLUDE_ZEPHYR_POSIX_POSIX_LIMITS_H_ */
diff --git a/include/zephyr/posix/posix_signal.h b/include/zephyr/posix/posix_signal.h
deleted file mode 100644
index c6b3d6110d0..00000000000
--- a/include/zephyr/posix/posix_signal.h
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- * Copyright (c) 2025 The Zephyr Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_POSIX_SIGNAL_H_
-#define ZEPHYR_INCLUDE_POSIX_POSIX_SIGNAL_H_
-
-#if defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__)
-
-#include <zephyr/toolchain.h>
-#include <zephyr/sys/util.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* SIG_DFL must be defined by the libc signal.h */
-/* SIG_ERR must be defined by the libc signal.h */
-
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-#define SIG_HOLD ((void *)-2)
-#endif
-
-/* SIG_IGN must be defined by the libc signal.h */
-
-#if defined(_POSIX_THREADS) || defined(__DOXYGEN__)
-
-#if !defined(_PTHREAD_T_DECLARED) && !defined(__pthread_t_defined)
-typedef unsigned int pthread_t;
-#define _PTHREAD_T_DECLARED
-#define __pthread_t_defined
-#endif
-
-#endif /* defined(_POSIX_THREADS) || defined(__DOXYGEN__) */
-
-/* size_t must be defined by the libc stddef.h */
-#include <stddef.h>
-
-#if !defined(_UID_T_DECLARED) && !defined(__uid_t_defined)
-typedef int uid_t;
-#define _UID_T_DECLARED
-#define __uid_t_defined
-#endif
-
-/* time_t must be defined by the libc time.h */
-#include <time.h>
-
-#if __STDC_VERSION__ >= 201112L
-/* struct timespec must be defined in the libc time.h */
-#else
-#if !defined(_TIMESPEC_DECLARED) && !defined(__timespec_defined)
-struct timespec {
-	time_t tv_sec;
-	long tv_nsec;
-};
-#define _TIMESPEC_DECLARED
-#define __timespec_defined
-#endif
-#endif
-
-/* sig_atomic_t must be defined by the libc signal.h */
-
-#define SIGRTMIN 32
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-BUILD_ASSERT(CONFIG_POSIX_RTSIG_MAX >= 0);
-#define SIGRTMAX (SIGRTMIN + CONFIG_POSIX_RTSIG_MAX)
-#else
-#define SIGRTMAX SIGRTMIN
-#endif
-
-#if !defined(_SIGSET_T_DECLARED) && !defined(__sigset_t_defined)
-typedef struct {
-	unsigned long sig[DIV_ROUND_UP(SIGRTMAX + 1, BITS_PER_LONG)];
-} sigset_t;
-#define _SIGSET_T_DECLARED
-#define __sigset_t_defined
-#endif
-
-#if !defined(_PID_T_DECLARED) && !defined(__pid_t_defined)
-typedef long pid_t;
-#define _PID_T_DECLARED
-#define __pid_t_defined
-#endif
-
-#if defined(_POSIX_THREADS) || defined(__DOXYGEN__)
-
-#if !defined(_PTHREAD_ATTR_T_DECLARED) && !defined(__pthread_attr_t_defined)
-typedef struct {
-	void *stack;
-	unsigned int details[2];
-} pthread_attr_t;
-#define _PTHREAD_ATTR_T_DECLARED
-#define __pthread_attr_t_defined
-#endif
-
-#endif
-
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-
-/* slightly out of order w.r.t. the specification */
-#if !defined(_SIGVAL_DECLARED) && !defined(__sigval_defined)
-union sigval {
-	int sival_int;
-	void *sival_ptr;
-};
-#define _SIGVAL_DECLARED
-#define __sigval_defined
-#endif
-
-#if !defined(_SIGEVENT_DECLARED) && !defined(__sigevent_defined)
-struct sigevent {
-#if defined(_POSIX_THREADS) || defined(__DOXYGEN__)
-	pthread_attr_t *sigev_notify_attributes;
-	void (*sigev_notify_function)(union sigval value);
-#endif
-	union sigval sigev_value;
-	int sigev_notify;
-	int sigev_signo;
-};
-#define _SIGEVENT_DECLARED
-#define __sigevent_defined
-#endif
-
-#define SIGEV_NONE   1
-#define SIGEV_SIGNAL 2
-#define SIGEV_THREAD 3
-
-/* Signal constants are defined below */
-
-#endif /* defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__) */
-
-/* SIGRTMIN and SIGRTMAX defined above */
-
-/* slightly out of order w.r.t. the specification */
-#if !defined(_SIGINFO_T_DECLARED) && !defined(__siginfo_t_defined)
-typedef struct {
-	void *si_addr;
-#if defined(_XOPEN_STREAMS) || defined(__DOXYGEN__)
-	long si_band;
-#endif
-	union sigval si_value;
-	pid_t si_pid;
-	uid_t si_uid;
-	int si_signo;
-	int si_code;
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-	int si_errno;
-#endif
-	int si_status;
-} siginfo_t;
-#define _SIGINFO_T_DECLARED
-#define __siginfo_t_defined
-#endif
-
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-
-#if !defined(_SIGACTION_DECLARED) && !defined(__sigaction_defined)
-struct sigaction {
-	union {
-		void (*sa_handler)(int sig);
-		void (*sa_sigaction)(int sig, siginfo_t *info, void *context);
-	};
-	sigset_t sa_mask;
-	int sa_flags;
-};
-#define _SIGACTION_DECLARED
-#define __sigaction_defined
-#endif
-
-#define SIG_BLOCK   1
-#define SIG_UNBLOCK 2
-#define SIG_SETMASK 0
-
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-#define SA_NOCLDSTOP 0x00000001
-#define SA_ONSTACK   0x00000002
-#endif
-#define SA_RESETHAND 0x00000004
-#define SA_RESTART   0x00000008
-#define SA_SIGINFO   0x00000010
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-#define SA_NOCLDWAIT 0x00000020
-#endif
-#define SA_NODEFER  0x00000040
-#define SS_ONSTACK  0x00000001
-#define SS_DISABLE  0x00000002
-#define MINSIGSTKSZ 4096
-#define SIGSTKSZ    4096
-
-#if !defined(_MCONTEXT_T_DECLARED) && !defined(__mcontext_t_defined)
-typedef struct {
-	/* FIXME: there should be a much better Zephyr-specific structure that can be used here */
-	unsigned long gregs[32];
-	unsigned long flags;
-} mcontext_t;
-#define _MCONTEXT_T_DECLARED
-#define __mcontext_defined
-#endif
-
-/* slightly out of order w.r.t. the specification */
-#if !defined(_STACK_T_DECLARED) && !defined(__stack_t_defined)
-typedef struct {
-	void *ss_sp;
-	size_t ss_size;
-	int ss_flags;
-} stack_t;
-#define _STACK_T_DECLARED
-#define __stack_t_defined
-#endif
-
-#if !defined(_UCONTEXT_T_DECLARED) && !defined(__ucontext_t_defined)
-typedef struct {
-	struct ucontext *uc_link;
-	sigset_t uc_sigmask;
-	stack_t uc_stack;
-	mcontext_t uc_mcontext;
-} ucontext_t;
-#define _UCONTEXT_T_DECLARED
-#define __ucontext_defined
-#endif
-
-#endif /* defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__) */
-
-/* Siginfo codes are defined below */
-
-#if !defined(_SIGHANDLER_T_DECLARED) && !defined(__sighandler_t_defined)
-typedef void (*sighandler_t)(int sig);
-#define _SIGHANDLER_T_DECLARED
-#define __sighandler_t_defined
-#endif
-
-int kill(pid_t pid, int sig);
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-int killpg(pid_t pgrp, int sig);
-#endif
-void psiginfo(const siginfo_t *info, const char *message);
-void psignal(int sig, const char *message);
-#if defined(_POSIX_THREADS) || defined(__DOXYGEN__)
-int pthread_kill(pthread_t thread, int sig);
-int pthread_sigmask(int how, const sigset_t *ZRESTRICT set, sigset_t *ZRESTRICT oset);
-#endif
-/* raise() must be defined by the libc signal.h */
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-TOOLCHAIN_DISABLE_WARNING(TOOLCHAIN_WARNING_SHADOW);
-int sigaction(int sig, const struct sigaction *ZRESTRICT act, struct sigaction *ZRESTRICT oact);
-TOOLCHAIN_ENABLE_WARNING(TOOLCHAIN_WARNING_SHADOW);
-#endif
-int sigaddset(sigset_t *set, int sig);
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-int sigaltstack(const stack_t *ZRESTRICT ss, stack_t *ZRESTRICT oss);
-#endif
-int sigdelset(sigset_t *set, int sig);
-int sigemptyset(sigset_t *set);
-int sigfillset(sigset_t *set);
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-int sighold(int sig);
-int sigignore(int sig);
-int siginterrupt(int sig, int flag);
-#endif
-int sigismember(const sigset_t *set, int sig);
-/* signal() must be defined by the libc signal.h */
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-int sigpause(int sig);
-#endif
-int sigpending(sigset_t *set);
-int sigprocmask(int how, const sigset_t *ZRESTRICT set, sigset_t *ZRESTRICT oset);
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-int sigqueue(pid_t pid, int sig, union sigval value);
-#endif
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-int sigrelse(int sig);
-sighandler_t sigset(int sig, sighandler_t disp);
-#endif
-int sigsuspend(const sigset_t *set);
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-int sigtimedwait(const sigset_t *ZRESTRICT set, siginfo_t *ZRESTRICT info,
-		 const struct timespec *ZRESTRICT timeout);
-#endif
-int sigwait(const sigset_t *ZRESTRICT set, int *ZRESTRICT sig);
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-int sigwaitinfo(const sigset_t *ZRESTRICT set, siginfo_t *ZRESTRICT info);
-#endif
-
-/* Note: only ANSI / ISO C signals are guarded below */
-
-#define SIGHUP 1 /**< Hangup */
-#if !defined(SIGINT) || defined(__DOXYGEN__)
-#define SIGINT 2 /**< Interrupt */
-#endif
-#define SIGQUIT 3 /**< Quit */
-#if !defined(SIGILL) || defined(__DOXYGEN__)
-#define SIGILL 4 /**< Illegal instruction */
-#endif
-#define SIGTRAP 5 /**< Trace/breakpoint trap */
-#if !defined(SIGABRT) || defined(__DOXYGEN__)
-#define SIGABRT 6 /**< Aborted */
-#endif
-#define SIGBUS 7 /**< Bus error */
-#if !defined(SIGFPE) || defined(__DOXYGEN__)
-#define SIGFPE 8 /**< Arithmetic exception */
-#endif
-#define SIGKILL 9  /**< Killed */
-#define SIGUSR1 10 /**< User-defined signal 1 */
-#if !defined(SIGSEGV) || defined(__DOXYGEN__)
-#define SIGSEGV 11 /**< Invalid memory reference */
-#endif
-#define SIGUSR2 12 /**< User-defined signal 2 */
-#define SIGPIPE 13 /**< Broken pipe */
-#define SIGALRM 14 /**< Alarm clock */
-#if !defined(SIGTERM) || defined(__DOXYGEN__)
-#define SIGTERM 15 /**< Terminated */
-#endif
-/* 16 not used */
-#define SIGCHLD   17 /**< Child status changed */
-#define SIGCONT   18 /**< Continued */
-#define SIGSTOP   19 /**< Stop executing */
-#define SIGTSTP   20 /**< Stopped */
-#define SIGTTIN   21 /**< Stopped (read) */
-#define SIGTTOU   22 /**< Stopped (write) */
-#define SIGURG    23 /**< Urgent I/O condition */
-#define SIGXCPU   24 /**< CPU time limit exceeded */
-#define SIGXFSZ   25 /**< File size limit exceeded */
-#define SIGVTALRM 26 /**< Virtual timer expired */
-#define SIGPROF   27 /**< Profiling timer expired */
-/* 28 not used */
-#define SIGPOLL   29 /**< Pollable event occurred */
-/* 30 not used */
-#define SIGSYS    31 /**< Bad system call */
-
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-
-/* SIGILL */
-#define ILL_ILLOPC 1 /**< Illegal opcode */
-#define ILL_ILLOPN 2 /**< Illegal operand */
-#define ILL_ILLADR 3 /**< Illegal addressing mode */
-#define ILL_ILLTRP 4 /**< Illegal trap */
-#define ILL_PRVOPC 5 /**< Privileged opcode */
-#define ILL_PRVREG 6 /**< Privileged register */
-#define ILL_COPROC 7 /**< Coprocessor error */
-#define ILL_BADSTK 8 /**< Internal stack error */
-
-/* SIGFPE */
-#define FPE_INTDIV 9  /**< Integer divide by zero */
-#define FPE_INTOVF 10 /**< Integer overflow */
-#define FPE_FLTDIV 11 /**< Floating-point divide by zero */
-#define FPE_FLTOVF 12 /**< Floating-point overflow */
-#define FPE_FLTUND 13 /**< Floating-point underflow */
-#define FPE_FLTRES 15 /**< Floating-point inexact result */
-#define FPE_FLTINV 16 /**< Invalid floating-point operation */
-#define FPE_FLTSUB 17 /**< Subscript out of range */
-
-/* SIGSEGV */
-#define SEGV_MAPERR 18 /**< Address not mapped to object */
-#define SEGV_ACCERR 19 /**< Invalid permissions for mapped object */
-
-/* SIGBUS */
-#define BUS_ADRALN 20 /**< Invalid address alignment */
-#define BUS_ADRERR 21 /**< Nonexistent physical address */
-#define BUS_OBJERR 22 /**< Object-specific hardware error */
-
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-/* SIGTRAP */
-#define TRAP_BRKPT 23 /**< Process breakpoint */
-#define TRAP_TRACE 24 /**< Process trace trap */
-#endif
-
-/* SIGCHLD */
-#define CLD_EXITED    25 /**< Child has exited */
-#define CLD_KILLED    26 /**< Child has terminated abnormally and did not create a core file */
-#define CLD_DUMPED    27 /**< Child has terminated abnormally and created a core file */
-#define CLD_TRAPPED   28 /**< Traced child has trapped */
-#define CLD_STOPPED   29 /**< Child has stopped */
-#define CLD_CONTINUED 30 /**< Stopped child has continued */
-
-#if defined(_XOPEN_STREAMS) || defined(__DOXYGEN__)
-/* SIGPOLL */
-#define POLL_IN  31 /**< Data input available */
-#define POLL_OUT 32 /**< Output buffers available */
-#define POLL_MSG 33 /**< Input message available */
-#define POLL_ERR 34 /**< I/O error */
-#define POLL_PRI 35 /**< High priority input available */
-#define POLL_HUP 36 /**< Device disconnected */
-#endif
-
-/* Any */
-#define SI_USER    37 /**< Signal sent by kill() */
-#define SI_QUEUE   38 /**< Signal sent by sigqueue() */
-#define SI_TIMER   39 /**< Signal generated by expiration of a timer set by timer_settime() */
-#define SI_ASYNCIO 40 /**< Signal generated by completion of an asynchronous I/O request */
-#define SI_MESGQ   41 /**< Signal generated by arrival of a message on an empty message queue */
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__) */
-
-#endif /* ZEPHYR_INCLUDE_POSIX_POSIX_SIGNAL_H_ */
diff --git a/include/zephyr/posix/posix_stdlib.h b/include/zephyr/posix/posix_stdlib.h
deleted file mode 100644
index 807fcf5fc76..00000000000
--- a/include/zephyr/posix/posix_stdlib.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (c) 2025 The Zephyr Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_POSIX_STDLIB_H_
-#define ZEPHYR_INCLUDE_POSIX_POSIX_STDLIB_H_
-
-#include <stddef.h> /* NULL, size_t */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* TODO: additional POSIX signatures here */
-
-#if defined(_BSD_SOURCE) || defined(__DOXYGEN__)
-int getenv_r(const char *name, char *buf, size_t len);
-#endif
-
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-int putenv(char *string);
-#endif
-
-#if defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__)
-int setenv(const char *envname, const char *envval, int overwrite);
-int unsetenv(const char *name);
-#endif /* defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__) */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_POSIX_STDLIB_H_ */
diff --git a/include/zephyr/posix/posix_string.h b/include/zephyr/posix/posix_string.h
deleted file mode 100644
index 2770942a3af..00000000000
--- a/include/zephyr/posix/posix_string.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (c) 2025 The Zephyr Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_POSIX_STRING_H_
-#define ZEPHYR_INCLUDE_POSIX_POSIX_STRING_H_
-
-#if defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__)
-
-#include <stddef.h> /* NULL, size_t */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* TODO: additional POSIX signatures here */
-
-char *strsignal(int signo);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__) */
-
-#endif /* ZEPHYR_INCLUDE_POSIX_POSIX_STRING_H_ */
diff --git a/include/zephyr/posix/posix_time.h b/include/zephyr/posix/posix_time.h
deleted file mode 100644
index ed3d1c37b8e..00000000000
--- a/include/zephyr/posix/posix_time.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright The Zephyr Project Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_ZEPHYR_POSIX_POSIX_TIME_H_
-#define ZEPHYR_INCLUDE_ZEPHYR_POSIX_POSIX_TIME_H_
-
-#if defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__)
-
-#include <stddef.h>
-
-#include <zephyr/sys/clock.h>
-#include <zephyr/toolchain.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* clock_t must be defined in the libc time.h */
-/* size_t must be defined in the libc stddef.h */
-/* time_t must be defined in the libc time.h */
-
-#if !defined(_CLOCKID_T_DECLARED) && !defined(__clockid_t_defined)
-typedef unsigned long clockid_t;
-#define _CLOCKID_T_DECLARED
-#define __clockid_t_defined
-#endif
-
-#if !defined(_TIMER_T_DECLARED) && !defined(__timer_t_defined)
-typedef unsigned long timer_t;
-#define _TIMER_T_DECLARED
-#define __timer_t_defined
-#endif
-
-#if !defined(_LOCALE_T_DECLARED) && !defined(__locale_t_defined)
-#ifdef CONFIG_NEWLIB_LIBC
-struct __locale_t;
-typedef struct __locale_t *locale_t;
-#else
-typedef void *locale_t;
-#endif
-#define _LOCALE_T_DECLARED
-#define __locale_t_defined
-#endif
-
-#if !defined(_PID_T_DECLARED) && !defined(__pid_t_defined)
-typedef int pid_t;
-#define _PID_T_DECLARED
-#define __pid_t_defined
-#endif
-
-struct sigevent;
-
-/* struct tm must be defined in the libc time.h */
-
-#if __STDC_VERSION__ >= 201112L
-/* struct timespec must be defined in the libc time.h */
-#else
-#if !defined(_TIMESPEC_DECLARED) && !defined(__timespec_defined)
-struct timespec {
-	time_t tv_sec;
-	long tv_nsec;
-};
-#define _TIMESPEC_DECLARED
-#define __timespec_defined
-#endif
-#endif
-
-#if !defined(_ITIMERSPEC_DECLARED) && !defined(__itimerspec_defined)
-struct itimerspec {
-	struct timespec it_interval;
-	struct timespec it_value;
-};
-#define _ITIMERSPEC_DECLARED
-#define __itimerspec_defined
-#endif
-
-/* NULL must be defined in the libc stddef.h */
-
-#ifndef CLOCK_REALTIME
-#define CLOCK_REALTIME ((clockid_t)SYS_CLOCK_REALTIME)
-#endif
-
-#ifndef CLOCKS_PER_SEC
-#if defined(_XOPEN_SOURCE)
-#define CLOCKS_PER_SEC 1000000
-#else
-#define CLOCKS_PER_SEC CONFIG_SYS_CLOCK_TICKS_PER_SEC
-#endif
-#endif
-
-#if defined(_POSIX_CPUTIME) || defined(__DOXYGEN__)
-#ifndef CLOCK_PROCESS_CPUTIME_ID
-#define CLOCK_PROCESS_CPUTIME_ID ((clockid_t)2)
-#endif
-#endif
-
-#if defined(_POSIX_THREAD_CPUTIME) || defined(__DOXYGEN__)
-#ifndef CLOCK_THREAD_CPUTIME_ID
-#define CLOCK_THREAD_CPUTIME_ID ((clockid_t)3)
-#endif
-#endif
-
-#if defined(_POSIX_MONOTONIC_CLOCK) || defined(__DOXYGEN__)
-#ifndef CLOCK_MONOTONIC
-#define CLOCK_MONOTONIC ((clockid_t)SYS_CLOCK_MONOTONIC)
-#endif
-#endif
-
-#ifndef TIMER_ABSTIME
-#define TIMER_ABSTIME SYS_TIMER_ABSTIME
-#endif
-
-/* asctime() must be declared in the libc time.h */
-#if defined(_POSIX_THREAD_SAFE_FUNCTIONS) || defined(__DOXYGEN__)
-char *asctime_r(const struct tm *ZRESTRICT tm, char *ZRESTRICT buf);
-#endif
-/* clock() must be declared in the libc time.h */
-#if defined(_POSIX_CPUTIME) || defined(__DOXYGEN__)
-int clock_getcpuclockid(pid_t pid, clockid_t *clock_id);
-#endif
-#if defined(_POSIX_TIMERS) || defined(__DOXYGEN__)
-int clock_getres(clockid_t clock_id, struct timespec *ts);
-int clock_gettime(clockid_t clock_id, struct timespec *ts);
-#endif
-#if defined(_POSIX_CLOCK_SELECTION) || defined(__DOXYGEN__)
-int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp,
-		    struct timespec *rmtp);
-#endif
-#if defined(_POSIX_TIMERS) || defined(__DOXYGEN__)
-int clock_settime(clockid_t clock_id, const struct timespec *ts);
-#endif
-/* ctime() must be declared in the libc time.h */
-#if defined(_POSIX_THREAD_SAFE_FUNCTIONS) || defined(__DOXYGEN__)
-char *ctime_r(const time_t *clock, char *buf);
-#endif
-/* difftime() must be declared in the libc time.h */
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-struct tm *getdate(const char *string);
-#endif
-/* gmtime() must be declared in the libc time.h */
-#if __STDC_VERSION__ >= 202311L
-/* gmtime_r() must be declared in the libc time.h */
-#else
-#if defined(_POSIX_THREAD_SAFE_FUNCTIONS) || defined(__DOXYGEN__)
-struct tm *gmtime_r(const time_t *ZRESTRICT timer, struct tm *ZRESTRICT result);
-#endif
-#endif
-/* localtime() must be declared in the libc time.h */
-#if __STDC_VERSION__ >= 202311L
-/* localtime_r() must be declared in the libc time.h */
-#else
-#if defined(_POSIX_THREAD_SAFE_FUNCTIONS) || defined(__DOXYGEN__)
-struct tm *localtime_r(const time_t *ZRESTRICT timer, struct tm *ZRESTRICT result);
-#endif
-#endif
-/* mktime() must be declared in the libc time.h */
-#if defined(_POSIX_TIMERS) || defined(__DOXYGEN__)
-int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);
-#endif
-/* strftime() must be declared in the libc time.h */
-size_t strftime_l(char *ZRESTRICT s, size_t maxsize, const char *ZRESTRICT format,
-		  const struct tm *ZRESTRICT timeptr, locale_t locale);
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-char *strptime(const char *ZRESTRICT s, const char *ZRESTRICT format, struct tm *ZRESTRICT tm);
-#endif
-/* time() must be declared in the libc time.h */
-#if defined(_POSIX_TIMERS) || defined(__DOXYGEN__)
-int timer_create(clockid_t clockId, struct sigevent *ZRESTRICT evp, timer_t *ZRESTRICT timerid);
-int timer_delete(timer_t timerid);
-int timer_getoverrun(timer_t timerid);
-int timer_gettime(timer_t timerid, struct itimerspec *its);
-int timer_settime(timer_t timerid, int flags, const struct itimerspec *value,
-		  struct itimerspec *ovalue);
-#endif
-
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-extern int daylight;
-extern long timezone;
-#endif
-
-extern char *tzname[];
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__) */
-
-#endif /* ZEPHYR_INCLUDE_ZEPHYR_POSIX_POSIX_TIME_H_ */
diff --git a/include/zephyr/posix/pthread.h b/include/zephyr/posix/pthread.h
deleted file mode 100644
index ac7b0f133a7..00000000000
--- a/include/zephyr/posix/pthread.h
+++ /dev/null
@@ -1,560 +0,0 @@
-/*
- * Copyright (c) 2017 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_PTHREAD_H_
-#define ZEPHYR_INCLUDE_POSIX_PTHREAD_H_
-
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-
-#include <zephyr/kernel.h>
-#include <unistd.h>
-#include <sched.h>
-
-#include <zephyr/posix/sys/_pthreadtypes.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Pthread detach/joinable
- * Undefine possibly predefined values by external toolchain headers
- */
-#undef PTHREAD_CREATE_DETACHED
-#define PTHREAD_CREATE_DETACHED 1
-#undef PTHREAD_CREATE_JOINABLE
-#define PTHREAD_CREATE_JOINABLE 0
-
-/* Pthread resource visibility */
-#define PTHREAD_PROCESS_PRIVATE 0
-#define PTHREAD_PROCESS_SHARED  1
-
-/* Pthread cancellation */
-#define PTHREAD_CANCELED       ((void *)-1)
-#define PTHREAD_CANCEL_ENABLE  0
-#define PTHREAD_CANCEL_DISABLE 1
-#define PTHREAD_CANCEL_DEFERRED     0
-#define PTHREAD_CANCEL_ASYNCHRONOUS 1
-
-/* Pthread scope */
-#undef PTHREAD_SCOPE_PROCESS
-#define PTHREAD_SCOPE_PROCESS    1
-#undef PTHREAD_SCOPE_SYSTEM
-#define PTHREAD_SCOPE_SYSTEM     0
-
-/* Pthread inherit scheduler */
-#undef PTHREAD_INHERIT_SCHED
-#define PTHREAD_INHERIT_SCHED  0
-#undef PTHREAD_EXPLICIT_SCHED
-#define PTHREAD_EXPLICIT_SCHED 1
-
-/* Passed to pthread_once */
-#define PTHREAD_ONCE_INIT {0}
-
-/* The minimum allowable stack size */
-#define PTHREAD_STACK_MIN K_KERNEL_STACK_LEN(0)
-
-/**
- * @brief Declare a condition variable as initialized
- *
- * Initialize a condition variable with the default condition variable attributes.
- */
-#define PTHREAD_COND_INITIALIZER (-1)
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *att);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_cond_destroy(pthread_cond_t *cv);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_cond_signal(pthread_cond_t *cv);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_cond_broadcast(pthread_cond_t *cv);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mut);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *mut,
-			   const struct timespec *abstime);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1.
- *
- */
-int pthread_condattr_init(pthread_condattr_t *att);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- *
- */
-int pthread_condattr_destroy(pthread_condattr_t *att);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- *
- */
-int pthread_condattr_getclock(const pthread_condattr_t *ZRESTRICT att,
-		clockid_t *ZRESTRICT clock_id);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- *
- */
-
-int pthread_condattr_setclock(pthread_condattr_t *att, clockid_t clock_id);
-
-/**
- * @brief Declare a mutex as initialized
- *
- * Initialize a mutex with the default mutex attributes.
- */
-#define PTHREAD_MUTEX_INITIALIZER (-1)
-
-/**
- * @brief Declare a rwlock as initialized
- *
- * Initialize a rwlock with the default rwlock attributes.
- */
-#define PTHREAD_RWLOCK_INITIALIZER (-1)
-
-/*
- *  Mutex attributes - type
- *
- *  PTHREAD_MUTEX_NORMAL: Owner of mutex cannot relock it. Attempting
- *      to relock will cause deadlock.
- *  PTHREAD_MUTEX_RECURSIVE: Owner can relock the mutex.
- *  PTHREAD_MUTEX_ERRORCHECK: If owner attempts to relock the mutex, an
- *      error is returned.
- *
- */
-#define PTHREAD_MUTEX_NORMAL        0
-#define PTHREAD_MUTEX_RECURSIVE     1
-#define PTHREAD_MUTEX_ERRORCHECK    2
-#define PTHREAD_MUTEX_DEFAULT       3
-
-/*
- *  Mutex attributes - protocol
- *
- *  PTHREAD_PRIO_NONE: Ownership of mutex does not affect priority.
- *  PTHREAD_PRIO_INHERIT: Owner's priority is boosted to the priority of
- *      highest priority thread blocked on the mutex.
- *  PTHREAD_PRIO_PROTECT:  Mutex has a priority ceiling.  The owner's
- *      priority is boosted to the highest priority ceiling of all mutexes
- *      owned (regardless of whether or not other threads are blocked on
- *      any of these mutexes).
- *  FIXME: Only PRIO_NONE is supported. Implement other protocols.
- */
-#define PTHREAD_PRIO_NONE           0
-#define PTHREAD_PRIO_INHERIT        1
-#define PTHREAD_PRIO_PROTECT        2
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_destroy(pthread_mutex_t *m);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_lock(pthread_mutex_t *m);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_unlock(pthread_mutex_t *m);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-
-int pthread_mutex_timedlock(pthread_mutex_t *m,
-			    const struct timespec *abstime);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_trylock(pthread_mutex_t *m);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_init(pthread_mutex_t *m,
-				     const pthread_mutexattr_t *att);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_setprotocol(pthread_mutexattr_t *attr, int protocol);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *attr,
-				  int *protocol);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- *
- * Note that pthread attribute structs are currently noops in Zephyr.
- */
-int pthread_mutexattr_init(pthread_mutexattr_t *attr);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- *
- * Note that pthread attribute structs are currently noops in Zephyr.
- */
-int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
-
-#define PTHREAD_BARRIER_SERIAL_THREAD 1
-
-/*
- *  Barrier attributes - type
- */
-#define PTHREAD_PROCESS_PRIVATE 0
-#define PTHREAD_PROCESS_SHARED  1
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_barrier_wait(pthread_barrier_t *b);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_barrier_init(pthread_barrier_t *b, const pthread_barrierattr_t *attr,
-			 unsigned int count);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_barrier_destroy(pthread_barrier_t *b);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_barrierattr_init(pthread_barrierattr_t *b);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_barrierattr_destroy(pthread_barrierattr_t *b);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr, int pshared);
-
-/**
- * @brief POSIX threading compatibility API
- *
- * See IEEE 1003.1
- */
-int pthread_barrierattr_getpshared(const pthread_barrierattr_t *ZRESTRICT attr,
-				   int *ZRESTRICT pshared);
-
-/* Predicates and setters for various pthread attribute values that we
- * don't support (or always support: the "process shared" attribute
- * can only be true given the way Zephyr implements these
- * objects). Leave these undefined for simplicity instead of defining
- * stubs to return an error that would have to be logged and
- * interpreted just to figure out that we didn't support it in the
- * first place. These APIs are very rarely used even in production
- * Unix code.  Leave the declarations here so they can be easily
- * uncommented and implemented as needed.
-
-int pthread_condattr_getpshared(const pthread_condattr_t * int *);
-int pthread_condattr_setpshared(pthread_condattr_t *, int);
-int pthread_mutex_consistent(pthread_mutex_t *);
-int pthread_mutexattr_getpshared(const pthread_mutexattr_t * int *);
-int pthread_mutexattr_getrobust(const pthread_mutexattr_t * int *);
-int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
-int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int);
-*/
-
-#ifdef CONFIG_POSIX_THREAD_PRIO_PROTECT
-int pthread_mutex_getprioceiling(const pthread_mutex_t *ZRESTRICT mutex,
-				 int *ZRESTRICT prioceiling);
-int pthread_mutex_setprioceiling(pthread_mutex_t *ZRESTRICT mutex, int prioceiling,
-				 int *ZRESTRICT old_ceiling);
-int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *ZRESTRICT attr,
-				     int *ZRESTRICT prioceiling);
-int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *attr, int prioceiling);
-#endif /* CONFIG_POSIX_THREAD_PRIO_PROTECT */
-
-/* Base Pthread related APIs */
-
-/**
- * @brief Obtain ID of the calling thread.
- *
- * The results of calling this API from threads not created with
- * pthread_create() are undefined.
- *
- * See IEEE 1003.1
- */
-pthread_t pthread_self(void);
-
-/**
- * @brief Compare thread IDs.
- *
- * See IEEE 1003.1
- */
-int pthread_equal(pthread_t pt1, pthread_t pt2);
-
-/**
- * @brief Destroy the read-write lock attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
-
-/**
- * @brief initialize the read-write lock attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
-
-int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *ZRESTRICT attr,
-				  int *ZRESTRICT pshared);
-int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);
-
-int pthread_attr_getguardsize(const pthread_attr_t *ZRESTRICT attr, size_t *ZRESTRICT guardsize);
-int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
-int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
-int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
-int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
-int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);
-int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
-int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
-int pthread_attr_init(pthread_attr_t *attr);
-int pthread_attr_destroy(pthread_attr_t *attr);
-int pthread_attr_getschedparam(const pthread_attr_t *attr,
-			       struct sched_param *schedparam);
-int pthread_getschedparam(pthread_t pthread, int *policy,
-			  struct sched_param *param);
-int pthread_attr_getstack(const pthread_attr_t *attr,
-			  void **stackaddr, size_t *stacksize);
-int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,
-			  size_t stacksize);
-int pthread_attr_getscope(const pthread_attr_t *attr, int *contentionscope);
-int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);
-int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inheritsched);
-int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);
-#ifdef CONFIG_POSIX_THREADS
-int pthread_once(pthread_once_t *once, void (*initFunc)(void));
-#endif
-FUNC_NORETURN void pthread_exit(void *retval);
-int pthread_timedjoin_np(pthread_t thread, void **status, const struct timespec *abstime);
-int pthread_tryjoin_np(pthread_t thread, void **status);
-int pthread_join(pthread_t thread, void **status);
-int pthread_cancel(pthread_t pthread);
-int pthread_detach(pthread_t thread);
-int pthread_create(pthread_t *newthread, const pthread_attr_t *attr,
-		   void *(*threadroutine)(void *), void *arg);
-int pthread_setcancelstate(int state, int *oldstate);
-int pthread_setcanceltype(int type, int *oldtype);
-void pthread_testcancel(void);
-int pthread_attr_setschedparam(pthread_attr_t *attr,
-			       const struct sched_param *schedparam);
-int pthread_setschedparam(pthread_t pthread, int policy,
-			  const struct sched_param *param);
-int pthread_setschedprio(pthread_t thread, int prio);
-int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
-int pthread_rwlock_init(pthread_rwlock_t *rwlock,
-			const pthread_rwlockattr_t *attr);
-int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
-int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock,
-			       const struct timespec *abstime);
-int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock,
-			       const struct timespec *abstime);
-int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
-int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
-int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
-int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
-int pthread_key_create(pthread_key_t *key,
-		void (*destructor)(void *));
-int pthread_key_delete(pthread_key_t key);
-int pthread_setspecific(pthread_key_t key, const void *value);
-void *pthread_getspecific(pthread_key_t key);
-int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
-int pthread_getconcurrency(void);
-int pthread_setconcurrency(int new_level);
-
-void __z_pthread_cleanup_push(void *cleanup[3], void (*routine)(void *arg), void *arg);
-void __z_pthread_cleanup_pop(int execute);
-
-#define pthread_cleanup_push(_rtn, _arg)                                                           \
-	do /* enforce '{'-like behaviour */ {                                                      \
-		void *_z_pthread_cleanup[3];                                                       \
-		__z_pthread_cleanup_push(_z_pthread_cleanup, _rtn, _arg)
-
-#define pthread_cleanup_pop(_ex)                                                                   \
-		__z_pthread_cleanup_pop(_ex);                                                      \
-	} /* enforce '}'-like behaviour */ while (0)
-
-/* Glibc / Oracle Extension Functions */
-
-/**
- * @brief Set name of POSIX thread.
- *
- * Non-portable, extension function that conforms with most
- * other definitions of this function.
- *
- * @param thread POSIX thread to set name
- * @param name Name string
- * @retval 0 Success
- * @retval ESRCH Thread does not exist
- * @retval EINVAL Name buffer is NULL
- * @retval Negative value if kernel function error
- *
- */
-int pthread_setname_np(pthread_t thread, const char *name);
-
-/**
- * @brief Get name of POSIX thread and store in name buffer
- *  	  that is of size len.
- *
- * Non-portable, extension function that conforms with most
- * other definitions of this function.
- *
- * @param thread POSIX thread to obtain name information
- * @param name Destination buffer
- * @param len Destination buffer size
- * @retval 0 Success
- * @retval ESRCH Thread does not exist
- * @retval EINVAL Name buffer is NULL
- * @retval Negative value if kernel function error
- */
-int pthread_getname_np(pthread_t thread, char *name, size_t len);
-
-#ifdef CONFIG_POSIX_THREADS
-
-/**
- * @brief Destroy a pthread_spinlock_t.
- *
- * See IEEE 1003.1
- */
-int pthread_spin_destroy(pthread_spinlock_t *lock);
-
-/**
- * @brief Initialize a thread_spinlock_t.
- *
- * See IEEE 1003.1
- */
-int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
-
-/**
- * @brief Lock a previously initialized thread_spinlock_t.
- *
- * See IEEE 1003.1
- */
-int pthread_spin_lock(pthread_spinlock_t *lock);
-
-/**
- * @brief Attempt to lock a previously initialized thread_spinlock_t.
- *
- * See IEEE 1003.1
- */
-int pthread_spin_trylock(pthread_spinlock_t *lock);
-
-/**
- * @brief Unlock a previously locked thread_spinlock_t.
- *
- * See IEEE 1003.1
- */
-int pthread_spin_unlock(pthread_spinlock_t *lock);
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_PTHREAD_H_ */
diff --git a/include/zephyr/posix/pwd.h b/include/zephyr/posix/pwd.h
deleted file mode 100644
index 48af8afddc2..00000000000
--- a/include/zephyr/posix/pwd.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2024 Meta Platforms
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_PWD_H_
-#define ZEPHYR_INCLUDE_POSIX_PWD_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <sys/stat.h>
-
-struct passwd {
-	/* user's login name */
-	char *pw_name;
-	/* numerical user ID */
-	uid_t pw_uid;
-	/* numerical group ID */
-	gid_t pw_gid;
-	/* initial working directory */
-	char *pw_dir;
-	/* program to use as shell */
-	char *pw_shell;
-};
-
-int getpwnam_r(const char *nam, struct passwd *pwd, char *buffer, size_t bufsize,
-	       struct passwd **result);
-int getpwuid_r(uid_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_PWD_H_ */
diff --git a/include/zephyr/posix/sched.h b/include/zephyr/posix/sched.h
deleted file mode 100644
index 384c7553c98..00000000000
--- a/include/zephyr/posix/sched.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2018-2023 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SCHED_H_
-#define ZEPHYR_INCLUDE_POSIX_SCHED_H_
-
-#include <sys/types.h>
-#include <time.h>
-
-#include <zephyr/kernel.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Other mandatory scheduling policy. Must be numerically distinct. May
- * execute identically to SCHED_RR or SCHED_FIFO. For Zephyr this is a
- * pseudonym for SCHED_RR.
- */
-#define SCHED_OTHER 0
-
-/* Cooperative scheduling policy */
-#define SCHED_FIFO 1
-
-/* Priority based preemptive scheduling policy */
-#define SCHED_RR 2
-
-#if defined(CONFIG_MINIMAL_LIBC) || defined(CONFIG_PICOLIBC) || defined(CONFIG_ARMCLANG_STD_LIBC) \
-	|| defined(CONFIG_ARCMWDT_LIBC)
-struct sched_param {
-	int sched_priority;
-};
-#endif
-
-/**
- * @brief Yield the processor
- *
- * See IEEE 1003.1
- */
-int sched_yield(void);
-
-int sched_get_priority_min(int policy);
-int sched_get_priority_max(int policy);
-
-int sched_getparam(pid_t pid, struct sched_param *param);
-int sched_getscheduler(pid_t pid);
-
-int sched_setparam(pid_t pid, const struct sched_param *param);
-int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param);
-int sched_rr_get_interval(pid_t pid, struct timespec *interval);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SCHED_H_ */
diff --git a/include/zephyr/posix/semaphore.h b/include/zephyr/posix/semaphore.h
deleted file mode 100644
index 1b8548104c4..00000000000
--- a/include/zephyr/posix/semaphore.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SEMAPHORE_H_
-#define ZEPHYR_INCLUDE_POSIX_SEMAPHORE_H_
-
-#include <time.h>
-
-#include <zephyr/kernel.h>
-#include <zephyr/toolchain.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define SEM_FAILED ((sem_t *) 0)
-
-#if !(defined(_SEM_T_DECLARED) || defined(__sem_t_defined)) || defined(__DOXYGEN__)
-typedef struct k_sem sem_t;
-#define _SEM_T_DECLARED
-#define __sem_t_defined
-#endif
-
-int sem_destroy(sem_t *semaphore);
-int sem_getvalue(sem_t *ZRESTRICT semaphore, int *ZRESTRICT value);
-int sem_init(sem_t *semaphore, int pshared, unsigned int value);
-int sem_post(sem_t *semaphore);
-int sem_timedwait(sem_t *ZRESTRICT semaphore, struct timespec *ZRESTRICT abstime);
-int sem_trywait(sem_t *semaphore);
-int sem_wait(sem_t *semaphore);
-sem_t *sem_open(const char *name, int oflags, ...);
-int sem_unlink(const char *name);
-int sem_close(sem_t *sem);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SEMAPHORE_H_ */
diff --git a/include/zephyr/posix/stropts.h b/include/zephyr/posix/stropts.h
deleted file mode 100644
index 41afdb5ae28..00000000000
--- a/include/zephyr/posix/stropts.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2024 Abhinav Srivastava
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_STROPTS_H_
-#define ZEPHYR_INCLUDE_POSIX_STROPTS_H_
-#define RS_HIPRI BIT(0)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct strbuf {
-	int maxlen;
-	int len;
-	char *buf;
-};
-
-int putmsg(int fildes, const struct strbuf *ctlptr, const struct strbuf *dataptr, int flags);
-int fdetach(const char *path);
-int fattach(int fildes, const char *path);
-int getmsg(int fildes, struct strbuf *ctlptr, struct strbuf *dataptr, int *flagsp);
-int getpmsg(int fildes, struct strbuf *ctlptr, struct strbuf *dataptr, int *bandp, int *flagsp);
-int isastream(int fildes);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_STROPTS_H_ */
diff --git a/include/zephyr/posix/sys/_pthreadtypes.h b/include/zephyr/posix/sys/_pthreadtypes.h
deleted file mode 100644
index 3bc2a2048c9..00000000000
--- a/include/zephyr/posix/sys/_pthreadtypes.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (c) 2025 The Zephyr Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS__PTHREADTYPES_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS__PTHREADTYPES_H_
-
-#include <stdbool.h>
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !(defined(_PTHREAD_ATTR_T_DECLARED) || defined(__pthread_attr_t_defined)) ||                   \
-	defined(__DOXYGEN__)
-typedef struct {
-	void *stack;
-	uint32_t details[2];
-} pthread_attr_t;
-#define _PTHREAD_ATTR_T_DECLARED
-#define __pthread_attr_t_defined
-#endif
-
-#if !(defined(_PTHREAD_BARRIER_T_DECLARED) && defined(__pthread_barrier_t_defined)) ||             \
-	defined(__DOXYGEN__)
-typedef uint32_t pthread_barrier_t;
-#define _PTHREAD_BARRIER_T_DECLARED
-#define __pthread_barrier_t_defined
-#endif
-
-#if !(defined(_PTHREAD_BARRIERATTR_T_DECLARED) && defined(__pthread_barrierattr_t_defined)) ||     \
-	defined(__DOXYGEN__)
-typedef struct {
-	union {
-#if defined(_POSIX_PROCESS_SHARED) || defined(__DOXYGEN__)
-		int pshared;
-#endif
-		/* avoid "empty struct has size 0 in C, size 1 in C++ [-Wextern-c-compat]" */
-		int: 8;
-	};
-} pthread_barrierattr_t;
-#define _PTHREAD_BARRIERATTR_T_DECLARED
-#define __pthread_barrierattr_t_defined
-#endif
-
-#if !(defined(_PTHREAD_COND_T_DECLARED) && defined(__pthread_cond_t_defined)) ||                   \
-	defined(__DOXYGEN__)
-/* TODO: convert this to a long so that it can refer to a k_condvar (pointer) */
-typedef uint32_t pthread_cond_t;
-#define _PTHREAD_COND_T_DECLARED
-#define __pthread_cond_t_defined
-#endif
-
-#if !(defined(_PTHREAD_CONDATTR_T_DECLARED) && defined(__pthread_condattr_t_defined)) ||           \
-	defined(__DOXYGEN__)
-typedef struct {
-	clockid_t clock;
-} pthread_condattr_t;
-#define _PTHREAD_CONDATTR_T_DECLARED
-#define __pthread_condattr_t_defined
-#endif
-
-#if !(defined(_PTHREAD_KEY_T_DECLARED) && defined(__pthread_key_t_defined)) || defined(__DOXYGEN__)
-typedef uint32_t pthread_key_t;
-#define _PTHREAD_KEY_T_DECLARED
-#define __pthread_key_t_defined
-#endif
-
-#if !(defined(_PTHREAD_MUTEX_T_DECLARED) && defined(__pthread_mutex_t_defined)) ||                 \
-	defined(__DOXYGEN__)
-/* TODO: convert this to a long so that it can refer to a k_mutex (pointer) */
-typedef uint32_t pthread_mutex_t;
-#define _PTHREAD_MUTEX_T_DECLARED
-#define __pthread_mutex_t_defined
-#endif
-
-#if !(defined(_PTHREAD_MUTEXATTR_T_DECLARED) && defined(__pthread_mutexattr_t_defined)) ||         \
-	defined(__DOXYGEN__)
-typedef struct {
-	unsigned char type: 2;
-	bool initialized: 1;
-} pthread_mutexattr_t;
-#define _PTHREAD_MUTEXATTR_T_DECLARED
-#define __pthread_mutexattr_t_defined
-#endif
-
-#if !(defined(_PTHREAD_ONCE_T_DECLARED) && defined(__pthread_once_t_defined)) ||                   \
-	defined(__DOXYGEN__)
-typedef struct {
-	bool flag;
-} pthread_once_t;
-#define _PTHREAD_ONCE_T_DECLARED
-#define __pthread_once_t_defined
-#endif
-
-#if !(defined(_PTHREAD_RWLOCK_T_DECLARED) && defined(__pthread_rwlock_t_defined)) ||               \
-	defined(__DOXYGEN__)
-typedef uint32_t pthread_rwlock_t;
-#define _PTHREAD_RWLOCK_T_DECLARED
-#define __pthread_rwlock_t_defined
-#endif
-
-#if !(defined(_PTHREAD_RWLOCKATTR_T_DECLARED) && defined(__pthread_rwlockattr_t_defined)) ||       \
-	defined(__DOXYGEN__)
-typedef uint32_t pthread_rwlockattr_t;
-#define _PTHREAD_RWLOCKATTR_T_DECLARED
-#define __pthread_rwlockattr_t_defined
-#endif
-
-#if !(defined(_PTHREAD_SPINLOCK_T_DECLARED) && defined(__pthread_spinlock_t_defined)) ||           \
-	defined(__DOXYGEN__)
-/* TODO: convert this to a long so that it can refer to a sys_sem_t (pointer) */
-typedef uint32_t pthread_spinlock_t;
-#define _PTHREAD_SPINLOCK_T_DECLARED
-#define __pthread_spinlock_t_defined
-#endif
-
-#if !(defined(_PTHREAD_T_DECLARED) && defined(__pthread_t_defined)) || defined(__DOXYGEN__)
-/* TODO: convert this to a long so that it can refer to a k_thread (pointer) */
-typedef uint32_t pthread_t;
-#define _PTHREAD_T_DECLARED
-#define __pthread_t_defined
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS__PTHREADTYPES_H_ */
diff --git a/include/zephyr/posix/sys/confstr.h b/include/zephyr/posix/sys/confstr.h
deleted file mode 100644
index 55f1ab4a873..00000000000
--- a/include/zephyr/posix/sys/confstr.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_CONFSTR_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_CONFSTR_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-enum {
-	_CS_PATH,
-	_CS_POSIX_V7_ILP32_OFF32_CFLAGS,
-	_CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
-	_CS_POSIX_V7_ILP32_OFF32_LIBS,
-	_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
-	_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
-	_CS_POSIX_V7_ILP32_OFFBIG_LIBS,
-	_CS_POSIX_V7_LP64_OFF64_CFLAGS,
-	_CS_POSIX_V7_LP64_OFF64_LDFLAGS,
-	_CS_POSIX_V7_LP64_OFF64_LIBS,
-	_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
-	_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
-	_CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
-	_CS_POSIX_V7_THREADS_CFLAGS,
-	_CS_POSIX_V7_THREADS_LDFLAGS,
-	_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS,
-	_CS_V7_ENV,
-	_CS_POSIX_V6_ILP32_OFF32_CFLAGS,
-	_CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
-	_CS_POSIX_V6_ILP32_OFF32_LIBS,
-	_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
-	_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
-	_CS_POSIX_V6_ILP32_OFFBIG_LIBS,
-	_CS_POSIX_V6_LP64_OFF64_CFLAGS,
-	_CS_POSIX_V6_LP64_OFF64_LDFLAGS,
-	_CS_POSIX_V6_LP64_OFF64_LIBS,
-	_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
-	_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
-	_CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
-	_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS,
-	_CS_V6_ENV,
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_CONFSTR_H_ */
diff --git a/include/zephyr/posix/sys/eventfd.h b/include/zephyr/posix/sys/eventfd.h
deleted file mode 100644
index 35bef86d87e..00000000000
--- a/include/zephyr/posix/sys/eventfd.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2020 Tobias Svehagen
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_EVENTFD_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_EVENTFD_H_
-
-#include <zephyr/zvfs/eventfd.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define EFD_SEMAPHORE ZVFS_EFD_SEMAPHORE
-#define EFD_NONBLOCK  ZVFS_EFD_NONBLOCK
-
-typedef zvfs_eventfd_t eventfd_t;
-
-/**
- * @brief Create a file descriptor for event notification
- *
- * The returned file descriptor can be used with POSIX read/write calls or
- * with the eventfd_read/eventfd_write functions.
- *
- * It also supports polling and by including an eventfd in a call to poll,
- * it is possible to signal and wake the polling thread by simply writing to
- * the eventfd.
- *
- * When using read() and write() on an eventfd, the size must always be at
- * least 8 bytes or the operation will fail with EINVAL.
- *
- * @return New eventfd file descriptor on success, -1 on error
- */
-int eventfd(unsigned int initval, int flags);
-
-/**
- * @brief Read from an eventfd
- *
- * If call is successful, the value parameter will have the value 1
- *
- * @param fd File descriptor
- * @param value Pointer for storing the read value
- *
- * @return 0 on success, -1 on error
- */
-int eventfd_read(int fd, eventfd_t *value);
-
-/**
- * @brief Write to an eventfd
- *
- * @param fd File descriptor
- * @param value Value to write
- *
- * @return 0 on success, -1 on error
- */
-int eventfd_write(int fd, eventfd_t value);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_EVENTFD_H_ */
diff --git a/include/zephyr/posix/sys/ioctl.h b/include/zephyr/posix/sys/ioctl.h
deleted file mode 100644
index 04a819e7a98..00000000000
--- a/include/zephyr/posix/sys/ioctl.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_IOCTL_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_IOCTL_H_
-
-#include <zephyr/sys/fdtable.h>
-
-#define FIONBIO ZFD_IOCTL_FIONBIO
-#define FIONREAD ZFD_IOCTL_FIONREAD
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int ioctl(int fd, unsigned long request, ...);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_IOCTL_H_ */
diff --git a/include/zephyr/posix/sys/mman.h b/include/zephyr/posix/sys/mman.h
deleted file mode 100644
index 8cbf5fd8380..00000000000
--- a/include/zephyr/posix/sys/mman.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_ZEPHYR_POSIX_SYS_MMAN_H_
-#define ZEPHYR_INCLUDE_ZEPHYR_POSIX_SYS_MMAN_H_
-
-#include <stddef.h>
-#include <sys/types.h>
-
-#define PROT_NONE  0x0
-#define PROT_READ  0x1
-#define PROT_WRITE 0x2
-#define PROT_EXEC  0x4
-
-#define MAP_SHARED  0x1
-#define MAP_PRIVATE 0x2
-#define MAP_FIXED   0x4
-
-/* for Linux compatibility */
-#define MAP_ANONYMOUS 0x20
-
-#define MS_SYNC       0x0
-#define MS_ASYNC      0x1
-#define MS_INVALIDATE 0x2
-
-#define MAP_FAILED ((void *)-1)
-
-#define MCL_CURRENT 0
-#define MCL_FUTURE  1
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int mlock(const void *addr, size_t len);
-int mlockall(int flags);
-void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);
-int msync(void *addr, size_t length, int flags);
-int munlock(const void *addr, size_t len);
-int munlockall(void);
-int munmap(void *addr, size_t len);
-int shm_open(const char *name, int oflag, mode_t mode);
-int shm_unlink(const char *name);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_ZEPHYR_POSIX_SYS_MMAN_H_ */
diff --git a/include/zephyr/posix/sys/select.h b/include/zephyr/posix/sys/select.h
deleted file mode 100644
index 495bc919ae0..00000000000
--- a/include/zephyr/posix/sys/select.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_SELECT_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_SELECT_H_
-
-#include <zephyr/sys/fdtable.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define FD_SETSIZE ZVFS_FD_SETSIZE
-
-#if !defined(_SIGSET_T_DECLARED) && !defined(__sigset_t_defined)
-
-#ifndef SIGRTMIN
-#define SIGRTMIN 32
-#endif
-#if defined(_POSIX_REALTIME_SIGNALS) || defined(__DOXYGEN__)
-BUILD_ASSERT(CONFIG_POSIX_RTSIG_MAX >= 0);
-#define SIGRTMAX (SIGRTMIN + CONFIG_POSIX_RTSIG_MAX)
-#else
-#define SIGRTMAX SIGRTMIN
-#endif
-
-typedef struct {
-	unsigned long sig[DIV_ROUND_UP(SIGRTMAX + 1, BITS_PER_LONG)];
-} sigset_t;
-#define _SIGSET_T_DECLARED
-#define __sigset_t_defined
-#endif
-
-#if !defined(_SUSECONDS_T_DECLARED) && !defined(__suseconds_t_defined)
-typedef long suseconds_t;
-#define _SUSECONDS_T_DECLARED
-#define __suseconds_t_defined
-#endif
-
-/* time_t must be defined by the libc time.h */
-#include <time.h>
-
-#if __STDC_VERSION__ >= 201112L
-/* struct timespec must be defined in the libc time.h */
-#else
-#if !defined(_TIMESPEC_DECLARED) && !defined(__timespec_defined)
-struct timespec {
-	time_t tv_sec;
-	long tv_nsec;
-};
-#define _TIMESPEC_DECLARED
-#define __timespec_defined
-#endif
-#endif
-
-#if !defined(_TIMEVAL_DECLARED) && !defined(__timeval_defined)
-struct timeval {
-	time_t tv_sec;
-	suseconds_t tv_usec;
-};
-#define _TIMEVAL_DECLARED
-#define __timeval_defined
-#endif
-
-typedef struct zvfs_fd_set fd_set;
-
-struct timeval;
-
-int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
-	    const struct timespec *timeout, const sigset_t *sigmask);
-int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
-void FD_CLR(int fd, fd_set *fdset);
-int FD_ISSET(int fd, fd_set *fdset);
-void FD_SET(int fd, fd_set *fdset);
-void FD_ZERO(fd_set *fdset);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_SELECT_H_ */
diff --git a/include/zephyr/posix/sys/socket.h b/include/zephyr/posix/sys/socket.h
deleted file mode 100644
index cae67100328..00000000000
--- a/include/zephyr/posix/sys/socket.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_SOCKET_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_SOCKET_H_
-
-#include <sys/types.h>
-#include <zephyr/net/socket.h>
-
-#define SHUT_RD   ZSOCK_SHUT_RD
-#define SHUT_WR   ZSOCK_SHUT_WR
-#define SHUT_RDWR ZSOCK_SHUT_RDWR
-
-#define MSG_PEEK     ZSOCK_MSG_PEEK
-#define MSG_TRUNC    ZSOCK_MSG_TRUNC
-#define MSG_DONTWAIT ZSOCK_MSG_DONTWAIT
-#define MSG_WAITALL  ZSOCK_MSG_WAITALL
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(_SOCKLEN_T_DECLARED) && !defined(__socklen_t_defined)
-typedef uint32_t socklen_t;
-#define _SOCKLEN_T_DECLARED
-#define __socklen_t_defined
-#endif
-
-struct linger {
-	int  l_onoff;
-	int  l_linger;
-};
-
-int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);
-int bind(int sock, const struct sockaddr *addr, socklen_t addrlen);
-int connect(int sock, const struct sockaddr *addr, socklen_t addrlen);
-int getpeername(int sock, struct sockaddr *addr, socklen_t *addrlen);
-int getsockname(int sock, struct sockaddr *addr, socklen_t *addrlen);
-int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen);
-int listen(int sock, int backlog);
-ssize_t recv(int sock, void *buf, size_t max_len, int flags);
-ssize_t recvfrom(int sock, void *buf, size_t max_len, int flags, struct sockaddr *src_addr,
-		 socklen_t *addrlen);
-ssize_t recvmsg(int sock, struct msghdr *msg, int flags);
-ssize_t send(int sock, const void *buf, size_t len, int flags);
-ssize_t sendmsg(int sock, const struct msghdr *message, int flags);
-ssize_t sendto(int sock, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr,
-	       socklen_t addrlen);
-int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);
-int shutdown(int sock, int how);
-int sockatmark(int s);
-int socket(int family, int type, int proto);
-int socketpair(int family, int type, int proto, int sv[2]);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* ZEPHYR_INCLUDE_POSIX_SYS_SOCKET_H_ */
diff --git a/include/zephyr/posix/sys/stat.h b/include/zephyr/posix/sys/stat.h
deleted file mode 100644
index bd46030f8db..00000000000
--- a/include/zephyr/posix/sys/stat.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright The Zephyr Project Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_ZEPHYR_POSIX_SYS_STAT_H_
-#define ZEPHYR_INCLUDE_ZEPHYR_POSIX_SYS_STAT_H_
-
-#include <time.h>
-
-#include <zephyr/toolchain.h>
-#include <zephyr/sys/fdtable.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__)
-
-/* slightly out of order w.r.t. the specification */
-#if !defined(_BLKCNT_T_DECLARED) && !defined(__blkcnt_t_defined)
-typedef long blkcnt_t;
-#define _BLKCNT_T_DECLARED
-#define __blkcnt_t_defined
-#endif
-
-#if !defined(_BLKSIZE_T_DECLARED) && !defined(__blksize_t_defined)
-typedef unsigned long blksize_t;
-#define _BLKSIZE_T_DECLARED
-#define __blksize_t_defined
-#endif
-
-#if !defined(_DEV_T_DECLARED) && !defined(__dev_t_defined)
-typedef int dev_t;
-#define _DEV_T_DECLARED
-#define __dev_t_defined
-#endif
-
-#if !defined(_GID_T_DECLARED) && !defined(__gid_t_defined)
-typedef unsigned short gid_t;
-#define _GID_T_DECLARED
-#define __gid_t_defined
-#endif
-
-#if !defined(_INO_T_DECLARED) && !defined(__ino_t_defined)
-typedef long ino_t;
-#define _INO_T_DECLARED
-#define __ino_t_defined
-#endif
-
-#if !defined(_MODE_T_DECLARED) && !defined(__mode_t_defined)
-typedef int mode_t;
-#define _MODE_T_DECLARED
-#define __mode_t_defined
-#endif
-
-#if !defined(_NLINK_T_DECLARED) && !defined(__nlink_t_defined)
-typedef unsigned short nlink_t;
-#define _NLINK_T_DECLARED
-#define __nlink_t_defined
-#endif
-
-#if !defined(_OFF_T_DECLARED) && !defined(__off_t_defined)
-typedef long off_t;
-#define _OFF_T_DECLARED
-#define __off_t_defined
-#endif
-
-/* time_t must be defined by the libc time.h */
-#include <time.h>
-
-#if __STDC_VERSION__ >= 201112L
-/* struct timespec must be defined in the libc time.h */
-#else
-/*
- * there is a workaround needed for picolibc because it doesn't have guards around the definition
- * of struct timespec
- */
-#if !defined(_TIMESPEC_DECLARED) && !defined(__timespec_defined) && !defined(CONFIG_PICOLIBC)
-struct timespec {
-	time_t tv_sec;
-	long tv_nsec;
-};
-#define _TIMESPEC_DECLARED
-#define __timespec_defined
-#endif
-#endif
-
-#if !defined(_UID_T_DECLARED) && !defined(__uid_t_defined)
-typedef unsigned short uid_t;
-#define _UID_T_DECLARED
-#define __uid_t_defined
-#endif
-
-#if !(defined(_STAT_DECLARED) || defined(__stat_defined)) || defined(__DOXYGEN__)
-struct stat {
-	dev_t st_dev;
-	ino_t st_ino;
-	mode_t st_mode;
-	nlink_t st_nlink;
-	uid_t st_uid;
-	gid_t st_gid;
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-	dev_t st_rdev;
-#endif
-	off_t st_size;
-	struct timespec st_atim;
-	struct timespec st_mtim;
-	struct timespec st_ctim;
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-	blkcnt_t st_blksize;
-	blkcnt_t st_blocks;
-#endif
-};
-#define _STAT_DECLARED
-#define __stat_defined
-#endif
-
-#define S_IFMT 00170000
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-#define S_IFBLK  ZVFS_MODE_IFBLK
-#define S_IFCHR  ZVFS_MODE_IFCHR
-#define S_IFIFO  ZVFS_MODE_IFIFO
-#define S_IFREG  ZVFS_MODE_IFREG
-#define S_IFDIR  ZVFS_MODE_IFDIR
-#define S_IFLNK  ZVFS_MODE_IFLNK
-#define S_IFSOCK ZVFS_MODE_IFSOCK
-#define S_IFSHM  ZVFS_MODE_IFSHM
-#endif
-
-#define S_IRWXU 0000700
-#define S_IRUSR 0000400
-#define S_IWUSR 0000200
-#define S_IXUSR 0000100
-#define S_IRWXG 0000070
-#define S_IRGRP 0000040
-#define S_IWGRP 0000020
-#define S_IXGRP 0000010
-#define S_IRWXO 0000007
-#define S_IROTH 0000004
-#define S_IWOTH 0000002
-#define S_IXOTH 0000001
-#define S_ISUID 0004000
-#define S_ISGID 0002000
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-#define S_ISVTX 0001000
-#endif
-
-#define S_ISBLK(m)  (((m) & S_IFMT) == S_IFBLK)
-#define S_ISCHR(m)  (((m) & S_IFMT) == S_IFCHR)
-#define S_ISDIR(m)  (((m) & S_IFMT) == S_IFDIR)
-#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
-#define S_ISREG(m)  (((m) & S_IFMT) == S_IFREG)
-#define S_ISLNK(m)  (((m) & S_IFMT) == S_IFLNK)
-#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
-
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-#define S_TYPEISMQ(buf)  (0)
-#define S_TYPEISSEM(buf) (0)
-#define S_TYPEISSHM(st)  (((st)->st_mode & S_IFMT) == S_IFSHM)
-#endif
-
-#if defined(_POSIX_TYPED_MEMORY_OBJECTS) || defined(__DOXYGEN__)
-#define S_TYPEISTMO(buf) (0)
-#endif
-
-#define UTIME_NOW  -1
-#define UTIME_OMIT -2
-
-int chmod(const char *path, mode_t mode);
-int fchmod(int fildes, mode_t mode);
-int fchmodat(int fd, const char *path, mode_t mode, int flag);
-int fstat(int fildes, struct stat *buf);
-int fstatat(int fd, const char *ZRESTRICT path, struct stat *ZRESTRICT buf, int flag);
-int futimens(int fildes, const struct timespec times[2]);
-int lstat(const char *ZRESTRICT path, struct stat *ZRESTRICT buf);
-int mkdir(const char *path, mode_t mode);
-int mkdirat(int fd, const char *path, mode_t mode);
-int mkfifo(const char *path, mode_t mode);
-int mkfifoat(int fd, const char *path, mode_t mode);
-#if defined(_XOPEN_SOURCE) || defined(__DOXYGEN__)
-int mknod(const char *path, mode_t mode, dev_t dev);
-int mknodat(int fd, const char *path, mode_t mode, dev_t dev);
-#endif
-TOOLCHAIN_DISABLE_WARNING(TOOLCHAIN_WARNING_SHADOW);
-int stat(const char *ZRESTRICT path, struct stat *ZRESTRICT buf);
-TOOLCHAIN_ENABLE_WARNING(TOOLCHAIN_WARNING_SHADOW);
-mode_t umask(mode_t cmask);
-int utimensat(int fd, const char *path, const struct timespec times[2], int flag);
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_ZEPHYR_POSIX_SYS_STAT_H_ */
diff --git a/include/zephyr/posix/sys/sysconf.h b/include/zephyr/posix/sys/sysconf.h
deleted file mode 100644
index a330bfa0432..00000000000
--- a/include/zephyr/posix/sys/sysconf.h
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_SYSCONF_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_SYSCONF_H_
-
-#include <limits.h>
-
-#include <zephyr/sys/util_macro.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined(CONFIG_MINIMAL_LIBC)
-
-enum {
-	_SC_ADVISORY_INFO,
-	_SC_ASYNCHRONOUS_IO,
-	_SC_BARRIERS,
-	_SC_CLOCK_SELECTION,
-	_SC_CPUTIME,
-	_SC_FSYNC,
-	_SC_IPV6,
-	_SC_JOB_CONTROL,
-	_SC_MAPPED_FILES,
-	_SC_MEMLOCK,
-	_SC_MEMLOCK_RANGE,
-	_SC_MEMORY_PROTECTION,
-	_SC_MESSAGE_PASSING,
-	_SC_MONOTONIC_CLOCK,
-	_SC_PRIORITIZED_IO,
-	_SC_PRIORITY_SCHEDULING,
-	_SC_RAW_SOCKETS,
-	_SC_RE_DUP_MAX,
-	_SC_READER_WRITER_LOCKS,
-	_SC_REALTIME_SIGNALS,
-	_SC_REGEXP,
-	_SC_SAVED_IDS,
-	_SC_SEMAPHORES,
-	_SC_SHARED_MEMORY_OBJECTS,
-	_SC_SHELL,
-	_SC_SPAWN,
-	_SC_SPIN_LOCKS,
-	_SC_SPORADIC_SERVER,
-	_SC_SS_REPL_MAX,
-	_SC_SYNCHRONIZED_IO,
-	_SC_THREAD_ATTR_STACKADDR,
-	_SC_THREAD_ATTR_STACKSIZE,
-	_SC_THREAD_CPUTIME,
-	_SC_THREAD_PRIO_INHERIT,
-	_SC_THREAD_PRIO_PROTECT,
-	_SC_THREAD_PRIORITY_SCHEDULING,
-	_SC_THREAD_PROCESS_SHARED,
-	_SC_THREAD_ROBUST_PRIO_INHERIT,
-	_SC_THREAD_ROBUST_PRIO_PROTECT,
-	_SC_THREAD_SAFE_FUNCTIONS,
-	_SC_THREAD_SPORADIC_SERVER,
-	_SC_THREADS,
-	_SC_TIMEOUTS,
-	_SC_TIMERS,
-	_SC_TRACE,
-	_SC_TRACE_EVENT_FILTER,
-	_SC_TRACE_EVENT_NAME_MAX,
-	_SC_TRACE_INHERIT,
-	_SC_TRACE_LOG,
-	_SC_TRACE_NAME_MAX,
-	_SC_TRACE_SYS_MAX,
-	_SC_TRACE_USER_EVENT_MAX,
-	_SC_TYPED_MEMORY_OBJECTS,
-	_SC_VERSION,
-	_SC_V7_ILP32_OFF32,
-	_SC_V7_ILP32_OFFBIG,
-	_SC_V7_LP64_OFF64,
-	_SC_V7_LPBIG_OFFBIG,
-	_SC_V6_ILP32_OFF32,
-	_SC_V6_ILP32_OFFBIG,
-	_SC_V6_LP64_OFF64,
-	_SC_V6_LPBIG_OFFBIG,
-	_SC_BC_BASE_MAX,
-	_SC_BC_DIM_MAX,
-	_SC_BC_SCALE_MAX,
-	_SC_BC_STRING_MAX,
-	_SC_2_C_BIND,
-	_SC_2_C_DEV,
-	_SC_2_CHAR_TERM,
-	_SC_COLL_WEIGHTS_MAX,
-	_SC_DELAYTIMER_MAX,
-	_SC_EXPR_NEST_MAX,
-	_SC_2_FORT_DEV,
-	_SC_2_FORT_RUN,
-	_SC_LINE_MAX,
-	_SC_2_LOCALEDEF,
-	_SC_2_PBS,
-	_SC_2_PBS_ACCOUNTING,
-	_SC_2_PBS_CHECKPOINT,
-	_SC_2_PBS_LOCATE,
-	_SC_2_PBS_MESSAGE,
-	_SC_2_PBS_TRACK,
-	_SC_2_SW_DEV,
-	_SC_2_UPE,
-	_SC_2_VERSION,
-	_SC_XOPEN_CRYPT,
-	_SC_XOPEN_ENH_I18N,
-	_SC_XOPEN_REALTIME,
-	_SC_XOPEN_REALTIME_THREADS,
-	_SC_XOPEN_SHM,
-	_SC_XOPEN_STREAMS,
-	_SC_XOPEN_UNIX,
-	_SC_XOPEN_UUCP,
-	_SC_XOPEN_VERSION,
-	_SC_CLK_TCK,
-	_SC_GETGR_R_SIZE_MAX,
-	_SC_GETPW_R_SIZE_MAX,
-	_SC_AIO_LISTIO_MAX,
-	_SC_AIO_MAX,
-	_SC_AIO_PRIO_DELTA_MAX,
-	_SC_ARG_MAX,
-	_SC_ATEXIT_MAX,
-	_SC_CHILD_MAX,
-	_SC_HOST_NAME_MAX,
-	_SC_IOV_MAX,
-	_SC_LOGIN_NAME_MAX,
-	_SC_NGROUPS_MAX,
-	_SC_MQ_OPEN_MAX,
-	_SC_MQ_PRIO_MAX,
-	_SC_OPEN_MAX,
-	_SC_PAGE_SIZE,
-	_SC_PAGESIZE,
-	_SC_THREAD_DESTRUCTOR_ITERATIONS,
-	_SC_THREAD_KEYS_MAX,
-	_SC_THREAD_STACK_MIN,
-	_SC_THREAD_THREADS_MAX,
-	_SC_RTSIG_MAX,
-	_SC_SEM_NSEMS_MAX,
-	_SC_SEM_VALUE_MAX,
-	_SC_SIGQUEUE_MAX,
-	_SC_STREAM_MAX,
-	_SC_SYMLOOP_MAX,
-	_SC_TIMER_MAX,
-	_SC_TTY_NAME_MAX,
-	_SC_TZNAME_MAX,
-};
-
-/*
- * clang-format and checkpatch disagree on formatting here, so rely on checkpatch and disable
- * clang-format since checkpatch cannot be selectively disabled.
- */
-
-/* clang-format off */
-
-#define __z_posix_sysconf_SC_ADVISORY_INFO (-1L)
-#define __z_posix_sysconf_SC_ASYNCHRONOUS_IO                                                       \
-	COND_CODE_1(CONFIG_POSIX_ASYNCHRONOUS_IO, (_POSIX_ASYNCHRONOUS_IO), (-1L))
-#define __z_posix_sysconf_SC_BARRIERS COND_CODE_1(CONFIG_POSIX_BARRIERS, (_POSIX_BARRIERS), (-1L))
-#define __z_posix_sysconf_SC_CLOCK_SELECTION                                                       \
-	COND_CODE_1(CONFIG_POSIX_CLOCK_SELECTION, (_POSIX_CLOCK_SELECTION), (-1L))
-#define __z_posix_sysconf_SC_CPUTIME \
-	COND_CODE_1(CONFIG_POSIX_CPUTIME, (_POSIX_CPUTIME), (-1L))
-#define __z_posix_sysconf_SC_FSYNC                                                                 \
-	COND_CODE_1(CONFIG_POSIX_FSYNC, (_POSIX_FSYNC), (-1L))
-#define __z_posix_sysconf_SC_IPV6              COND_CODE_1(CONFIG_NET_IPV6, (_POSIX_IPV6), (-1L))
-#define __z_posix_sysconf_SC_JOB_CONTROL       (-1L)
-#define __z_posix_sysconf_SC_MAPPED_FILES                                                          \
-	COND_CODE_1(CONFIG_POSIX_MAPPED_FILES, (_POSIX_MAPPED_FILES), (-1L))
-#define __z_posix_sysconf_SC_MEMLOCK                                                               \
-	COND_CODE_1(CONFIG_POSIX_MEMLOCK, (_POSIX_MEMLOCK), (-1L))
-#define __z_posix_sysconf_SC_MEMLOCK_RANGE                                                         \
-	COND_CODE_1(CONFIG_POSIX_MEMLOCK_RANGE, (_POSIX_MEMLOCK_RANGE), (-1L))
-#define __z_posix_sysconf_SC_MEMORY_PROTECTION                                                     \
-	COND_CODE_1(CONFIG_POSIX_MEMORY_PROTECTION, (_POSIX_MEMORY_PROTECTION), (-1L))
-#define __z_posix_sysconf_SC_MESSAGE_PASSING                                                       \
-	COND_CODE_1(CONFIG_POSIX_MESSAGE_PASSING, (_POSIX_MESSAGE_PASSING), (-1L))
-#define __z_posix_sysconf_SC_MONOTONIC_CLOCK                                                       \
-	COND_CODE_1(CONFIG_POSIX_MONOTONIC_CLOCK, (_POSIX_MONOTONIC_CLOCK), (-1L))
-#define __z_posix_sysconf_SC_PRIORITIZED_IO (-1L)
-#define __z_posix_sysconf_SC_PRIORITY_SCHEDULING                                                   \
-	COND_CODE_1(CONFIG_POSIX_PRIORITY_SCHEDULING, (_POSIX_PRIORITY_SCHEDULING), (-1L))
-#define __z_posix_sysconf_SC_RAW_SOCKETS                                                           \
-	COND_CODE_1(CONFIG_NET_SOCKETS_PACKET, (_POSIX_RAW_SOCKETS), (-1L))
-#define __z_posix_sysconf_SC_RE_DUP_MAX _POSIX_RE_DUP_MAX
-#define __z_posix_sysconf_SC_READER_WRITER_LOCKS                                                   \
-	COND_CODE_1(CONFIG_POSIX_RW_LOCKS, (_POSIX_READER_WRITER_LOCKS), (-1L))
-#define __z_posix_sysconf_SC_REALTIME_SIGNALS      (-1L)
-#define __z_posix_sysconf_SC_REGEXP                (-1L)
-#define __z_posix_sysconf_SC_SAVED_IDS             (-1L)
-#define __z_posix_sysconf_SC_SEMAPHORES                                                            \
-	COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (_POSIX_SEMAPHORES), (-1L))
-#define __z_posix_sysconf_SC_SHARED_MEMORY_OBJECTS                                                 \
-	COND_CODE_1(CONFIG_POSIX_SHARED_MEMORY_OBJECTS, (_POSIX_SHARED_MEMORY_OBJECTS), (-1L))
-#define __z_posix_sysconf_SC_SHELL                 (-1L)
-#define __z_posix_sysconf_SC_SPAWN                 (-1L)
-#define __z_posix_sysconf_SC_SPIN_LOCKS                                                            \
-	COND_CODE_1(CONFIG_POSIX_SPIN_LOCKS, (_POSIX_SPIN_LOCKS), (-1L))
-#define __z_posix_sysconf_SC_SPORADIC_SERVER (-1L)
-#define __z_posix_sysconf_SC_SS_REPL_MAX     _POSIX_SS_REPL_MAX
-#define __z_posix_sysconf_SC_SYNCHRONIZED_IO (-1L)
-#define __z_posix_sysconf_SC_THREAD_ATTR_STACKADDR                                                 \
-	COND_CODE_1(CONFIG_POSIX_THREAD_ATTR_STACKADDR, (_POSIX_THREAD_ATTR_STACKADDR), (-1))
-#define __z_posix_sysconf_SC_THREAD_ATTR_STACKSIZE                                                 \
-	COND_CODE_1(CONFIG_POSIX_THREAD_ATTR_STACKSIZE, (_POSIX_THREAD_ATTR_STACKSIZE), (-1L))
-#define __z_posix_sysconf_SC_THREAD_CPUTIME (-1L)
-#define __z_posix_sysconf_SC_THREAD_PRIO_INHERIT                                                   \
-	COND_CODE_1(CONFIG_POSIX_THREAD_PRIO_INHERIT, (_POSIX_THREAD_PRIO_INHERIT), (-1L))
-#define __z_posix_sysconf_SC_THREAD_PRIO_PROTECT        (-1L)
-#define __z_posix_sysconf_SC_THREAD_PRIORITY_SCHEDULING                                            \
-	COND_CODE_1(CONFIG_POSIX_THREAD_PRIORITY_SCHEDULING, (_POSIX_THREAD_PRIORITY_SCHEDULING),  \
-		    (-1L))
-#define __z_posix_sysconf_SC_THREAD_PROCESS_SHARED      (-1L)
-#define __z_posix_sysconf_SC_THREAD_ROBUST_PRIO_INHERIT (-1L)
-#define __z_posix_sysconf_SC_THREAD_ROBUST_PRIO_PROTECT (-1L)
-#define __z_posix_sysconf_SC_THREAD_SAFE_FUNCTIONS                                                 \
-	COND_CODE_1(CONFIG_POSIX_THREAD_SAFE_FUNCTIONS, (_POSIX_THREAD_SAFE_FUNCTIONS), (-1L))
-#define __z_posix_sysconf_SC_THREAD_SPORADIC_SERVER       (-1L)
-#define __z_posix_sysconf_SC_THREADS                                                               \
-	COND_CODE_1(CONFIG_POSIX_THREADS, (_POSIX_THREADS), (-1L))
-#define __z_posix_sysconf_SC_TIMEOUTS                                                              \
-	COND_CODE_1(CONFIG_POSIX_TIMEOUTS, (_POSIX_TIMEOUTS), (-1L))
-#define __z_posix_sysconf_SC_TIMERS                                                                \
-	COND_CODE_1(CONFIG_POSIX_TIMEOUTS, (_POSIX_TIMERS), (-1))
-#define __z_posix_sysconf_SC_TRACE                        (-1L)
-#define __z_posix_sysconf_SC_TRACE_EVENT_FILTER           (-1L)
-#define __z_posix_sysconf_SC_TRACE_EVENT_NAME_MAX         _POSIX_TRACE_NAME_MAX
-#define __z_posix_sysconf_SC_TRACE_INHERIT                (-1L)
-#define __z_posix_sysconf_SC_TRACE_LOG                    (-1L)
-#define __z_posix_sysconf_SC_TRACE_NAME_MAX               _POSIX_TRACE_NAME_MAX
-#define __z_posix_sysconf_SC_TRACE_SYS_MAX                _POSIX_TRACE_SYS_MAX
-#define __z_posix_sysconf_SC_TRACE_USER_EVENT_MAX         _POSIX_TRACE_USER_EVENT_MAX
-#define __z_posix_sysconf_SC_TYPED_MEMORY_OBJECTS         (-1L)
-#define __z_posix_sysconf_SC_VERSION                                                         \
-	COND_CODE_1(CONFIG_POSIX_SYSTEM_INTERFACES, (_POSIX_VERSION), (0))
-#define __z_posix_sysconf_SC_V6_ILP32_OFF32               (-1L)
-#define __z_posix_sysconf_SC_V6_ILP32_OFFBIG              (-1L)
-#define __z_posix_sysconf_SC_V6_LP64_OFF64                (-1L)
-#define __z_posix_sysconf_SC_V6_LPBIG_OFFBIG              (-1L)
-#define __z_posix_sysconf_SC_V7_ILP32_OFF32               (-1L)
-#define __z_posix_sysconf_SC_V7_ILP32_OFFBIG              (-1L)
-#define __z_posix_sysconf_SC_V7_LP64_OFF64                (-1L)
-#define __z_posix_sysconf_SC_V7_LPBIG_OFFBIG              (-1L)
-#define __z_posix_sysconf_SC_BC_BASE_MAX                  _POSIX2_BC_BASE_MAX
-#define __z_posix_sysconf_SC_BC_DIM_MAX                   _POSIX2_BC_DIM_MAX
-#define __z_posix_sysconf_SC_BC_SCALE_MAX                 _POSIX2_BC_SCALE_MAX
-#define __z_posix_sysconf_SC_BC_STRING_MAX                _POSIX2_BC_STRING_MAX
-#define __z_posix_sysconf_SC_2_C_BIND                     _POSIX2_C_BIND
-#define __z_posix_sysconf_SC_2_C_DEV                                                               \
-	COND_CODE_1(_POSIX2_C_DEV > 0, (_POSIX2_C_DEV), (-1))
-#define __z_posix_sysconf_SC_2_CHAR_TERM                  (-1L)
-#define __z_posix_sysconf_SC_COLL_WEIGHTS_MAX             _POSIX2_COLL_WEIGHTS_MAX
-#define __z_posix_sysconf_SC_DELAYTIMER_MAX                                                        \
-	COND_CODE_1(CONFIG_POSIX_TIMERS, (CONFIG_POSIX_DELAYTIMER_MAX), (0))
-#define __z_posix_sysconf_SC_EXPR_NEST_MAX                _POSIX2_EXPR_NEST_MAX
-#define __z_posix_sysconf_SC_2_FORT_DEV                   (-1L)
-#define __z_posix_sysconf_SC_2_FORT_RUN                   (-1L)
-#define __z_posix_sysconf_SC_LINE_MAX                     (-1L)
-#define __z_posix_sysconf_SC_2_LOCALEDEF                  (-1L)
-#define __z_posix_sysconf_SC_2_PBS                        (-1L)
-#define __z_posix_sysconf_SC_2_PBS_ACCOUNTING             (-1L)
-#define __z_posix_sysconf_SC_2_PBS_CHECKPOINT             (-1L)
-#define __z_posix_sysconf_SC_2_PBS_LOCATE                 (-1L)
-#define __z_posix_sysconf_SC_2_PBS_MESSAGE                (-1L)
-#define __z_posix_sysconf_SC_2_PBS_TRACK                  (-1L)
-#define __z_posix_sysconf_SC_2_SW_DEV                     (-1L)
-#define __z_posix_sysconf_SC_2_UPE                        (-1L)
-#define __z_posix_sysconf_SC_2_VERSION                                                             \
-	COND_CODE_1(_POSIX2_VERSION > 0, (_POSIX2_VERSION), (-1))
-#define __z_posix_sysconf_SC_XOPEN_CRYPT                  (-1L)
-#define __z_posix_sysconf_SC_XOPEN_ENH_I18N               (-1L)
-#define __z_posix_sysconf_SC_XOPEN_REALTIME \
-	COND_CODE_1(CONFIG_XSI_REALTIME, (_XOPEN_VERSION), (-1))
-#define __z_posix_sysconf_SC_XOPEN_REALTIME_THREADS       (-1L)
-#define __z_posix_sysconf_SC_XOPEN_SHM                    (-1L)
-#define __z_posix_sysconf_SC_XOPEN_STREAMS                                                         \
-	COND_CODE_1(CONFIG_XSI_STREAMS, (_XOPEN_STREAMS), (-1))
-#define __z_posix_sysconf_SC_XOPEN_UNIX \
-	COND_CODE_1(CONFIG_XSI, (_XOPEN_UNIX), (-1))
-#define __z_posix_sysconf_SC_XOPEN_UUCP                   (-1L)
-#define __z_posix_sysconf_SC_XOPEN_VERSION                                                         \
-	COND_CODE_1(CONFIG_XSI, (_XOPEN_VERSION), (0))
-#define __z_posix_sysconf_SC_CLK_TCK                      (100L)
-#define __z_posix_sysconf_SC_GETGR_R_SIZE_MAX             (0L)
-#define __z_posix_sysconf_SC_GETPW_R_SIZE_MAX             (0L)
-#define __z_posix_sysconf_SC_AIO_LISTIO_MAX               _POSIX_AIO_LISTIO_MAX
-#define __z_posix_sysconf_SC_AIO_MAX                      _POSIX_AIO_MAX
-#define __z_posix_sysconf_SC_AIO_PRIO_DELTA_MAX           0
-#define __z_posix_sysconf_SC_ARG_MAX                      _POSIX_ARG_MAX
-#define __z_posix_sysconf_SC_ATEXIT_MAX                   32
-#define __z_posix_sysconf_SC_CHILD_MAX                    _POSIX_CHILD_MAX
-#define __z_posix_sysconf_SC_HOST_NAME_MAX                                                         \
-	COND_CODE_1(CONFIG_POSIX_NETWORKING, (CONFIG_POSIX_HOST_NAME_MAX), (0))
-#define __z_posix_sysconf_SC_IOV_MAX                      16 /* _XOPEN_IOV_MAX */
-#define __z_posix_sysconf_SC_LOGIN_NAME_MAX               _POSIX_LOGIN_NAME_MAX
-#define __z_posix_sysconf_SC_NGROUPS_MAX                  _POSIX_NGROUPS_MAX
-#define __z_posix_sysconf_SC_MQ_OPEN_MAX                                                           \
-	COND_CODE_1(CONFIG_POSIX_MESSAGE_PASSING, (CONFIG_POSIX_MQ_OPEN_MAX), (0))
-#define __z_posix_sysconf_SC_MQ_PRIO_MAX                  _POSIX_MQ_PRIO_MAX
-#define __z_posix_sysconf_SC_OPEN_MAX                     CONFIG_POSIX_OPEN_MAX
-#define __z_posix_sysconf_SC_PAGE_SIZE                    CONFIG_POSIX_PAGE_SIZE
-#define __z_posix_sysconf_SC_PAGESIZE                     CONFIG_POSIX_PAGE_SIZE
-#define __z_posix_sysconf_SC_THREAD_DESTRUCTOR_ITERATIONS _POSIX_THREAD_DESTRUCTOR_ITERATIONS
-#define __z_posix_sysconf_SC_THREAD_KEYS_MAX                                                       \
-	COND_CODE_1(CONFIG_POSIX_THREADS, (CONFIG_POSIX_THREAD_KEYS_MAX), (0))
-#define __z_posix_sysconf_SC_THREAD_STACK_MIN             0
-#define __z_posix_sysconf_SC_THREAD_THREADS_MAX                                                    \
-	COND_CODE_1(CONFIG_POSIX_THREADS, (CONFIG_POSIX_THREAD_THREADS_MAX), (0))
-#define __z_posix_sysconf_SC_RTSIG_MAX                                                             \
-	COND_CODE_1(CONFIG_POSIX_REALTIME_SIGNALS, (CONFIG_POSIX_RTSIG_MAX), (0))
-#define __z_posix_sysconf_SC_SEM_NSEMS_MAX                                                         \
-	COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (CONFIG_POSIX_SEM_NSEMS_MAX), (0))
-#define __z_posix_sysconf_SC_SEM_VALUE_MAX                                                         \
-	COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (CONFIG_POSIX_SEM_VALUE_MAX), (0))
-#define __z_posix_sysconf_SC_SIGQUEUE_MAX                 _POSIX_SIGQUEUE_MAX
-#define __z_posix_sysconf_SC_STREAM_MAX                   _POSIX_STREAM_MAX
-#define __z_posix_sysconf_SC_SYMLOOP_MAX                  _POSIX_SYMLOOP_MAX
-#define __z_posix_sysconf_SC_TIMER_MAX                                                             \
-	COND_CODE_1(CONFIG_POSIX_TIMERS, (CONFIG_POSIX_TIMER_MAX), (0))
-#define __z_posix_sysconf_SC_TTY_NAME_MAX                 _POSIX_TTY_NAME_MAX
-#define __z_posix_sysconf_SC_TZNAME_MAX                   _POSIX_TZNAME_MAX
-
-#ifdef CONFIG_POSIX_SYSCONF_IMPL_MACRO
-#define sysconf(x) (long)CONCAT(__z_posix_sysconf, x)
-#endif
-
-/* clang-format on */
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_SYSCONF_H_ */
diff --git a/include/zephyr/posix/sys/time.h b/include/zephyr/posix/sys/time.h
deleted file mode 100644
index 71153f7155d..00000000000
--- a/include/zephyr/posix/sys/time.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_TIME_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_TIME_H_
-
-#ifdef CONFIG_NEWLIB_LIBC
-/* Kludge to support outdated newlib version as used in SDK 0.10 for Xtensa */
-#include <newlib.h>
-
-#ifdef __NEWLIB__
-#include <sys/_timeval.h>
-#else
-#include <sys/types.h>
-struct timeval {
-	time_t tv_sec;
-	suseconds_t tv_usec;
-};
-#endif
-
-#else
-#include <sys/types.h>
-#include <sys/_timeval.h>
-#endif /* CONFIG_NEWLIB_LIBC */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int gettimeofday(struct timeval *tv, void *tz);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* ZEPHYR_INCLUDE_POSIX_SYS_TIME_H_ */
diff --git a/include/zephyr/posix/sys/times.h b/include/zephyr/posix/sys/times.h
deleted file mode 100644
index f7773ebb859..00000000000
--- a/include/zephyr/posix/sys/times.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_TIMES_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_TIMES_H_
-
-#include <time.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__)
-
-#if !defined(_TMS_DECLARED) && !defined(__tms_defined)
-struct tms {
-	clock_t tms_utime;
-	clock_t tms_stime;
-	clock_t tms_cutime;
-	clock_t tms_cstime;
-};
-#define _TMS_DECLARED
-#define __tms_defined
-#endif
-
-clock_t times(struct tms *buf);
-
-#endif /* defined(_POSIX_C_SOURCE) || defined(__DOXYGEN__) */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_TIMES_H_ */
diff --git a/include/zephyr/posix/sys/types.h b/include/zephyr/posix/sys/types.h
deleted file mode 100644
index e93945df2df..00000000000
--- a/include/zephyr/posix/sys/types.h
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright The Zephyr Project Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_TYPES_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_TYPES_H_
-
-#include <zephyr/kernel.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(_BLKCNT_T_DECLARED) && !defined(__blkcnt_t_defined)
-typedef long blkcnt_t;
-#define _BLKCNT_T_DECLARED
-#define __blkcnt_t_defined
-#endif
-
-#if !defined(_BLKSIZE_T_DECLARED) && !defined(__blksize_t_defined)
-typedef unsigned long blksize_t;
-#define _BLKSIZE_T_DECLARED
-#define __blksize_t_defined
-#endif
-
-#if !defined(_CLOCK_T_DECLARED) && !defined(__clock_t_defined)
-typedef unsigned long clock_t;
-#define _CLOCK_T_DECLARED
-#define __clock_t_defined
-#endif
-
-#if !defined(_CLOCKID_T_DECLARED) && !defined(__clockid_t_defined)
-typedef unsigned long clockid_t;
-#define _CLOCKID_T_DECLARED
-#define __clockid_t_defined
-#endif
-
-#if !defined(_DEV_T_DECLARED) && !defined(__dev_t_defined)
-typedef int dev_t;
-#define _DEV_T_DECLARED
-#define __dev_t_defined
-#endif
-
-#if !defined(_FSBLKCNT_T_DECLARED) && !defined(__fsblkcnt_t_defined)
-typedef unsigned long fsblkcnt_t;
-#define _FSBLKCNT_T_DECLARED
-#define __fsblkcnt_t_defined
-#endif
-
-#if !defined(_FSFILCNT_T_DECLARED) && !defined(__fsfilcnt_t_defined)
-typedef unsigned long fsfilcnt_t;
-#define _FSFILCNT_T_DECLARED
-#define __fsfilcnt_t_defined
-#endif
-
-#if !defined(_GID_T_DECLARED) && !defined(__gid_t_defined)
-typedef unsigned short gid_t;
-#define _GID_T_DECLARED
-#define __gid_t_defined
-#endif
-
-#if !defined(_INO_T_DECLARED) && !defined(__ino_t_defined)
-typedef long ino_t;
-#define _INO_T_DECLARED
-#define __ino_t_defined
-#endif
-
-/* Maybe limit to when _XOPEN_SOURCE is defined? */
-#if !defined(_KEY_T_DECLARED) && !defined(__key_t_defined)
-typedef unsigned long key_t;
-#define _KEY_T_DECLARED
-#define __key_t_defined
-#endif
-
-#if !defined(_MODE_T_DECLARED) && !defined(__mode_t_defined)
-typedef int mode_t;
-#define _MODE_T_DECLARED
-#define __mode_t_defined
-#endif
-
-#if !defined(_NLINK_T_DECLARED) && !defined(__nlink_t_defined)
-typedef unsigned short nlink_t;
-#define _NLINK_T_DECLARED
-#define __nlink_t_defined
-#endif
-
-#if !defined(_OFF_T_DECLARED) && !defined(__off_t_defined)
-typedef long off_t;
-#define _OFF_T_DECLARED
-#define __off_t_defined
-#endif
-
-#if !defined(_PID_T_DECLARED) && !defined(__pid_t_defined)
-/* TODO: it would be nice to convert this to a long */
-typedef int pid_t;
-#define _PID_T_DECLARED
-#define __pid_t_defined
-#endif
-
-/* size_t must be defined by the libc stddef.h */
-#include <stddef.h>
-
-#ifndef __SIZE_TYPE__
-#define __SIZE_TYPE__ unsigned long
-#endif
-
-#if !defined(_SSIZE_T_DECLARED) && !defined(__ssize_t_defined)
-#define unsigned signed /* parasoft-suppress MISRAC2012-RULE_20_4-a MISRAC2012-RULE_20_4-b */
-typedef __SIZE_TYPE__ ssize_t;
-#undef unsigned
-#define _SSIZE_T_DECLARED
-#define __ssize_t_defined
-#endif
-
-#if !defined(_SUSECONDS_T_DECLARED) && !defined(__suseconds_t_defined)
-typedef long suseconds_t;
-#define _SUSECONDS_T_DECLARED
-#define __suseconds_t_defined
-#endif
-
-/* time_t must be defined by the libc time.h */
-#include <time.h>
-
-#if __STDC_VERSION__ >= 201112L
-/* struct timespec must be defined in the libc time.h */
-#else
-/*
- * there is a workaround needed for picolibc because it doesn't have guards around the definition
- * of struct timespec
- */
-#if !defined(_TIMESPEC_DECLARED) && !defined(__timespec_defined) && !defined(CONFIG_PICOLIBC)
-struct timespec {
-	time_t tv_sec;
-	long tv_nsec;
-};
-#define _TIMESPEC_DECLARED
-#define __timespec_defined
-#endif
-#endif
-
-/* TODO: trace_attr_t, trace_event_id_t, trace_event_set_t, trace_id_t */
-
-#if !defined(_UID_T_DECLARED) && !defined(__uid_t_defined)
-typedef unsigned short uid_t;
-#define _UID_T_DECLARED
-#define __uid_t_defined
-#endif
-
-#if !defined(_USECONDS_T_DECLARED) && !defined(__useconds_t_defined)
-typedef unsigned long useconds_t;
-#define _USECONDS_T_DECLARED
-#define __useconds_t_defined
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#include <sys/_pthreadtypes.h>
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_TYPES_H_ */
diff --git a/include/zephyr/posix/sys/utsname.h b/include/zephyr/posix/sys/utsname.h
deleted file mode 100644
index 542215076a4..00000000000
--- a/include/zephyr/posix/sys/utsname.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SYS_UTSNAME_H_
-#define ZEPHYR_INCLUDE_POSIX_SYS_UTSNAME_H_
-
-#include <zephyr/sys/util_macro.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* These are for compatibility / practicality */
-#define _UTSNAME_NODENAME_LENGTH                                                                   \
-	COND_CODE_1(CONFIG_POSIX_SINGLE_PROCESS, (CONFIG_POSIX_UNAME_VERSION_LEN), (0))
-#define _UTSNAME_VERSION_LENGTH                                                                    \
-	COND_CODE_1(CONFIG_POSIX_SINGLE_PROCESS, (CONFIG_POSIX_UNAME_VERSION_LEN), (0))
-
-struct utsname {
-	char sysname[sizeof("Zephyr")];
-	char nodename[_UTSNAME_NODENAME_LENGTH + 1];
-	char release[sizeof("99.99.99-rc1")];
-	char version[_UTSNAME_VERSION_LENGTH + 1];
-	char machine[sizeof(CONFIG_ARCH)];
-};
-
-int uname(struct utsname *name);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYS_UTSNAME_H_ */
diff --git a/include/zephyr/posix/syslog.h b/include/zephyr/posix/syslog.h
deleted file mode 100644
index d4c9c58b80c..00000000000
--- a/include/zephyr/posix/syslog.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_SYSLOG_H_
-#define ZEPHYR_INCLUDE_POSIX_SYSLOG_H_
-
-#include <stdarg.h>
-
-/* option */
-#define LOG_PID    1
-#define LOG_CONS   2
-#define LOG_NDELAY 4
-#define LOG_ODELAY 8
-#define LOG_NOWAIT 16
-#define LOG_PERROR 32
-
-/* facility */
-#define LOG_KERN   0
-#define LOG_USER   1
-#define LOG_MAIL   2
-#define LOG_NEWS   3
-#define LOG_UUCP   4
-#define LOG_DAEMON 5
-#define LOG_AUTH   6
-#define LOG_CRON   7
-#define LOG_LPR    8
-#define LOG_LOCAL0 9
-#define LOG_LOCAL1 10
-#define LOG_LOCAL2 11
-#define LOG_LOCAL3 12
-#define LOG_LOCAL4 13
-#define LOG_LOCAL5 14
-#define LOG_LOCAL6 15
-#define LOG_LOCAL7 16
-
-/* priority */
-#define LOG_EMERG   0
-#define LOG_ALERT   1
-#define LOG_CRIT    2
-#define LOG_ERR     3
-#define LOG_WARNING 4
-#define LOG_NOTICE  5
-#define LOG_INFO    6
-#define LOG_DEBUG   7
-
-/* generate a valid log mask */
-#define LOG_MASK(mask) ((mask) & BIT_MASK(LOG_DEBUG + 1))
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void closelog(void);
-void openlog(const char *ident, int logopt, int facility);
-int setlogmask(int maskpri);
-void syslog(int priority, const char *message, ...);
-void vsyslog(int priority, const char *format, va_list ap);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZEPHYR_INCLUDE_POSIX_SYSLOG_H_ */
diff --git a/include/zephyr/posix/unistd.h b/include/zephyr/posix/unistd.h
deleted file mode 100644
index bb3b5e55c17..00000000000
--- a/include/zephyr/posix/unistd.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#ifndef ZEPHYR_INCLUDE_POSIX_UNISTD_H_
-#define ZEPHYR_INCLUDE_POSIX_UNISTD_H_
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <time.h>
-
-#include <zephyr/fs/fs.h>
-#include <zephyr/posix/sys/confstr.h>
-#include <zephyr/posix/sys/sysconf.h>
-#include <zephyr/toolchain.h>
-
-#include "posix_features.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* File related operations */
-int close(int file);
-ssize_t write(int file, const void *buffer, size_t count);
-ssize_t read(int file, void *buffer, size_t count);
-off_t lseek(int file, off_t offset, int whence);
-int fsync(int fd);
-int ftruncate(int fd, off_t length);
-
-#ifdef CONFIG_POSIX_SYNCHRONIZED_IO
-int fdatasync(int fd);
-#endif /* CONFIG_POSIX_SYNCHRONIZED_IO */
-
-/* File System related operations */
-int rename(const char *old, const char *newp);
-int unlink(const char *path);
-int stat(const char *path, struct stat *buf);
-int mkdir(const char *path, mode_t mode);
-int rmdir(const char *path);
-
-FUNC_NORETURN void _exit(int status);
-
-int gethostname(char *buf, size_t len);
-
-#ifdef CONFIG_POSIX_C_LIB_EXT
-int getopt(int argc, char *const argv[], const char *optstring);
-extern char *optarg;
-extern int opterr, optind, optopt;
-#endif
-
-int getentropy(void *buffer, size_t length);
-pid_t getpid(void);
-unsigned sleep(unsigned int seconds);
-int usleep(useconds_t useconds);
-#if _POSIX_C_SOURCE >= 2
-size_t confstr(int name, char *buf, size_t len);
-#endif
-
-#ifdef CONFIG_POSIX_SYSCONF_IMPL_MACRO
-#define sysconf(x) (long)CONCAT(__z_posix_sysconf, x)
-#else
-long sysconf(int opt);
-#endif /* CONFIG_POSIX_SYSCONF_IMPL_FULL */
-
-#if _XOPEN_SOURCE >= 500
-long gethostid(void);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* ZEPHYR_INCLUDE_POSIX_UNISTD_H_ */
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index f960141b7af..51413ffc4b5 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -4,9 +4,6 @@
 add_compile_options($<TARGET_PROPERTY:compiler,warning_shadow_variables>)
 
 add_subdirectory(libc)
-if(NOT CONFIG_NATIVE_LIBC)
-add_subdirectory(posix)
-endif()
 add_subdirectory_ifdef(CONFIG_CPP                  cpp)
 add_subdirectory(hash)
 add_subdirectory(heap)
diff --git a/lib/Kconfig b/lib/Kconfig
index 7f2a5b2a15b..41800484d6b 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -21,8 +21,6 @@ source "lib/net_buf/Kconfig"
 
 source "lib/os/Kconfig"
 
-source "lib/posix/Kconfig"
-
 source "lib/smf/Kconfig"
 
 source "lib/acpi/Kconfig"
diff --git a/lib/libc/minimal/CMakeLists.txt b/lib/libc/minimal/CMakeLists.txt
index e0a47206f05..ce5438007c9 100644
--- a/lib/libc/minimal/CMakeLists.txt
+++ b/lib/libc/minimal/CMakeLists.txt
@@ -53,4 +53,4 @@ add_custom_command(
   WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
 )
 
-zephyr_include_directories(${ZEPHYR_BASE}/include/zephyr/posix)
+zephyr_include_directories(${ZEPHYR_POSIX_NEXT_MODULE_DIR}/include/zephyr/posix)
diff --git a/lib/libc/picolibc/CMakeLists.txt b/lib/libc/picolibc/CMakeLists.txt
index e71ba2db988..981c155819e 100644
--- a/lib/libc/picolibc/CMakeLists.txt
+++ b/lib/libc/picolibc/CMakeLists.txt
@@ -10,9 +10,7 @@ zephyr_library_sources(
   locks.c
   stdio.c
   )
-if(CONFIG_POSIX_BASE_DEFINITIONS OR CONFIG_EVENTFD)
   zephyr_include_directories(include)
-endif()
 if(CONFIG_PICOLIBC_USE_MODULE)
   # temporary workaround for https://github.com/picolibc/picolibc/pull/1079
   zephyr_compile_options(-Dpid_t=__pid_t)
diff --git a/lib/posix/CMakeLists.txt b/lib/posix/CMakeLists.txt
deleted file mode 100644
index bfc33a3fcd0..00000000000
--- a/lib/posix/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-# zephyr-keep-sorted-start
-add_subdirectory_ifdef(CONFIG_EVENTFD eventfd)
-add_subdirectory_ifdef(CONFIG_POSIX_C_LIB_EXT c_lib_ext)
-add_subdirectory_ifdef(CONFIG_POSIX_SHELL shell)
-add_subdirectory_ifdef(CONFIG_POSIX_SYSTEM_INTERFACES options)
-# zephyr-keep-sorted-stop
diff --git a/lib/posix/Kconfig b/lib/posix/Kconfig
deleted file mode 100644
index 067def5180d..00000000000
--- a/lib/posix/Kconfig
+++ /dev/null
@@ -1,44 +0,0 @@
-# Copyright (c) 2024 Meta
-# Copyright (c) 2025 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menu "POSIX API Support"
-
-# POSIX Subprofile Definitions
-rsource "Kconfig.profile"
-
-# Toolchain hooks for external implementations
-rsource "Kconfig.toolchain"
-
-# POSIX C Library Extensions
-# This menu is for POSIX Option Groups that do not require OS support.
-menu "POSIX C Library Extensions"
-rsource "c_lang_support_r/Kconfig"
-rsource "c_lib_ext/Kconfig"
-endmenu
-
-# POSIX System Interfaces
-menuconfig POSIX_SYSTEM_INTERFACES
-	bool "POSIX System Interfaces"
-	select NATIVE_LIBC_INCOMPATIBLE
-	help
-	  Select 'y' here to support POSIX System Interfaces within Zephyr.
-
-	  Options in this menu are organized by POSIX subprofiling Option Group.
-
-	  For more information, see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-
-if POSIX_SYSTEM_INTERFACES
-rsource "options/Kconfig"
-
-# POSIX Shell utilities
-rsource "shell/Kconfig"
-endif
-
-endmenu
-
-# Eventfd Support (not officially POSIX)
-rsource "eventfd/Kconfig"
diff --git a/lib/posix/Kconfig.profile b/lib/posix/Kconfig.profile
deleted file mode 100644
index f7129baa911..00000000000
--- a/lib/posix/Kconfig.profile
+++ /dev/null
@@ -1,212 +0,0 @@
-# Copyright (c) 2024 Tenstorrent
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config POSIX_API
-	bool "POSIX APIs"
-	select POSIX_SYSTEM_INTERFACES
-	select POSIX_BASE_DEFINITIONS # clock_gettime(), pthread_create(), sem_get(), etc
-	select POSIX_AEP_REALTIME_MINIMAL # CLOCK_MONOTONIC, pthread_attr_setstack(), etc
-	select POSIX_NETWORKING if NETWORKING # inet_ntoa(), socket(), etc
-	imply EVENTFD # eventfd(), eventfd_read(), eventfd_write()
-	imply POSIX_FD_MGMT # open(), close(), read(), write()
-	imply POSIX_MULTI_PROCESS # sleep(), getpid(), etc
-	imply XSI_SINGLE_PROCESS # gettimeofday()
-	select DEPRECATED
-	help
-	  This option is deprecated. Applications should select CONFIG_POSIX_AEP_CHOICE_BASE,
-	  CONFIG_POSIX_AEP_CHOICE_PSE51, CONFIG_POSIX_AEP_CHOICE_PSE52, or
-	  CONFIG_POSIX_AEP_CHOICE_PSE53. Libraries should depend on
-	  CONFIG_POSIX_SYSTEM_INTERFACES and other POSIX Option Groups.
-
-	  For more information, please see
-
-
-choice POSIX_AEP_CHOICE
-	prompt "POSIX Subprofile"
-	default POSIX_AEP_CHOICE_ZEPHYR
-	help
-	  This choice is intended to help users select the correct POSIX profile for their
-	  application. Choices are based on IEEE 1003.13-2003 (now inactive / reserved) and
-	  extrapolated to the more recent Subprofiling Option Groups in IEEE 1003.3-2017.
-
-	  For more information, please refer to
-	  https://standards.ieee.org/ieee/1003.13/3322/
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config POSIX_AEP_CHOICE_NONE
-	bool "No POSIX subprofile"
-	help
-	  No POSIX subprofile is selected.
-
-config POSIX_AEP_CHOICE_ZEPHYR
-	bool "Minimal Zephyr System Profile"
-	select POSIX_C_LIB_EXT
-	select POSIX_C_LANG_SUPPORT_R
-	help
-	  Zephyr expects certain POSIX functions to be available throughout the build environment,
-	  such as gmtime_r(), strnlen(), strtok_r(), and possibly others.
-
-	  These functions are divided into two standalone Option Groups that may be enabled
-	  independently of the remainder of the POSIX API implementation; namely POSIX_C_LIB_EXT and
-	  POSIX_C_LANG_SUPPORT_R. If not referenced by the Zephyr kernel or application, there are no
-	  resource implications for enabling these option groups.
-
-	  Unlike pre-defined, standard POSIX subprofiles, this subprofile is custom to Zephyr and
-	  therefore does not need to include the base definitions or system interfaces that would
-	  otherwise be required for a conformant POSIX system or subprofile. This system profile
-	  does not itself meet the requirements for POSIX implementation conformance.
-
-	  For more information, see
-	  https://docs.zephyrproject.org/latest/contribute/coding_guidelines/index.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config POSIX_AEP_CHOICE_BASE
-	bool "Minimal POSIX System Profile"
-	select POSIX_SYSTEM_INTERFACES
-	select POSIX_BASE_DEFINITIONS
-	help
-	  Only enable the base definitions required for all POSIX systems.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_03_01
-
-config POSIX_AEP_CHOICE_PSE51
-	bool "Minimal Realtime System Profile (PSE51)"
-	select POSIX_SYSTEM_INTERFACES
-	select POSIX_BASE_DEFINITIONS
-	select POSIX_AEP_REALTIME_MINIMAL
-	help
-	  PSE51 includes the POSIX Base Definitions (System Interfaces) as well as several Options and
-	  Option Groups to facilitate device I/O, signals, mandatory configuration utilities, and
-	  threading.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config POSIX_AEP_CHOICE_PSE52
-	bool "Realtime Controller System Profile (PSE52)"
-	select POSIX_SYSTEM_INTERFACES
-	select POSIX_BASE_DEFINITIONS
-	select POSIX_AEP_REALTIME_MINIMAL
-	select POSIX_AEP_REALTIME_CONTROLLER
-	help
-	  PSE52 includes the POSIX Base Definitions (System Interfaces) as well as all features of
-	  PSE51. Additionally, it includes interfaces for file descriptor management, filesystem
-	  support, support for message queues, and tracing.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config POSIX_AEP_CHOICE_PSE53
-	bool "Dedicated Realtime System Profile (PSE53)"
-	select POSIX_SYSTEM_INTERFACES
-	select POSIX_BASE_DEFINITIONS
-	select POSIX_AEP_REALTIME_MINIMAL
-	select POSIX_AEP_REALTIME_CONTROLLER
-	select POSIX_AEP_REALTIME_DEDICATED
-	help
-	  PSE53 includes the POSIX Base Definitions (System Interfaces) as well as all features of
-	  PSE52. Additionally, it includes interfaces for POSIX multi-processing, networking, pipes,
-	  and prioritized I/O.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-# TODO: PSE54: Multi-purpose Realtime System Profile
-
-endchoice # POSIX_AEP_CHOICE
-
-if POSIX_SYSTEM_INTERFACES
-
-# Mandatory POSIX System Interfaces (base profile)
-config POSIX_BASE_DEFINITIONS
-	bool
-	select POSIX_ASYNCHRONOUS_IO
-	select POSIX_BARRIERS
-	select POSIX_CLOCK_SELECTION
-	select POSIX_MAPPED_FILES
-	select POSIX_MEMORY_PROTECTION
-	select POSIX_RW_LOCKS
-	select POSIX_REALTIME_SIGNALS
-	select POSIX_SEMAPHORES
-	select POSIX_SPIN_LOCKS
-	select POSIX_THREAD_SAFE_FUNCTIONS
-	select POSIX_THREADS
-	select POSIX_TIMEOUTS
-	select POSIX_TIMERS
-	help
-	  This option is not user configurable. It may be configured indirectly by selecting
-	  CONFIG_POSIX_AEP_CHOICE_BASE=y.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_03_01
-
-config POSIX_AEP_REALTIME_MINIMAL
-	bool
-	# Option Groups
-	select POSIX_DEVICE_IO
-	select POSIX_SIGNALS
-	select POSIX_SINGLE_PROCESS
-	select XSI
-	select XSI_THREADS_EXT
-	# Options
-	select POSIX_FSYNC
-	select POSIX_MEMLOCK
-	select POSIX_MEMLOCK_RANGE
-	select POSIX_MONOTONIC_CLOCK
-	select POSIX_SHARED_MEMORY_OBJECTS
-	select POSIX_SYNCHRONIZED_IO
-	select POSIX_THREAD_ATTR_STACKADDR
-	select POSIX_THREAD_ATTR_STACKSIZE
-	select POSIX_THREAD_CPUTIME
-	select POSIX_THREAD_PRIO_INHERIT
-	select POSIX_THREAD_PRIO_PROTECT
-	select POSIX_THREAD_PRIORITY_SCHEDULING
-	# select POSIX_THREAD_SPORADIC_SERVER
-	help
-	  This option is not user configurable. It may be configured indirectly by selecting
-	  CONFIG_POSIX_AEP_CHOICE_PSE51=y.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config POSIX_AEP_REALTIME_CONTROLLER
-	bool
-	# Option Groups
-	select POSIX_FD_MGMT
-	select POSIX_FILE_SYSTEM
-	# Options
-	select POSIX_MESSAGE_PASSING
-	# select POSIX_TRACE
-	# select POSIX_TRACE_EVENT_FILTER
-	# select POSIX_TRACE_LOG
-	help
-	  This option is not user configurable. It may be configured indirectly by selecting
-	  CONFIG_POSIX_AEP_CHOICE_PSE52=y.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config POSIX_AEP_REALTIME_DEDICATED
-	bool
-	# Option Groups
-	select POSIX_MULTI_PROCESS
-	select POSIX_NETWORKING
-	# select POSIX_PIPE
-	# select POSIX_SIGNAL_JUMP
-	# Options
-	select POSIX_CPUTIME
-	# select POSIX_PRIORITIZED_IO
-	select POSIX_PRIORITY_SCHEDULING
-	select POSIX_RAW_SOCKETS
-	# select POSIX_SPAWN
-	# select POSIX_SPORADIC_SERVER
-	help
-	  This option is not user configurable. It may be configured indirectly by selecting
-	  CONFIG_POSIX_AEP_CHOICE_PSE53=y.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-endif # POSIX_SYSTEM_INTERFACES
diff --git a/lib/posix/Kconfig.toolchain b/lib/posix/Kconfig.toolchain
deleted file mode 100644
index e22d357b2a5..00000000000
--- a/lib/posix/Kconfig.toolchain
+++ /dev/null
@@ -1,241 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-# The following list of Kconfig options are based on standard POSIX Subprofiling Option Groups
-# and may be used to override Zephyr's internal POSIX implementations. This facility is mainly
-# for toolchain integrators, C library maintainers, etc, and is not intended for general users.
-#
-# Use these features with caution as doing so might introduce unwanted, unexpected, or undefined
-# behavior.
-#
-# POSIX Subprofiling Option Groups are defined at the link below:
-#
-# https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config TC_PROVIDES_POSIX_ASYNCHRONOUS_IO
-	bool
-
-config TC_PROVIDES_POSIX_BARRIERS
-	bool
-
-config TC_PROVIDES_POSIX_C_LANG_JUMP
-	bool
-
-config TC_PROVIDES_POSIX_C_LANG_MATH
-	bool
-
-config TC_PROVIDES_POSIX_C_LANG_SUPPORT
-	bool
-
-config TC_PROVIDES_POSIX_C_LANG_SUPPORT_R
-	bool
-
-config TC_PROVIDES_POSIX_C_LANG_WIDE_CHAR
-	bool
-
-config TC_PROVIDES_POSIX_C_LANG_WIDE_CHAR_EXT
-	bool
-
-config TC_PROVIDES_POSIX_C_LIB_EXT
-	bool
-
-config TC_PROVIDES_POSIX_CLOCK_SELECTION
-	bool
-
-config TC_PROVIDES_POSIX_DEVICE_IO
-	bool
-
-config TC_PROVIDES_POSIX_DEVICE_IO_EXT
-	bool
-
-config TC_PROVIDES_POSIX_DEVICE_SPECIFIC
-	bool
-
-config TC_PROVIDES_POSIX_DEVICE_SPECIFIC_R
-	bool
-
-config TC_PROVIDES_POSIX_DYNAMIC_LINKING
-	bool
-
-config TC_PROVIDES_POSIX_FD_MGMT
-	bool
-
-config TC_PROVIDES_POSIX_FIFO
-	bool
-
-config TC_PROVIDES_POSIX_FIFO_FD
-	bool
-
-config TC_PROVIDES_POSIX_FILE_ATTRIBUTES
-	bool
-
-config TC_PROVIDES_POSIX_FILE_ATTRIBUTES_FD
-	bool
-
-config TC_PROVIDES_POSIX_FILE_LOCKING
-	bool
-
-config TC_PROVIDES_POSIX_FILE_SYSTEM
-	bool
-
-config TC_PROVIDES_POSIX_FILE_SYSTEM_EXT
-	bool
-
-config TC_PROVIDES_POSIX_FILE_SYSTEM_FD
-	bool
-
-config TC_PROVIDES_POSIX_FILE_SYSTEM_GLOB
-	bool
-
-config TC_PROVIDES_POSIX_FILE_SYSTEM_R
-	bool
-
-config TC_PROVIDES_POSIX_I18N
-	bool
-
-config TC_PROVIDES_POSIX_JOB_CONTROL
-	bool
-
-config TC_PROVIDES_POSIX_MAPPED_FILES
-	bool
-
-config TC_PROVIDES_POSIX_MEMORY_PROTECTION
-	bool
-
-config TC_PROVIDES_POSIX_MULTI_CONCURRENT_LOCALES
-	bool
-
-config TC_PROVIDES_POSIX_MULTI_PROCESS
-	bool
-
-config TC_PROVIDES_POSIX_MULTI_PROCESS_FD
-	bool
-
-config TC_PROVIDES_POSIX_NETWORKING
-	bool
-
-config TC_PROVIDES_POSIX_PIPE
-	bool
-
-config TC_PROVIDES_POSIX_ROBUST_MUTEXES
-	bool
-
-config TC_PROVIDES_POSIX_REALTIME_SIGNALS
-	bool
-
-config TC_PROVIDES_POSIX_REGEXP
-	bool
-
-config TC_PROVIDES_POSIX_RW_LOCKS
-	bool
-
-config TC_PROVIDES_POSIX_SEMAPHORES
-	bool
-
-config TC_PROVIDES_POSIX_SHELL_FUNC
-	bool
-
-config TC_PROVIDES_POSIX_SIGNAL_JUMP
-	bool
-
-config TC_PROVIDES_POSIX_SIGNALS
-	bool
-
-config TC_PROVIDES_POSIX_SIGNALS_EXT
-	bool
-
-config TC_PROVIDES_POSIX_SINGLE_PROCESS
-	bool
-
-config TC_PROVIDES_POSIX_SPIN_LOCKS
-	bool
-
-config TC_PROVIDES_POSIX_SYMBOLIC_LINKS
-	bool
-
-config TC_PROVIDES_POSIX_SYMBOLIC_LINKS_FD
-	bool
-
-config TC_PROVIDES_POSIX_SYSTEM_DATABASE
-	bool
-
-config TC_PROVIDES_POSIX_SYSTEM_DATABASE_R
-	bool
-
-# Note: the Option is _POSIX_THREADS, while the Option Group is POSIX_THREADS_BASE.
-# We have opted to use POSIX_THREADS here to match the Option name.
-config TC_PROVIDES_POSIX_THREADS
-	bool
-
-config TC_PROVIDES_POSIX_THREADS_EXT
-	bool
-
-config TC_PROVIDES_POSIX_TIMERS
-	bool
-
-config TC_PROVIDES_POSIX_USER_GROUPS
-	bool
-
-config TC_PROVIDES_POSIX_USER_GROUPS_R
-	bool
-
-config TC_PROVIDES_POSIX_WIDE_CHAR_DEVICE_IO
-	bool
-
-config TC_PROVIDES_XSI_C_LANG_SUPPORT
-	bool
-
-config TC_PROVIDES_XSI_DBM
-	bool
-
-config TC_PROVIDES_XSI_DEVICE_IO
-	bool
-
-config TC_PROVIDES_XSI_DEVICE_SPECIFIC
-	bool
-
-config TC_PROVIDES_XSI_FILE_SYSTEM
-	bool
-
-config TC_PROVIDES_XSI_IPC
-	bool
-
-config TC_PROVIDES_XSI_JUMP
-	bool
-
-config TC_PROVIDES_XSI_MATH
-	bool
-
-config TC_PROVIDES_XSI_MULTI_PROCESS
-	bool
-
-config TC_PROVIDES_XSI_REALTIME
-	bool
-
-config TC_PROVIDES_XSI_SIGNALS
-	bool
-
-config TC_PROVIDES_XSI_SINGLE_PROCESS
-	bool
-
-config TC_PROVIDES_XSI_STREAMS
-	bool
-
-config TC_PROVIDES_XSI_SYSTEM_DATABASE
-	bool
-
-config TC_PROVIDES_XSI_SYSTEM_LOGGING
-	bool
-
-config TC_PROVIDES_XSI_THREADS_EXT
-	bool
-
-config TC_PROVIDES_XSI_TIMERS
-	bool
-
-config TC_PROVIDES_XSI_USER_GROUPS
-	bool
-
-config TC_PROVIDES_XSI_WIDE_CHAR
-	bool
diff --git a/lib/posix/c_lang_support_r/Kconfig b/lib/posix/c_lang_support_r/Kconfig
deleted file mode 100644
index b2f1ae3ea4a..00000000000
--- a/lib/posix/c_lang_support_r/Kconfig
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-# Copyright (c) 2024 Meta Platforms
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config POSIX_C_LANG_SUPPORT_R
-	bool "Thread-Safe General ISO C Library"
-	select COMMON_LIBC_ASCTIME_R if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R
-	select COMMON_LIBC_CTIME_R if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R
-	select COMMON_LIBC_GMTIME_R if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R
-	select COMMON_LIBC_LOCALTIME_R_UTC if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R
-	help
-	  Select 'y' here and Zephyr will provide an implementation of the POSIX_C_LANG_SUPPORT_R
-	  Option Group, consisting of asctime_r(), ctime_r(), gmtime_r(), localtime_r(), rand_r(),
-	  strerror_r(), and strtok_r()
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
diff --git a/lib/posix/c_lib_ext/CMakeLists.txt b/lib/posix/c_lib_ext/CMakeLists.txt
deleted file mode 100644
index ee0581cb222..00000000000
--- a/lib/posix/c_lib_ext/CMakeLists.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-zephyr_include_directories(getopt)
-
-if(CONFIG_TC_PROVIDES_POSIX_C_LIB_EXT)
-  return()
-endif()
-
-zephyr_library()
-zephyr_library_sources(
-  fnmatch.c
-  getentropy.c
-  getopt/getopt.c
-  getopt/getopt_common.c
-)
-
-zephyr_library_sources_ifdef(CONFIG_GETOPT_LONG getopt/getopt_long.c)
diff --git a/lib/posix/c_lib_ext/Kconfig b/lib/posix/c_lib_ext/Kconfig
deleted file mode 100644
index 9dc4ae52520..00000000000
--- a/lib/posix/c_lib_ext/Kconfig
+++ /dev/null
@@ -1,29 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_C_LIB_EXT
-	bool "POSIX general C library extension"
-	help
-	  Select 'y' here and Zephyr will provide an implementation of the POSIX_C_LIB_EXT Option
-	  Group, consisting of fnmatch(), getopt(), getsubopt(), optarg, opterr, optind, optopt,
-	  stpcpy(), stpncpy(), strcasecmp(), strdup(), strfmon(), and strncasecmp(), strndup(), and
-	  strnlen().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_C_LIB_EXT
-
-config GETOPT_LONG
-	bool "Getopt long library support"
-	help
-	  This option adds support of the getopt long.
-	  Different shell backends are using their own instance of getopt to
-	  not interfere with each other.
-	  All not shell threads share one global instance of getopt state, hence
-	  apart from shell this library is not thread safe. User can add support
-	  for other threads by extending function getopt_state_get in
-	  getopt_common.c file.
-
-endif # POSIX_C_LIB_EXT
diff --git a/lib/posix/c_lib_ext/fnmatch.c b/lib/posix/c_lib_ext/fnmatch.c
deleted file mode 100644
index 37731787282..00000000000
--- a/lib/posix/c_lib_ext/fnmatch.c
+++ /dev/null
@@ -1,287 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause */
-
-/*    $NetBSD: fnmatch.c,v 1.26 2014/10/12 22:32:33 christos Exp $    */
-
-/*
- * Copyright (c) 1989, 1993, 1994
- *    The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Guido van Rossum.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.
- * Compares a filename or pathname to a pattern.
- */
-
-#include <ctype.h>
-#include <stdbool.h>
-#include <string.h>
-
-#include <fnmatch.h>
-#include <zephyr/toolchain.h>
-
-#define EOS '\0'
-
-#ifndef FNM_NORES
-#define FNM_NORES 3
-#endif
-
-#ifndef FNM_LEADING_DIR
-#define FNM_LEADING_DIR 0x08
-#endif
-
-#ifndef FNM_CASEFOLD
-#define FNM_CASEFOLD 0x10
-#endif
-
-static inline int foldcase(int ch, int flags)
-{
-
-	if ((flags & FNM_CASEFOLD) != 0 && isupper(ch)) {
-		return tolower(ch);
-	}
-
-	return ch;
-}
-
-#define FOLDCASE(ch, flags) foldcase((unsigned char)(ch), (flags))
-
-static const char *rangematch(const char *pattern, int test, int flags)
-{
-	bool negate, ok, need;
-	char c, c2;
-
-	if (pattern == NULL) {
-		return NULL;
-	}
-
-	/*
-	 * A bracket expression starting with an unquoted circumflex
-	 * character produces unspecified results (IEEE 1003.2-1992,
-	 * 3.13.2).  This implementation treats it like '!', for
-	 * consistency with the regular expression syntax.
-	 * J.T. Conklin (conklin@ngai.kaleida.com)
-	 */
-	negate = *pattern == '!' || *pattern == '^';
-	if (negate) {
-		++pattern;
-	}
-
-	for (need = true, ok = false, c = FOLDCASE(*pattern++, flags); c != ']' || need;
-	     c = FOLDCASE(*pattern++, flags)) {
-		need = false;
-
-		if (c == '/' && (flags & FNM_PATHNAME)) {
-			return (void *)-1;
-		}
-
-		if (c == '\\' && !(flags & FNM_NOESCAPE)) {
-			if (*pattern != ']' && *pattern != EOS) {
-				c = FOLDCASE(*pattern++, flags);
-			}
-		}
-
-		if (c == EOS) {
-			return NULL;
-		}
-
-		if (*pattern == '-') {
-			c2 = FOLDCASE(*(pattern + 1), flags);
-			if (c2 != EOS && c2 != ']') {
-				pattern += 2;
-				if (c2 == '\\' && !(flags & FNM_NOESCAPE)) {
-					c2 = FOLDCASE(*pattern++, flags);
-				}
-
-				if (c2 == EOS) {
-					return NULL;
-				}
-
-				if (c <= test && test <= c2) {
-					ok = true;
-				}
-			}
-		} else if (c == test) {
-			ok = true;
-		}
-	}
-
-	return ok == negate ? NULL : pattern;
-}
-
-static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
-{
-	const char *stringstart, *r;
-	char c, test;
-
-	if (pattern == NULL || string == NULL) {
-		return FNM_NOMATCH;
-	}
-
-	if (recursion-- == 0) {
-		return FNM_NORES;
-	}
-
-	for (stringstart = string;;) {
-		c = FOLDCASE(*pattern++, flags);
-		switch (c) {
-		case EOS:
-			if ((flags & FNM_LEADING_DIR) && *string == '/') {
-				return 0;
-			}
-
-			return *string == EOS ? 0 : FNM_NOMATCH;
-		case '?':
-			if (*string == EOS) {
-				return FNM_NOMATCH;
-			}
-
-			if (*string == '/' && (flags & FNM_PATHNAME)) {
-				return FNM_NOMATCH;
-			}
-
-			if (*string == '.' && (flags & FNM_PERIOD) &&
-			    (string == stringstart ||
-			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
-				return FNM_NOMATCH;
-			}
-
-			++string;
-			break;
-		case '*':
-			c = FOLDCASE(*pattern, flags);
-			/* Collapse multiple stars. */
-			while (c == '*') {
-				c = FOLDCASE(*++pattern, flags);
-			}
-
-			if (*string == '.' && (flags & FNM_PERIOD) &&
-			    (string == stringstart ||
-			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
-				return FNM_NOMATCH;
-			}
-
-			/* Optimize for pattern with * at end or before /. */
-			if (c == EOS) {
-				if (flags & FNM_PATHNAME) {
-					return (flags & FNM_LEADING_DIR) ||
-							       strchr(string, '/') == NULL
-						       ? 0
-						       : FNM_NOMATCH;
-				} else {
-					return 0;
-				}
-			} else if (c == '/' && flags & FNM_PATHNAME) {
-				string = strchr(string, '/');
-				if (string == NULL) {
-					return FNM_NOMATCH;
-				}
-
-				break;
-			}
-
-			/* General case, use recursion. */
-			do {
-				test = FOLDCASE(*string, flags);
-				if (test == EOS) {
-					break;
-				}
-
-				int e = fnmatchx(pattern, string, flags & ~FNM_PERIOD, recursion);
-
-				if (e != FNM_NOMATCH) {
-					return e;
-				}
-
-				if (test == '/' && flags & FNM_PATHNAME) {
-					break;
-				}
-
-				++string;
-			} while (true);
-
-			return FNM_NOMATCH;
-		case '[':
-			if (*string == EOS) {
-				return FNM_NOMATCH;
-			}
-
-			if (*string == '/' && flags & FNM_PATHNAME) {
-				return FNM_NOMATCH;
-			}
-
-			if (*string == '.' && (flags & FNM_PERIOD) &&
-			    (string == stringstart ||
-			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
-				return FNM_NOMATCH;
-			}
-
-			r = rangematch(pattern, FOLDCASE(*string, flags), flags);
-
-			if (r == NULL) {
-				if (FOLDCASE('[', flags) != FOLDCASE(*string, flags)) {
-					return FNM_NOMATCH;
-				}
-				++string;
-				break;
-			}
-
-			if (r == (void *)-1) {
-				if (*string != '[') {
-					return FNM_NOMATCH;
-				}
-			} else {
-				pattern = r;
-			}
-
-			++string;
-			break;
-		case '\\':
-			if (!(flags & FNM_NOESCAPE)) {
-				c = FOLDCASE(*pattern++, flags);
-				if (c == EOS) {
-					c = '\0';
-					--pattern;
-				}
-			}
-			__fallthrough;
-		default:
-			if (c != FOLDCASE(*string++, flags)) {
-				return FNM_NOMATCH;
-			}
-
-			break;
-		}
-	}
-}
-
-int fnmatch(const char *pattern, const char *string, int flags)
-{
-	return fnmatchx(pattern, string, flags, 64);
-}
diff --git a/lib/posix/c_lib_ext/getentropy.c b/lib/posix/c_lib_ext/getentropy.c
deleted file mode 100644
index a81e4823e39..00000000000
--- a/lib/posix/c_lib_ext/getentropy.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2024 Google LLC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-
-#include <zephyr/drivers/entropy.h>
-#include <zephyr/kernel.h>
-
-#define ENTROPY_NODE DEVICE_DT_GET_OR_NULL(DT_CHOSEN(zephyr_entropy))
-
-int getentropy(void *buffer, size_t length)
-{
-	const struct device *const entropy = ENTROPY_NODE;
-
-	if (!buffer) {
-		errno = EFAULT;
-		return -1;
-	}
-
-	if (length > 256) {
-		errno = EIO;
-		return -1;
-	}
-
-	if (entropy == NULL || !device_is_ready(entropy)) {
-		errno = EIO;
-		return -1;
-	}
-
-	/*
-	 * getentropy() uses size_t to represent buffer size, but Zephyr uses
-	 * uint16_t. The length check above allows us to safely cast without
-	 * overflow.
-	 */
-	if (entropy_get_entropy(entropy, buffer, (uint16_t)length)) {
-		errno = EIO;
-		return -1;
-	}
-
-	return 0;
-}
diff --git a/lib/posix/c_lib_ext/getopt/README b/lib/posix/c_lib_ext/getopt/README
deleted file mode 100644
index 606e93b4e6b..00000000000
--- a/lib/posix/c_lib_ext/getopt/README
+++ /dev/null
@@ -1,58 +0,0 @@
-[GetOpt]
-#####################
-
-Origin:
-   [Lattera FreeBSD]
-   [https://github.com/lattera/freebsd/blob/master/lib/libc/stdlib/getopt.c]
-
-Status:
-   [So far Zephyr samples were using getopt implementation from: argtable3.c.]
-
-Purpose:
-   [Shell users would like to parse options passed to the command handler.]
-
-Description:
-   [This library is going to be used by the shell module. Some shell users
-   are not satisfied with subcommands alone and need to use the options for
-   commands as well. A library is needed that allows the developer to parse
-   the arguments string, looking for supported options. Typically, this task
-   is accomplished by the getopt function.
-
-   For this purpose I decided to port the getopt library available
-   in the FreeBSD project. I had to modify it so that it could be used
-   by all instances of the shell at the same time.
-
-   Originally this function was using global variables which were defining
-   its state. In my implementation I put those variables in a structure
-   and a pointer to that structure is passed as an additional parameter
-   to getopt function. In proposed implementation each shell backend has its
-   own getopt function state structure which it uses.
-
-   This module is intended to be used inside the shell command handler
-   by the abstraction layer "SHELL_GETOPT". For example:
-   while ((char c = shell_getopt(sh, argc, argv, "abhc:")) != -1) {
-      /* some code */
-   }
-   ]
-
-Dependencies:
-   [This package does not depend on any other component.
-
-   Zephyr project will only need this component if the user configures a shell
-   module: SHELL_GETOPT.]
-
-URL:
-   [https://github.com/lattera/freebsd]
-
-commit:
-   [324e4c082c14aebf00f8dbee0fb7ad285393756a]
-
-Maintained-by:
-   [External]
-
-License:
-   [BSD 3-Clause "New" or "Revised" License]
-
-License Link:
-   [BSD 3-Clause used in getopt: https://spdx.org/licenses/BSD-3-Clause.html]
-   [Project license: https://github.com/lattera/freebsd/blob/master/COPYRIGHT]
diff --git a/lib/posix/c_lib_ext/getopt/getopt.c b/lib/posix/c_lib_ext/getopt/getopt.c
deleted file mode 100644
index 39638cd3a62..00000000000
--- a/lib/posix/c_lib_ext/getopt/getopt.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/*	$NetBSD: getopt.c,v 1.26 2003/08/07 16:43:40 agc Exp $	*/
-/* SPDX-License-Identifier: BSD-3-Clause */
-/*
- * Copyright (c) 1987, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <string.h>
-#include "getopt.h"
-#include "getopt_common.h"
-
-#include <zephyr/logging/log.h>
-LOG_MODULE_REGISTER(getopt);
-
-#define BADCH  ((int)'?')
-#define BADARG ((int)':')
-#define EMSG   ""
-
-void getopt_init(void)
-{
-	struct getopt_state *state;
-
-	state = getopt_state_get();
-
-	state->opterr = 1;
-	state->optind = 1;
-	state->optopt = 0;
-	state->optreset = 0;
-	state->optarg = NULL;
-
-	state->place = ""; /* EMSG */
-
-#if CONFIG_GETOPT_LONG
-	state->nonopt_start = -1; /* first non option argument (for permute) */
-	state->nonopt_end = -1;   /* first option after non options (for permute) */
-#endif
-
-	opterr = 1;
-	optind = 1;
-	optopt = 0;
-	optreset = 0;
-	optarg = NULL;
-}
-
-/*
- * getopt --
- *	Parse argc/argv argument vector.
- */
-int getopt(int nargc, char *const nargv[], const char *ostr)
-{
-	struct getopt_state *state;
-	char *oli; /* option letter list index */
-
-	/* get getopt state of the current thread */
-	state = getopt_state_get();
-
-	if (state->optreset || *state->place == 0) { /* update scanning pointer */
-		state->optreset = 0;
-		state->place = nargv[state->optind];
-		if (state->optind >= nargc || *state->place++ != '-') {
-			/* Argument is absent or is not an option */
-			state->place = EMSG;
-			z_getopt_global_state_update(state);
-			return -1;
-		}
-		state->optopt = *state->place++;
-		if (state->optopt == '-' && *state->place == 0) {
-			/* "--" => end of options */
-			++state->optind;
-			state->place = EMSG;
-			z_getopt_global_state_update(state);
-			return -1;
-		}
-		if (state->optopt == 0) {
-			/* Solitary '-', treat as a '-' option
-			 * if the program (eg su) is looking for it.
-			 */
-			state->place = EMSG;
-			if (strchr(ostr, '-') == NULL) {
-				z_getopt_global_state_update(state);
-				return -1;
-			}
-			state->optopt = '-';
-		}
-	} else {
-		state->optopt = *state->place++;
-	}
-
-	/* See if option letter is one the caller wanted... */
-	oli = strchr(ostr, state->optopt);
-	if (state->optopt == ':' || oli == NULL) {
-		if (*state->place == 0) {
-			++state->optind;
-		}
-		if (state->opterr && *ostr != ':') {
-			LOG_DBG("illegal option -- %c", state->optopt);
-		}
-		z_getopt_global_state_update(state);
-		return BADCH;
-	}
-
-	/* Does this option need an argument? */
-	if (oli[1] != ':') {
-		/* don't need argument */
-		state->optarg = NULL;
-		if (*state->place == 0) {
-			++state->optind;
-		}
-	} else {
-		/* Option-argument is either the rest of this argument or the
-		 * entire next argument.
-		 */
-		if (*state->place) {
-			state->optarg = state->place;
-		} else if (nargc > ++state->optind) {
-			state->optarg = nargv[state->optind];
-		} else {
-			/* option-argument absent */
-			state->place = EMSG;
-			if (*ostr == ':') {
-				z_getopt_global_state_update(state);
-				return BADARG;
-			}
-			if (state->opterr) {
-				LOG_DBG("option requires an argument -- %c", state->optopt);
-			}
-			z_getopt_global_state_update(state);
-			return BADCH;
-		}
-		state->place = EMSG;
-		++state->optind;
-	}
-	z_getopt_global_state_update(state);
-	return state->optopt; /* return option letter */
-}
diff --git a/lib/posix/c_lib_ext/getopt/getopt.h b/lib/posix/c_lib_ext/getopt/getopt.h
deleted file mode 100644
index eb0641f6c90..00000000000
--- a/lib/posix/c_lib_ext/getopt/getopt.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2021 Nordic Semiconductor ASA
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef _GETOPT_H__
-#define _GETOPT_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <zephyr/kernel.h>
-
-struct getopt_state {
-	int opterr;   /* if error message should be printed */
-	int optind;   /* index into parent argv vector */
-	int optopt;   /* character checked for validity */
-	int optreset; /* reset getopt */
-	char *optarg; /* argument associated with option */
-
-	char *place; /* option letter processing */
-
-#if CONFIG_GETOPT_LONG
-	int nonopt_start;
-	int nonopt_end;
-#endif
-};
-
-extern int optreset; /* reset getopt */
-extern char *optarg;
-extern int opterr;
-extern int optind;
-extern int optopt;
-
-#define no_argument       0
-#define required_argument 1
-#define optional_argument 2
-
-struct option {
-	/* name of long option */
-	const char *name;
-	/*
-	 * one of no_argument, required_argument, and optional_argument:
-	 * whether option takes an argument
-	 */
-	int has_arg;
-	/* if not NULL, set *flag to val when option found */
-	int *flag;
-	/* if flag not NULL, value to set *flag to; else return value */
-	int val;
-};
-
-/* Function initializes getopt_state structure for current thread */
-void getopt_init(void);
-
-/* Function returns getopt_state structure for the current thread. */
-struct getopt_state *getopt_state_get(void);
-
-/**
- * @brief Parses the command-line arguments.
- *
- * The getopt_long() function works like @ref getopt() except
- * it also accepts long options, started with two dashes.
- *
- * @note This function is based on FreeBSD implementation but it does not
- * support environment variable: POSIXLY_CORRECT.
- *
- * @param[in] argc	   Arguments count.
- * @param[in] argv	   Arguments.
- * @param[in] options	   String containing the legitimate option characters.
- * @param[in] long_options Pointer to the first element of an array of
- *			   @a struct z_option.
- * @param[in] long_idx	   If long_idx is not NULL, it points to a variable
- *			   which is set to the index of the long option relative
- *			   to @p long_options.
- *
- * @return		If an option was successfully found, function returns
- *			the option character.
- */
-int getopt_long(int nargc, char *const *nargv, const char *options,
-		const struct option *long_options, int *idx);
-
-/**
- * @brief Parses the command-line arguments.
- *
- * The getopt_long_only() function works like @ref getopt_long(),
- * but '-' as well as "--" can indicate a long option. If an option that starts
- * with '-' (not "--") doesn't match a long option, but does match a short
- * option, it is parsed as a short option instead.
- *
- * @note This function is based on FreeBSD implementation but it does not
- * support environment variable: POSIXLY_CORRECT.
- *
- * @param[in] argc	   Arguments count.
- * @param[in] argv	   Arguments.
- * @param[in] options	   String containing the legitimate option characters.
- * @param[in] long_options Pointer to the first element of an array of
- *			   @a struct option.
- * @param[in] long_idx	   If long_idx is not NULL, it points to a variable
- *			   which is set to the index of the long option relative
- *			   to @p long_options.
- *
- * @return		If an option was successfully found, function returns
- *			the option character.
- */
-int getopt_long_only(int nargc, char *const *nargv, const char *options,
-		     const struct option *long_options, int *idx);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _GETOPT_H__ */
diff --git a/lib/posix/c_lib_ext/getopt/getopt_common.c b/lib/posix/c_lib_ext/getopt/getopt_common.c
deleted file mode 100644
index 2599d2c2d98..00000000000
--- a/lib/posix/c_lib_ext/getopt/getopt_common.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2021 Nordic Semiconductor ASA
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include <zephyr/kernel.h>
-#include <zephyr/shell/shell.h>
-#if CONFIG_SHELL_GETOPT
-#include <zephyr/sys/iterable_sections.h>
-#endif
-
-#include "getopt.h"
-
-/* Referring  below variables is not thread safe. They reflects getopt state
- * only when 1 thread is using getopt.
- * When more threads are using getopt please call getopt_state_get to know
- * getopt state for the current thread.
- */
-int opterr = 1; /* if error message should be printed */
-int optind = 1; /* index into parent argv vector */
-int optopt;     /* character checked for validity */
-int optreset;   /* reset getopt */
-char *optarg;   /* argument associated with option */
-
-/* Common state for all threads that did not have own getopt state. */
-static struct getopt_state m_getopt_common_state = {
-	.opterr = 1,
-	.optind = 1,
-	.optopt = 0,
-	.optreset = 0,
-	.optarg = NULL,
-
-	.place = "", /* EMSG */
-
-#if CONFIG_GETOPT_LONG
-	.nonopt_start = -1, /* first non option argument (for permute) */
-	.nonopt_end = -1,   /* first option after non options (for permute) */
-#endif
-};
-
-/* This function is not thread safe. All threads using getopt are calling
- * this function.
- */
-void z_getopt_global_state_update(struct getopt_state *state)
-{
-	opterr = state->opterr;
-	optind = state->optind;
-	optopt = state->optopt;
-	optreset = state->optreset;
-	optarg = state->optarg;
-}
-
-/* It is internal getopt API function, it shall not be called by the user. */
-struct getopt_state *getopt_state_get(void)
-{
-#if CONFIG_SHELL_GETOPT
-	k_tid_t tid;
-
-	tid = k_current_get();
-	STRUCT_SECTION_FOREACH(shell, sh) {
-		if (tid == sh->ctx->tid) {
-			return &sh->ctx->getopt;
-		}
-	}
-#endif
-	/* If not a shell thread return a common pointer */
-	return &m_getopt_common_state;
-}
diff --git a/lib/posix/c_lib_ext/getopt/getopt_common.h b/lib/posix/c_lib_ext/getopt/getopt_common.h
deleted file mode 100644
index b0ec82bf921..00000000000
--- a/lib/posix/c_lib_ext/getopt/getopt_common.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2021 Nordic Semiconductor ASA
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef _GETOPT_COMMON_H__
-#define _GETOPT_COMMON_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* This function is not thread safe. All threads using getopt are calling
- * this function.
- */
-void z_getopt_global_state_update(struct getopt_state *state);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _GETOPT_COMMON_H__ */
diff --git a/lib/posix/c_lib_ext/getopt/getopt_long.c b/lib/posix/c_lib_ext/getopt/getopt_long.c
deleted file mode 100644
index e39a13b3bbc..00000000000
--- a/lib/posix/c_lib_ext/getopt/getopt_long.c
+++ /dev/null
@@ -1,601 +0,0 @@
-/*	$OpenBSD: getopt_long.c,v 1.22 2006/10/04 21:29:04 jmc Exp $	*/
-/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/
-
-/*
- * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * Sponsored in part by the Defense Advanced Research Projects
- * Agency (DARPA) and Air Force Research Laboratory, Air Force
- * Materiel Command, USAF, under agreement number F39502-99-1-0512.
- */
-/*
- * Copyright (c) 2000 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Dieter Baron and Thomas Klausner.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <string.h>
-#include "getopt.h"
-#include "getopt_common.h"
-
-#include <zephyr/logging/log.h>
-LOG_MODULE_DECLARE(getopt);
-
-#define GNU_COMPATIBLE /* Be more compatible, configure's use us! */
-
-#define PRINT_ERROR ((state->opterr) && (*options != ':'))
-
-#define FLAG_PERMUTE  0x01 /* permute non-options to the end of argv */
-#define FLAG_ALLARGS  0x02 /* treat non-options as args to option "-1" */
-#define FLAG_LONGONLY 0x04 /* operate as getopt_long_only */
-
-/* return values */
-#define BADCH   (int)'?'
-#define BADARG  ((*options == ':') ? (int)':' : (int)'?')
-#define INORDER 1
-
-#define EMSG ""
-
-#ifdef GNU_COMPATIBLE
-#define NO_PREFIX (-1)
-#define D_PREFIX  0
-#define DD_PREFIX 1
-#define W_PREFIX  2
-#endif
-
-static int getopt_internal(struct getopt_state *, int, char *const *, const char *,
-			   const struct option *, int *, int);
-static int parse_long_options(struct getopt_state *, char *const *, const char *,
-			      const struct option *, int *, int, int);
-static int gcd(int, int);
-static void permute_args(int, int, int, char *const *);
-
-/* Error messages */
-#define RECARGCHAR "option requires an argument -- %c"
-#define ILLOPTCHAR "illegal option -- %c" /* From P1003.2 */
-#ifdef GNU_COMPATIBLE
-static int dash_prefix = NO_PREFIX;
-#define GNUOPTCHAR "invalid option -- %c"
-
-#define RECARGSTRING "option `%s%s' requires an argument"
-#define AMBIG        "option `%s%.*s' is ambiguous"
-#define NOARG        "option `%s%.*s' doesn't allow an argument"
-#define ILLOPTSTRING "unrecognized option `%s%s'"
-#else
-#define RECARGSTRING "option requires an argument -- %s"
-#define AMBIG        "ambiguous option -- %.*s"
-#define NOARG        "option doesn't take an argument -- %.*s"
-#define ILLOPTSTRING "unknown option -- %s"
-#endif
-
-/*
- * Compute the greatest common divisor of a and b.
- */
-static int gcd(int a, int b)
-{
-	int c;
-
-	c = a % b;
-	while (c != 0) {
-		a = b;
-		b = c;
-		c = a % b;
-	}
-
-	return b;
-}
-
-/*
- * Exchange the block from nonopt_start to nonopt_end with the block
- * from nonopt_end to opt_end (keeping the same order of arguments
- * in each block).
- */
-static void permute_args(int panonopt_start, int panonopt_end, int opt_end, char *const *nargv)
-{
-	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
-	char *swap;
-
-	/*
-	 * compute lengths of blocks and number and size of cycles
-	 */
-	nnonopts = panonopt_end - panonopt_start;
-	nopts = opt_end - panonopt_end;
-	ncycle = gcd(nnonopts, nopts);
-	cyclelen = (opt_end - panonopt_start) / ncycle;
-
-	for (i = 0; i < ncycle; i++) {
-		cstart = panonopt_end + i;
-		pos = cstart;
-		for (j = 0; j < cyclelen; j++) {
-			if (pos >= panonopt_end) {
-				pos -= nnonopts;
-			} else {
-				pos += nopts;
-			}
-			swap = nargv[pos];
-			/* LINTED const cast */
-			((char **)nargv)[pos] = nargv[cstart];
-			/* LINTED const cast */
-			((char **)nargv)[cstart] = swap;
-		}
-	}
-}
-
-/*
- * parse_long_options --
- *	Parse long options in argc/argv argument vector.
- * Returns -1 if short_too is set and the option does not match long_options.
- */
-static int parse_long_options(struct getopt_state *state, char *const *nargv, const char *options,
-			      const struct option *long_options, int *idx, int short_too, int flags)
-{
-	char *current_argv, *has_equal;
-#ifdef GNU_COMPATIBLE
-	char *current_dash = "";
-#endif
-	size_t current_argv_len;
-	int i, match, exact_match, second_partial_match;
-
-	current_argv = state->place;
-#ifdef GNU_COMPATIBLE
-	if (PRINT_ERROR) {
-		switch (dash_prefix) {
-		case D_PREFIX:
-			current_dash = "-";
-			break;
-		case DD_PREFIX:
-			current_dash = "--";
-			break;
-		case W_PREFIX:
-			current_dash = "-W ";
-			break;
-		default:
-			break;
-		}
-	}
-#endif
-	match = -1;
-	exact_match = 0;
-	second_partial_match = 0;
-
-	state->optind++;
-
-	has_equal = strchr(current_argv, '=');
-	if (has_equal != NULL) {
-		/* argument found (--option=arg) */
-		current_argv_len = has_equal - current_argv;
-		has_equal++;
-	} else {
-		current_argv_len = strlen(current_argv);
-	}
-
-	for (i = 0; long_options[i].name; i++) {
-		/* find matching long option */
-		if (strncmp(current_argv, long_options[i].name, current_argv_len)) {
-			continue;
-		}
-
-		if (strlen(long_options[i].name) == current_argv_len) {
-			/* exact match */
-			match = i;
-			exact_match = 1;
-			break;
-		}
-		/*
-		 * If this is a known short option, don't allow
-		 * a partial match of a single character.
-		 */
-		if (short_too && current_argv_len == 1) {
-			continue;
-		}
-
-		if (match == -1) { /* first partial match */
-			match = i;
-		} else if ((flags & FLAG_LONGONLY) ||
-			   long_options[i].has_arg != long_options[match].has_arg ||
-			   long_options[i].flag != long_options[match].flag ||
-			   long_options[i].val != long_options[match].val) {
-			second_partial_match = 1;
-		}
-	}
-	if (!exact_match && second_partial_match) {
-		/* ambiguous abbreviation */
-		if (PRINT_ERROR) {
-			LOG_WRN(AMBIG,
-#ifdef GNU_COMPATIBLE
-				current_dash,
-#endif
-				(int)current_argv_len, current_argv);
-		}
-		state->optopt = 0;
-		return BADCH;
-	}
-	if (match != -1) { /* option found */
-		if (long_options[match].has_arg == no_argument && has_equal) {
-			if (PRINT_ERROR) {
-				LOG_WRN(NOARG,
-#ifdef GNU_COMPATIBLE
-					current_dash,
-#endif
-					(int)current_argv_len, current_argv);
-			}
-			/*
-			 * XXX: GNU sets optopt to val regardless of flag
-			 */
-			if (long_options[match].flag == NULL) {
-				state->optopt = long_options[match].val;
-			} else {
-				state->optopt = 0;
-			}
-#ifdef GNU_COMPATIBLE
-			return BADCH;
-#else
-			return BADARG;
-#endif
-		}
-		if (long_options[match].has_arg == required_argument ||
-		    long_options[match].has_arg == optional_argument) {
-			if (has_equal) {
-				state->optarg = has_equal;
-			} else if (long_options[match].has_arg == required_argument) {
-				/*
-				 * optional argument doesn't use next nargv
-				 */
-				state->optarg = nargv[state->optind++];
-			}
-		}
-		if ((long_options[match].has_arg == required_argument) && (state->optarg == NULL)) {
-			/*
-			 * Missing argument; leading ':' indicates no error
-			 * should be generated.
-			 */
-			if (PRINT_ERROR) {
-				LOG_WRN(RECARGSTRING,
-#ifdef GNU_COMPATIBLE
-					current_dash,
-#endif
-					current_argv);
-			}
-			/*
-			 * XXX: GNU sets optopt to val regardless of flag
-			 */
-			if (long_options[match].flag == NULL) {
-				state->optopt = long_options[match].val;
-			} else {
-				state->optopt = 0;
-			}
-			--state->optind;
-			return BADARG;
-		}
-	} else { /* unknown option */
-		if (short_too) {
-			--state->optind;
-			return -1;
-		}
-		if (PRINT_ERROR) {
-			LOG_WRN(ILLOPTSTRING,
-#ifdef GNU_COMPATIBLE
-				current_dash,
-#endif
-				current_argv);
-		}
-		state->optopt = 0;
-		return BADCH;
-	}
-	if (idx) {
-		*idx = match;
-	}
-	if (long_options[match].flag) {
-		*long_options[match].flag = long_options[match].val;
-		return 0;
-	} else {
-		return long_options[match].val;
-	}
-}
-
-/*
- * getopt_internal --
- *	Parse argc/argv argument vector.  Called by user level routines.
- */
-static int getopt_internal(struct getopt_state *state, int nargc, char *const *nargv,
-			   const char *options, const struct option *long_options, int *idx,
-			   int flags)
-{
-	char *oli; /* option letter list index */
-	int optchar, short_too;
-
-	if (options == NULL) {
-		return -1;
-	}
-
-	/*
-	 * Disable GNU extensions if options string begins with a '+'.
-	 */
-#ifdef GNU_COMPATIBLE
-	if (*options == '-') {
-		flags |= FLAG_ALLARGS;
-	} else if (*options == '+') {
-		flags &= ~FLAG_PERMUTE;
-	}
-#else
-	if (*options == '+') {
-		flags &= ~FLAG_PERMUTE;
-	} else if (*options == '-') {
-		flags |= FLAG_ALLARGS;
-	}
-#endif
-	if (*options == '+' || *options == '-') {
-		options++;
-	}
-
-	/*
-	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
-	 * XXX using optreset.  Work around this braindamage.
-	 */
-	if (state->optind == 0) {
-		state->optind = state->optreset = 1;
-	}
-
-	state->optarg = NULL;
-	if (state->optreset) {
-		state->nonopt_start = state->nonopt_end = -1;
-	}
-start:
-	if (state->optreset || !*(state->place)) { /* update scanning pointer */
-		state->optreset = 0;
-		if (state->optind >= nargc) { /* end of argument vector */
-			state->place = EMSG;
-			if (state->nonopt_end != -1) {
-				/* do permutation, if we have to */
-				permute_args(state->nonopt_start, state->nonopt_end, state->optind,
-					     nargv);
-				state->optind -= state->nonopt_end - state->nonopt_start;
-			} else if (state->nonopt_start != -1) {
-				/*
-				 * If we skipped non-options, set optind
-				 * to the first of them.
-				 */
-				state->optind = state->nonopt_start;
-			}
-			state->nonopt_start = state->nonopt_end = -1;
-			return -1;
-		}
-		state->place = nargv[state->optind];
-		if (*(state->place) != '-' ||
-#ifdef GNU_COMPATIBLE
-		    state->place[1] == '\0') {
-#else
-		    (state->place[1] == '\0' && strchr(options, '-') == NULL)) {
-#endif
-			state->place = EMSG; /* found non-option */
-			if (flags & FLAG_ALLARGS) {
-				/*
-				 * GNU extension:
-				 * return non-option as argument to option 1
-				 */
-				state->optarg = nargv[state->optind++];
-				return INORDER;
-			}
-			if (!(flags & FLAG_PERMUTE)) {
-				/*
-				 * If no permutation wanted, stop parsing
-				 * at first non-option.
-				 */
-				return -1;
-			}
-			/* do permutation */
-			if (state->nonopt_start == -1) {
-				state->nonopt_start = state->optind;
-			} else if (state->nonopt_end != -1) {
-				permute_args(state->nonopt_start, state->nonopt_end, state->optind,
-					     nargv);
-				state->nonopt_start =
-					state->optind - (state->nonopt_end - state->nonopt_start);
-				state->nonopt_end = -1;
-			}
-			state->optind++;
-			/* process next argument */
-			goto start;
-		}
-		if (state->nonopt_start != -1 && state->nonopt_end == -1) {
-			state->nonopt_end = state->optind;
-		}
-
-		/*
-		 * If we have "-" do nothing, if "--" we are done.
-		 */
-		if (state->place[1] != '\0' && *++(state->place) == '-' &&
-		    state->place[1] == '\0') {
-			state->optind++;
-			state->place = EMSG;
-			/*
-			 * We found an option (--), so if we skipped
-			 * non-options, we have to permute.
-			 */
-			if (state->nonopt_end != -1) {
-				permute_args(state->nonopt_start, state->nonopt_end, state->optind,
-					     nargv);
-				state->optind -= state->nonopt_end - state->nonopt_start;
-			}
-			state->nonopt_start = state->nonopt_end = -1;
-			return -1;
-		}
-	}
-
-	/*
-	 * Check long options if:
-	 *  1) we were passed some
-	 *  2) the arg is not just "-"
-	 *  3) either the arg starts with -- we are getopt_long_only()
-	 */
-	if (long_options != NULL && state->place != nargv[state->optind] &&
-	    (*(state->place) == '-' || (flags & FLAG_LONGONLY))) {
-		short_too = 0;
-#ifdef GNU_COMPATIBLE
-		dash_prefix = D_PREFIX;
-#endif
-		if (*(state->place) == '-') {
-			state->place++; /* --foo long option */
-#ifdef GNU_COMPATIBLE
-			dash_prefix = DD_PREFIX;
-#endif
-		} else if (*(state->place) != ':' && strchr(options, *(state->place)) != NULL) {
-			short_too = 1; /* could be short option too */
-		}
-
-		optchar = parse_long_options(state, nargv, options, long_options, idx, short_too,
-					     flags);
-		if (optchar != -1) {
-			state->place = EMSG;
-			return optchar;
-		}
-	}
-	optchar = (int)*(state->place)++;
-	oli = strchr(options, optchar);
-	if (optchar == (int)':' || (optchar == (int)'-' && *(state->place) != '\0') ||
-	    oli == NULL) {
-		/*
-		 * If the user specified "-" and  '-' isn't listed in
-		 * options, return -1 (non-option) as per POSIX.
-		 * Otherwise, it is an unknown option character (or ':').
-		 */
-		if (optchar == (int)'-' && *(state->place) == '\0') {
-			return -1;
-		}
-		if (!*(state->place)) {
-			++state->optind;
-		}
-#ifdef GNU_COMPATIBLE
-		if (PRINT_ERROR) {
-			LOG_WRN(GNUOPTCHAR, optchar);
-		}
-#else
-		if (PRINT_ERROR) {
-			LOG_WRN(ILLOPTCHAR, optchar);
-		}
-#endif
-		state->optopt = optchar;
-		return BADCH;
-	}
-	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
-		/* -W long-option */
-		if (*(state->place)) {                   /* no space */
-			;                                /* NOTHING */
-		} else if (++(state->optind) >= nargc) { /* no arg */
-			state->place = EMSG;
-			if (PRINT_ERROR) {
-				LOG_WRN(RECARGCHAR, optchar);
-			}
-			state->optopt = optchar;
-			return BADARG;
-		} else if ((state->optind) < nargc) {
-			state->place = nargv[state->optind];
-		}
-#ifdef GNU_COMPATIBLE
-		dash_prefix = W_PREFIX;
-#endif
-		optchar = parse_long_options(state, nargv, options, long_options, idx, 0, flags);
-		state->place = EMSG;
-		return optchar;
-	}
-	if (*++oli != ':') { /* doesn't take argument */
-		if (!*(state->place)) {
-			++state->optind;
-		}
-	} else { /* takes (optional) argument */
-		state->optarg = NULL;
-		if (*(state->place)) { /* no white space */
-			state->optarg = state->place;
-		} else if (oli[1] != ':') {             /* arg not optional */
-			if (++state->optind >= nargc) { /* no arg */
-				state->place = EMSG;
-				if (PRINT_ERROR) {
-					LOG_WRN(RECARGCHAR, optchar);
-				}
-				state->optopt = optchar;
-				return BADARG;
-			}
-			state->optarg = nargv[state->optind];
-		}
-		state->place = EMSG;
-		++state->optind;
-	}
-	/* dump back option letter */
-	return optchar;
-}
-
-/*
- * getopt_long --
- *	Parse argc/argv argument vector.
- */
-int getopt_long(int nargc, char *const *nargv, const char *options,
-		const struct option *long_options, int *idx)
-{
-	struct getopt_state *state;
-	int ret;
-
-	/* Get state of the current thread */
-	state = getopt_state_get();
-
-	ret = getopt_internal(state, nargc, nargv, options, long_options, idx, FLAG_PERMUTE);
-
-	z_getopt_global_state_update(state);
-
-	return ret;
-}
-
-/*
- * getopt_long_only --
- *	Parse argc/argv argument vector.
- */
-int getopt_long_only(int nargc, char *const *nargv, const char *options,
-		     const struct option *long_options, int *idx)
-{
-	struct getopt_state *state;
-	int ret;
-
-	/* Get state of the current thread */
-	state = getopt_state_get();
-
-	ret = getopt_internal(state, nargc, nargv, options, long_options, idx,
-			      FLAG_PERMUTE | FLAG_LONGONLY);
-
-	z_getopt_global_state_update(state);
-
-	return ret;
-}
diff --git a/lib/posix/eventfd/CMakeLists.txt b/lib/posix/eventfd/CMakeLists.txt
deleted file mode 100644
index 2736572dd00..00000000000
--- a/lib/posix/eventfd/CMakeLists.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-zephyr_library()
-zephyr_library_sources(eventfd.c)
diff --git a/lib/posix/eventfd/Kconfig b/lib/posix/eventfd/Kconfig
deleted file mode 100644
index 019daef4a35..00000000000
--- a/lib/posix/eventfd/Kconfig
+++ /dev/null
@@ -1,13 +0,0 @@
-# Copyright (c) 2020 Tobias Svehagen
-# Copyright (c) 2023 Meta
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config EVENTFD
-	bool "Support for eventfd"
-	select ZVFS
-	select ZVFS_EVENTFD
-	help
-	  Enable support for event file descriptors, eventfd. An eventfd can
-	  be used as an event wait/notify mechanism together with POSIX calls
-	  like read, write and poll.
diff --git a/lib/posix/eventfd/eventfd.c b/lib/posix/eventfd/eventfd.c
deleted file mode 100644
index c021b5dadb6..00000000000
--- a/lib/posix/eventfd/eventfd.c
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <sys/eventfd.h>
-#include <zephyr/zvfs/eventfd.h>
-
-int eventfd(unsigned int initval, int flags)
-{
-	return zvfs_eventfd(initval, flags);
-}
-
-int eventfd_read(int fd, eventfd_t *value)
-{
-	return zvfs_eventfd_read(fd, value);
-}
-
-int eventfd_write(int fd, eventfd_t value)
-{
-	return zvfs_eventfd_write(fd, value);
-}
diff --git a/lib/posix/options/CMakeLists.txt b/lib/posix/options/CMakeLists.txt
deleted file mode 100644
index 59b51d59f03..00000000000
--- a/lib/posix/options/CMakeLists.txt
+++ /dev/null
@@ -1,166 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-set(POSIX_VERSION 200809L)
-set(XOPEN_VERSION 700)
-set(GEN_DIR ${ZEPHYR_BINARY_DIR}/include/generated)
-
-if(CONFIG_POSIX_SYSTEM_INTERFACES)
-  zephyr_compile_options("SHELL: $<$<COMPILE_LANGUAGE:C>:$<TARGET_PROPERTY:compiler,imacros> ${ZEPHYR_BASE}/include/zephyr/posix/posix_features.h>")
-  zephyr_compile_options("SHELL: $<$<COMPILE_LANGUAGE:CXX>:$<TARGET_PROPERTY:compiler,imacros> ${ZEPHYR_BASE}/include/zephyr/posix/posix_features.h>")
-endif()
-
-zephyr_syscall_header_ifdef(CONFIG_POSIX_CLOCK_SELECTION posix_clock.h)
-zephyr_syscall_header_ifdef(CONFIG_POSIX_TIMERS posix_clock.h)
-zephyr_syscall_header_ifdef(CONFIG_XSI_SINGLE_PROCESS posix_clock.h)
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_SIGNALS)
-  if(CONFIG_POSIX_SIGNALS)
-    set(STRSIGNAL_TABLE_H ${GEN_DIR}/posix/strsignal_table.h)
-
-    add_custom_command(
-      OUTPUT ${STRSIGNAL_TABLE_H}
-      COMMAND
-      ${PYTHON_EXECUTABLE}
-      ${ZEPHYR_BASE}/scripts/build/gen_strsignal_table.py
-      -i ${ZEPHYR_BASE}/include/zephyr/posix/posix_signal.h
-      -o ${STRSIGNAL_TABLE_H}
-      DEPENDS ${ZEPHYR_BASE}/include/zephyr/posix/posix_signal.h
-    )
-  endif()
-endif()
-
-zephyr_library()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_ASYNCHRONOUS_IO)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_ASYNCHRONOUS_IO aio.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_BARRIERS)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_BARRIERS barrier.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_CLOCK_SELECTION)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_CLOCK_SELECTION clock_selection.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_DEVICE_IO)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_DEVICE_IO
-    # perror should be moved to the common libc
-    perror.c
-    device_io.c
-  )
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_FD_MGMT)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_FD_MGMT
-    fd_mgmt.c
-  )
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_FILE_SYSTEM)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_FILE_SYSTEM fs.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_FILE_SYSTEM_R)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_FILE_SYSTEM_R file_system_r.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_MEMORY_PROTECTION)
-zephyr_library_sources_ifdef(CONFIG_POSIX_MEMORY_PROTECTION mprotect.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_MAPPED_FILES)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_MAPPED_FILES mmap.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_MULTI_PROCESS)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_MULTI_PROCESS
-    sleep.c
-    multi_process.c
-  )
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_NETWORKING)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_NETWORKING net.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_SIGNALS)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_SIGNALS signal.c ${STRSIGNAL_TABLE_H})
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_SINGLE_PROCESS)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_SINGLE_PROCESS
-    confstr.c
-    env.c
-    env_common.c
-    sysconf.c
-    uname.c
-  )
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_SPIN_LOCKS)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_SPIN_LOCKS spinlock.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_TIMERS)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_TIMERS
-    clock.c
-    timer.c
-    timespec_to_timeout.c
-  )
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_RW_LOCKS)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_RW_LOCKS rwlock.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_SEMAPHORES)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_SEMAPHORES semaphore.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_POSIX_THREADS)
-  # Note: the Option is _POSIX_THREADS, while the Option Group is POSIX_THREADS_BASE.
-  # We have opted to use POSIX_THREADS here to match the Option name.
-  zephyr_library_sources_ifdef(CONFIG_POSIX_THREADS
-    cond.c
-    grp.c
-    key.c
-    mutex.c
-    pthread.c
-    pwd.c
-  )
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_XSI_REALTIME)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_FSYNC fsync.c)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_MEMLOCK mlockall.c)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_MEMLOCK_RANGE mlock.c)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_MESSAGE_PASSING mqueue.c)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_PRIORITY_SCHEDULING sched.c)
-  zephyr_library_sources_ifdef(CONFIG_POSIX_SHARED_MEMORY_OBJECTS shm.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_XSI_SINGLE_PROCESS)
-  zephyr_library_sources_ifdef(CONFIG_XSI_SINGLE_PROCESS
-    env_common.c
-    xsi_single_process.c
-  )
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_XSI_STREAMS)
-  zephyr_library_sources_ifdef(CONFIG_XSI_STREAMS stropts.c)
-endif()
-
-if(NOT CONFIG_TC_PROVIDES_XSI_SYSTEM_LOGGING)
-  zephyr_library_sources_ifdef(CONFIG_XSI_SYSTEM_LOGGING syslog.c)
-endif()
-
-zephyr_library_include_directories(
-  ${ZEPHYR_BASE}/kernel/include
-  ${ARCH_DIR}/${ARCH}/include
-)
-
-zephyr_library_property(ALLOW_EMPTY TRUE)
-
-zephyr_library_compile_options(-U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-zephyr_library_compile_options_ifdef(CONFIG_XSI -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/lib/posix/options/Kconfig b/lib/posix/options/Kconfig
deleted file mode 100644
index 908f9ac1899..00000000000
--- a/lib/posix/options/Kconfig
+++ /dev/null
@@ -1,32 +0,0 @@
-# Copyright (c) 2018 Intel Corporation
-# Copyright (c) 2023 Meta
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-# zephyr-keep-sorted-start
-rsource "Kconfig.aio"
-rsource "Kconfig.barrier"
-rsource "Kconfig.device_io"
-rsource "Kconfig.fd_mgmt"
-rsource "Kconfig.file_system_r"
-rsource "Kconfig.fs"
-rsource "Kconfig.mem"
-rsource "Kconfig.mqueue"
-rsource "Kconfig.net"
-rsource "Kconfig.proc1"
-rsource "Kconfig.procN"
-rsource "Kconfig.pthread"
-rsource "Kconfig.rwlock"
-rsource "Kconfig.sched"
-rsource "Kconfig.semaphore"
-rsource "Kconfig.signal"
-rsource "Kconfig.spinlock"
-rsource "Kconfig.sync_io"
-rsource "Kconfig.timer"
-# zephyr-keep-sorted-stop
-
-menu "X/Open system interfaces"
-rsource "Kconfig.xsi"
-
-endmenu # "X/Open system interfaces"
diff --git a/lib/posix/options/Kconfig.aio b/lib/posix/options/Kconfig.aio
deleted file mode 100644
index 2536301d697..00000000000
--- a/lib/posix/options/Kconfig.aio
+++ /dev/null
@@ -1,9 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config POSIX_ASYNCHRONOUS_IO
-	bool "POSIX asynchronous I/O"
-	help
-	  Enable this option for asynchronous I/O. This option is present for conformance purposes
-	  only. All functions listed in <aio.h> return -1 and set errno to ENOSYS.
diff --git a/lib/posix/options/Kconfig.barrier b/lib/posix/options/Kconfig.barrier
deleted file mode 100644
index b349d037655..00000000000
--- a/lib/posix/options/Kconfig.barrier
+++ /dev/null
@@ -1,40 +0,0 @@
-# Copyright (c) 2017 Intel Corporation
-# Copyright (c) 2023 Meta
-# Copyright (c) 2024 Tenstorrent
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_BARRIERS
-	bool "POSIX barriers"
-	help
-	  Select 'y' here to enable POSIX barriers.
-
-	  For more information please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_BARRIERS
-
-config MAX_PTHREAD_BARRIER_COUNT
-	int "Maximum number of POSIX barriers"
-	default 5
-	help
-	  Maximum simultaneously active pthread_barrier_t in a POSIX application.
-
-	  Note: this is a non-standard option.
-
-config PTHREAD_CREATE_BARRIER
-	bool "Use a POSIX barrier to serialize pthread_create()"
-	help
-	  When running several SMP applications in parallel instances of Qemu,
-	  e.g. via twister, explicit serialization may be required between
-	  pthread_create() and zephyr_thread_wrapper() when spawning and joining
-	  many pthreads concurrently.
-
-	  On such systems, say Y here to introduce explicit serialization
-	  via pthread_barrier_wait().
-
-module = PTHREAD_BARRIER
-module-str = POSIX thread barriers
-source "subsys/logging/Kconfig.template.log_config"
-
-endif # POSIX_BARRIERS
diff --git a/lib/posix/options/Kconfig.clock_selection b/lib/posix/options/Kconfig.clock_selection
deleted file mode 100644
index 34b12ff8f23..00000000000
--- a/lib/posix/options/Kconfig.clock_selection
+++ /dev/null
@@ -1,13 +0,0 @@
-# Copyright (c) 2025 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config POSIX_CLOCK_SELECTION
-	bool "POSIX Clock Selection"
-	help
-	  Select 'y' here and Zephyr will provide an implementation of the POSIX_CLOCK_SELECTION Option
-	  Group, which includes the functions clock_nanosleep(), pthread_condattr_getclock(),
-	  pthread_condattr_setclock().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
diff --git a/lib/posix/options/Kconfig.device_io b/lib/posix/options/Kconfig.device_io
deleted file mode 100644
index 04862ff0c82..00000000000
--- a/lib/posix/options/Kconfig.device_io
+++ /dev/null
@@ -1,62 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menu "POSIX device I/O"
-
-config POSIX_DEVICE_IO
-	bool "POSIX device I/O"
-	select ZVFS
-	select ZVFS_POLL
-	select ZVFS_SELECT
-	help
-	  Select 'y' here and Zephyr will provide an implementation of the POSIX_DEVICE_IO Option
-	  Group such as FD_CLR(), FD_ISSET(), FD_SET(), FD_ZERO(), close(), fdopen(), fileno(), open(),
-	  poll(), pread(), pselect(), pwrite(), read(), select(), and write().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_DEVICE_IO
-
-# These options are intended to be used for compatibility with external POSIX
-# implementations such as those in Newlib or Picolibc.
-
-config POSIX_DEVICE_IO_ALIAS_CLOSE
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for close() as _close().
-
-config POSIX_DEVICE_IO_ALIAS_OPEN
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for open() as _open().
-
-config POSIX_DEVICE_IO_ALIAS_READ
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for read() as _read().
-
-config POSIX_DEVICE_IO_ALIAS_WRITE
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for write() as _write().
-
-endif # POSIX_DEVICE_IO
-
-# Allocate fd for stdin, stdout and stderr
-config ZVFS_OPEN_ADD_SIZE_POSIX
-	int "Amount of file descriptors used by Posix"
-	default 3
-
-config POSIX_OPEN_MAX
-	int
-	default ZVFS_OPEN_ADD_SIZE_POSIX
-	help
-	  The maximum number of files that a process can have open at one time. This option is not
-	  directly user-configurable but can be adjusted via CONFIG_ZVFS_OPEN_ADD_SIZE_POSIX.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html
-
-endmenu
diff --git a/lib/posix/options/Kconfig.fd_mgmt b/lib/posix/options/Kconfig.fd_mgmt
deleted file mode 100644
index a41bba869da..00000000000
--- a/lib/posix/options/Kconfig.fd_mgmt
+++ /dev/null
@@ -1,35 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_FD_MGMT
-	bool "POSIX file descriptor management"
-	help
-	  Select 'y' here and Zephyr will provide implementations for the POSIX_FD_MGMT Option Group.
-	  This includes support for dup(), dup2(), fcntl(), fseeko(), ftello(), ftruncate(),
-	  and lseek().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_FD_MGMT
-
-# These options are intended to be used for compatibility with external POSIX
-# implementations such as those in Newlib or Picolibc.
-
-config POSIX_FD_MGMT_ALIAS_FCNTL
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for fcntl() as _fcntl().
-
-config POSIX_FD_MGMT_ALIAS_FTRUNCATE
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for ftruncate() as _ftruncate().
-
-config POSIX_FD_MGMT_ALIAS_LSEEK
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for lseek() as _lseek().
-
-endif # POSIX_FD_MGMT
diff --git a/lib/posix/options/Kconfig.file_system_r b/lib/posix/options/Kconfig.file_system_r
deleted file mode 100644
index 571100c9c3e..00000000000
--- a/lib/posix/options/Kconfig.file_system_r
+++ /dev/null
@@ -1,14 +0,0 @@
-# Copyright (c) 2018 Intel Corporation
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config POSIX_FILE_SYSTEM_R
-	bool "Thread-Safe File System"
-	select FILE_SYSTEM
-	select FDTABLE
-	help
-	  Select 'y' here and Zephyr will provide an implementation of the POSIX_FILE_SYSTEM_R
-	  Option Group, consisting of readdir_r().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
diff --git a/lib/posix/options/Kconfig.fs b/lib/posix/options/Kconfig.fs
deleted file mode 100644
index 6cb3f4778c1..00000000000
--- a/lib/posix/options/Kconfig.fs
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (c) 2018 Intel Corporation
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_FILE_SYSTEM
-	bool "POSIX file system API support"
-	select FILE_SYSTEM
-	select FDTABLE
-	help
-	  This enables POSIX style file system related APIs.
-
-if POSIX_FILE_SYSTEM
-
-config POSIX_FILE_SYSTEM_ALIAS_FSTAT
-	bool
-	help
-	  When selected via Kconfig, Zephyr will provide an alias for fstat() as _fstat().
-
-endif # POSIX_FILE_SYSTEM
diff --git a/lib/posix/options/Kconfig.mem b/lib/posix/options/Kconfig.mem
deleted file mode 100644
index 346b5d363aa..00000000000
--- a/lib/posix/options/Kconfig.mem
+++ /dev/null
@@ -1,79 +0,0 @@
-# Copyright (c) 2024 BayLibre SAS
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menu "POSIX memory"
-
-config POSIX_PAGE_SIZE
-	hex
-	# TODO: something similar and arch-independent for MPUs
-	default MMU_PAGE_SIZE if MMU
-	default 0x40
-	help
-	  This option is not user-configurable.
-
-config POSIX_SHARED_MEMORY_OBJECTS
-	bool "POSIX shared memory objects"
-	select SYS_HASH_FUNC32
-	select SYS_HASH_FUNC32_DJB2
-	select FDTABLE
-	select POSIX_MAPPED_FILES
-	help
-	  Select 'y' here and Zephyr will provide implementations of shm_open() and shm_unlink().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799.orig/functions/V2_chap02.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-
-config POSIX_MAPPED_FILES
-	bool "POSIX memory-mapped files"
-	help
-	  Select 'y' here and Zephyr will provide support for mmap(), msync(), and munmap().
-
-	  Note: This feature depends on hardware MMU support. If the underlying platform does not
-	  support an MMU, then affected POSIX API functions may return -1 and set errno to ENOTSUP.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799.orig/functions/V2_chap02.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-
-if POSIX_MAPPED_FILES
-
-config POSIX_MEMLOCK
-	bool "POSIX memory locking"
-	help
-	  Select 'y' here and Zephyr will provide support for mlockall() and munlockall().
-
-	  Note: This feature depends on hardware MMU support as well as DEMAND_PAGING. If the
-	  underlying platform does not support an MMU or DEMAND_PAGING, then affected POSIX API
-	  functions will return -1 and set errno to ENOTSUP.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799.orig/functions/V2_chap02.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-
-config POSIX_MEMLOCK_RANGE
-	bool "POSIX range memory locking"
-	imply DEMAND_PAGING
-	help
-	  Select 'y' here and Zephyr will provide support for mlock() and munlock().
-
-	  Note: This feature depends on hardware MMU support. If the underlying platform does not
-	  support an MMU, then affected POSIX API functions will return -1 and set errno to ENOTSUP.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799.orig/functions/V2_chap02.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-
-endif
-
-config POSIX_MEMORY_PROTECTION
-	bool "POSIX memory protection"
-	help
-	  Select 'y' here and Zephyr will provide support for mprotect().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799.orig/functions/V2_chap02.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-
-endmenu
diff --git a/lib/posix/options/Kconfig.mqueue b/lib/posix/options/Kconfig.mqueue
deleted file mode 100644
index 83b3a218588..00000000000
--- a/lib/posix/options/Kconfig.mqueue
+++ /dev/null
@@ -1,41 +0,0 @@
-# Copyright (c) 2017 Intel Corporation
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_MESSAGE_PASSING
-	bool "POSIX message queue support"
-	help
-	  This enabled POSIX message queue related APIs.
-
-if POSIX_MESSAGE_PASSING
-
-config POSIX_MQ_OPEN_MAX
-	int "Maximum number of messages in a POSIX message queue"
-	default 16
-	help
-	  Mention maximum number of messages in message queue in POSIX compliant
-	  application.
-
-config POSIX_MQ_PRIO_MAX
-	int "Maximum number of POSIX message priorities"
-	default 32
-	help
-	  Maximum number of message priorities supported by the implementation.
-
-config MSG_SIZE_MAX
-	int "Maximum size of a POSIX message"
-	default 16
-	help
-	  Mention maximum size of message in bytes.
-
-config MQUEUE_NAMELEN_MAX
-	int "Maximum POSIX message queue name size"
-	default 16
-	range 2 $(UINT8_MAX)
-	help
-	  Mention size of message queue name in number of characters.
-
-config HEAP_MEM_POOL_ADD_SIZE_MQUEUE
-	def_int 1024
-
-endif
diff --git a/lib/posix/options/Kconfig.net b/lib/posix/options/Kconfig.net
deleted file mode 100644
index 88aecc04592..00000000000
--- a/lib/posix/options/Kconfig.net
+++ /dev/null
@@ -1,49 +0,0 @@
-# Copyright (c) 2024, Friedt Professional Engineering Services, Inc
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_NETWORKING
-	bool "POSIX Networking API"
-	depends on NETWORKING
-	select NET_HOSTNAME_ENABLE
-	select NET_HOSTNAME_DYNAMIC
-	select NET_INTERFACE_NAME
-	select NET_SOCKETPAIR
-	select NET_SOCKETS
-	help
-	  Enable this option to support the POSIX networking API. This includes
-	  support for BSD Sockets.
-
-	  For additional details, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_NETWORKING
-
-config POSIX_HOST_NAME_MAX
-	int
-	default NET_HOSTNAME_MAX_LEN
-	help
-	  The maximum length of a host name as defined by POSIX.
-
-	  For additional details, please see
-	  https://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html
-
-config POSIX_IPV6
-	bool "POSIX IPv6 support"
-	default y if NET_CONFIG_NEED_IPV6
-	help
-	  Enable this option to support the POSIX IPv6 API.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-
-config POSIX_RAW_SOCKETS
-	bool "POSIX RAW socket support"
-	select NET_SOCKETS_PACKET
-	help
-	  Enable this option to support the raw sockets.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/xrat/V4_xsh_chap02.html#tag_22_02_10_18
-
-endif # POSIX_NETWORKING
diff --git a/lib/posix/options/Kconfig.proc1 b/lib/posix/options/Kconfig.proc1
deleted file mode 100644
index 721db930e87..00000000000
--- a/lib/posix/options/Kconfig.proc1
+++ /dev/null
@@ -1,61 +0,0 @@
-# Copyright (c) 2023 Meta
-# Copyright (c) 2024 BayLibre SAS
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_SINGLE_PROCESS
-	bool "POSIX single process support"
-	# imply COMMON_LIBC_MALLOC # for env.c
-	help
-	  Select 'y' here to use confstr(), environ, errno, getenv(), setenv(), sysconf(), uname(),
-	  or unsetenv().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_SINGLE_PROCESS
-
-choice POSIX_SYSCONF_IMPL_CHOICE
-	default POSIX_SYSCONF_IMPL_FULL if CPP
-	default POSIX_SYSCONF_IMPL_MACRO if MINIMAL_LIBC
-	default POSIX_SYSCONF_IMPL_FULL
-	prompt "Sysconf implementation method"
-
-config POSIX_SYSCONF_IMPL_MACRO
-	bool "Macro"
-	help
-	  The sysconf() function is implemented compile-time constant via macros. This is the option
-	  with the least overhead. The downside is that sysconf() is not an addressable function.
-
-config POSIX_SYSCONF_IMPL_FULL
-	bool "Full"
-	help
-	  The sysconf() function is implemented as a large integer-integer array. The advantage if this
-	  option is that all sysconf() options can be queried and that the sysconf() symbol is
-	  addressable.
-
-endchoice
-
-config POSIX_UNAME_VERSION_LEN
-	int "uname version string length"
-	default 70
-	help
-	  Defines the maximum string length of uname version.
-
-config POSIX_UNAME_NODENAME_LEN
-	int "uname nodename string length"
-	default 6 if !NET_HOSTNAME_UNIQUE
-	default 22 if NET_HOSTNAME_UNIQUE
-	help
-	  Defines the maximum string length of nodename version.
-
-endif # POSIX_SINGLE_PROCESS
-
-if POSIX_SINGLE_PROCESS || XSI_SINGLE_PROCESS
-
-module = POSIX_ENV
-module-str = POSIX env logging
-source "subsys/logging/Kconfig.template.log_config"
-
-endif # POSIX_SINGLE_PROCESS || XSI_SINGLE_PROCESS
diff --git a/lib/posix/options/Kconfig.procN b/lib/posix/options/Kconfig.procN
deleted file mode 100644
index 4f05f3b18fa..00000000000
--- a/lib/posix/options/Kconfig.procN
+++ /dev/null
@@ -1,29 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_MULTI_PROCESS
-	bool "POSIX multi-process support"
-	select SCHED_THREAD_USAGE # times()
-	select THREAD_RUNTIME_STATS
-	help
-	  Support for multi-processing.
-
-	  Note: Currently Zephyr does not support multiple processes and therefore much of this option
-	  group is not implemented and is considered undefined behaviour.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_MULTI_PROCESS
-
-# These options are intended to be used for compatibility with external POSIX
-# implementations such as those in Newlib or Picolibc.
-
-config POSIX_MULTI_PROCESS_ALIAS_GETPID
-	bool
-	default y
-	help
-	  Select 'y' here and Zephyr will provide an alias for getpid() as _getpid().
-
-endif # POSIX_MULTI_PROCESS
diff --git a/lib/posix/options/Kconfig.pthread b/lib/posix/options/Kconfig.pthread
deleted file mode 100644
index c4563a56c04..00000000000
--- a/lib/posix/options/Kconfig.pthread
+++ /dev/null
@@ -1,204 +0,0 @@
-# Copyright (c) 2017 Intel Corporation
-# Copyright (c) 2023 Meta
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_THREADS
-	bool "POSIX thread support"
-	help
-	  Select 'y' here to enable POSIX threads, mutexes, condition variables, and
-	  thread-specific storage.
-
-	  This option makes the following functions available:
-	  pthread_atfork(), pthread_attr_destroy(), pthread_attr_getdetachstate(),
-	  pthread_attr_getschedparam(), pthread_attr_init(), pthread_attr_setdetachstate(),
-	  pthread_attr_setschedparam(), pthread_cancel(), pthread_cleanup_pop(),
-	  pthread_cleanup_push(), pthread_cond_broadcast(), pthread_cond_destroy(),
-	  pthread_cond_init(), pthread_cond_signal(), pthread_cond_timedwait(),
-	  pthread_cond_wait(), pthread_condattr_destroy(), pthread_condattr_init(),
-	  pthread_create(), pthread_detach(), pthread_equal(), pthread_exit(),
-	  pthread_getspecific(), pthread_join(), pthread_key_create(), pthread_key_delete(),
-	  pthread_kill(), pthread_mutex_destroy(), pthread_mutex_init(), pthread_mutex_lock(),
-	  pthread_mutex_timedlock(), pthread_mutex_trylock(), pthread_mutex_unlock(),
-	  pthread_mutexattr_destroy(), pthread_mutexattr_init(), pthread_once(), pthread_self(),
-	  pthread_setcancelstate(), pthread_setcanceltype(), pthread_setspecific(),
-	  pthread_sigmask(), pthread_testcancel(), and sched_yield().
-
-	  For more information please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_THREADS
-
-config HEAP_MEM_POOL_ADD_SIZE_POSIX_THREADS
-	def_int 256
-
-config POSIX_THREAD_THREADS_MAX
-	int "Maximum number of POSIX threads"
-	default 5
-	help
-	  Maximum simultaneously active threads in a POSIX application.
-
-	  For more information, see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html
-
-config MAX_PTHREAD_MUTEX_COUNT
-	int "Maximum number of POSIX mutexes"
-	default 5
-	help
-	  Maximum simultaneously active mutexes in a POSIX application.
-
-config MAX_PTHREAD_COND_COUNT
-	int "Maximum number of POSIX condition variables"
-	default 5
-	help
-	  Maximum simultaneously active condition variables in a POSIX application.
-
-config POSIX_THREAD_KEYS_MAX
-	int "Maximum number of POSIX thread-specific-storage keys"
-	default 5
-	help
-	  Maximum simultaneously active thread-specific-storage keys in a POSIX application.
-
-	  For more information, see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html
-
-config PTHREAD_RECYCLER_DELAY_MS
-	int "Delay for reclaiming dynamic pthread stacks (ms)"
-	default 100
-	help
-	  Prior to a POSIX thread terminating via k_thread_abort(), scheduled
-	  work is added to the system workqueue (SWQ) so that any resources
-	  allocated by the thread (e.g. thread stack from a pool or the heap)
-	  can be released back to the system. Because resources are also freed
-	  on calls to pthread_create() there is no need to worry about resource
-	  starvation.
-
-	  This option sets the number of milliseconds by which to defer
-	  scheduled work.
-
-	  Note: this option should be considered temporary and will likely be
-	  removed once a more synchronous solution is available.
-
-config POSIX_THREAD_ATTR_STACKADDR
-	bool "Support getting and setting POSIX thread stack addresses"
-	help
-	  Enable this option to use pthread_attr_getstackaddr() and
-	  pthread_attr_setstackaddr().
-
-	  This option was removed in IEEE 1003.1-2017 in favour of
-	  pthread_attr_getstack() and pthread_attr_setstack().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/009696799/functions/pthread_attr_getstackaddr.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap03.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_08
-
-config POSIX_THREAD_ATTR_STACKSIZE
-	bool "Support getting and setting POSIX thread stack sizes"
-	help
-	  Enable this option to use pthread_attr_getstacksize() or
-	  pthread_attr_setstacksize().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/009696699/functions/pthread_attr_getstacksize.html
-
-config POSIX_THREADS_EXT
-	bool "Extended POSIX thread support"
-	help
-	  Enable this option to use pthread_attr_getguardsize(), pthread_attr_setguardsize(),
-	  pthread_mutexattr_gettype(), or pthread_mutexattr_settype().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-config POSIX_THREAD_PRIORITY_SCHEDULING
-	bool "Run POSIX threads with different priorities and schedulers"
-	help
-	  Enabling this option allows the application to configure different priorities and
-	  scheduling algorithms for different threads via functions such as pthread_setschedparam()
-	  and pthread_setschedprio(). This is required for Realtime Threads and Advanced Realtime
-	  Threads.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_06
-	  https://man7.org/linux/man-pages/man7/posixoptions.7.html
-
-config POSIX_PTHREAD_ATTR_STACKSIZE_BITS
-	int "Significant bits for pthread_attr_t stacksize"
-	range 8 31
-	default 23
-	help
-	  This value plays a part in determining the maximum supported
-	  pthread_attr_t stacksize. Valid stacksizes are in the range
-	  [1, N], where N = 1 << M, and M is this configuration value.
-
-config POSIX_PTHREAD_ATTR_GUARDSIZE_BITS
-	int "Significant bits for pthread_attr_t guardsize"
-	range 1 31
-	default 9
-	help
-	  This value plays a part in determining the maximum supported
-	  pthread_attr_t guardsize. Valid guardsizes are in the range
-	  [0, N-1], where N = 1 << M, and M is this configuration value.
-
-	  Actual guardsize values may be rounded-up.
-
-config POSIX_PTHREAD_ATTR_GUARDSIZE_DEFAULT
-	int "Default size of stack guard area"
-	default 0
-	help
-	  This is the default amount of space to reserve at the overflow end of a
-	  pthread stack. Since Zephyr already supports both software-based stack
-	  protection (canaries) and hardware-based stack protection (MMU or MPU),
-	  this is set to 0 by default. However, a conforming application would be
-	  required to set this to PAGESIZE. Eventually, this option might
-	  facilitate a more dynamic approach to guard areas (via software or
-	  hardware) but for now it simply increases the size of thread stacks.
-
-config POSIX_THREAD_PRIO_INHERIT
-	bool "POSIX mutex priority inheritance"
-	help
-	  Select 'y' here to enable POSIX mutex priority inheritance.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutexattr_getprotocol.html
-
-config POSIX_THREAD_PRIO_PROTECT
-	bool "POSIX mutex priority protection"
-	help
-	  Select 'y' here to enable POSIX mutex priority protection.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutexattr_getprotocol.html
-
-config POSIX_THREAD_SAFE_FUNCTIONS
-	bool "POSIX thread-safe functions"
-	select POSIX_FILE_SYSTEM_R
-	select POSIX_C_LANG_SUPPORT_R
-	help
-	  Select 'y' here to enable POSIX thread-safe functions including asctime_r(), ctime_r(),
-	  flockfile(), ftrylockfile(), funlockfile(), getc_unlocked(), getchar_unlocked(),
-	  getgrgid_r(), getgrnam_r(), getpwnam_r(), getpwuid_r(), gmtime_r(), localtime_r(),
-	  putc_unlocked(), putchar_unlocked(), rand_r(), readdir_r(), strerror_r(), and strtok_r().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap02.html#tag_22_02_09_07
-
-module = PTHREAD
-module-str = POSIX thread
-source "subsys/logging/Kconfig.template.log_config"
-
-module = PTHREAD_MUTEX
-module-str = POSIX mutex
-source "subsys/logging/Kconfig.template.log_config"
-
-module = PTHREAD_COND
-module-str = POSIX condition variable
-source "subsys/logging/Kconfig.template.log_config"
-
-module = PTHREAD_KEY
-module-str = POSIX thread-specific data
-source "subsys/logging/Kconfig.template.log_config"
-
-endif # POSIX_THREADS
diff --git a/lib/posix/options/Kconfig.rwlock b/lib/posix/options/Kconfig.rwlock
deleted file mode 100644
index 569cef39e76..00000000000
--- a/lib/posix/options/Kconfig.rwlock
+++ /dev/null
@@ -1,34 +0,0 @@
-# Copyright (c) 2024 Meta
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_RW_LOCKS
-	bool "POSIX reader-writer locks"
-	help
-	  Select 'y' here to enable POSIX reader-writer locks.
-
-	  For more information please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_RW_LOCKS
-
-config MAX_PTHREAD_RWLOCK_COUNT
-	int "Maximum number of POSIX reader-writer locks"
-	default 5
-	help
-	  Maximum simultaneously active reader-writer locks in a POSIX application.
-
-	  Note: this is a non-standard option.
-
-module = PTHREAD_RWLOCK
-module-str = POSIX Reader-Writer Locks
-source "subsys/logging/Kconfig.template.log_config"
-
-endif # POSIX_RW_LOCKS
-
-config POSIX_READER_WRITER_LOCKS
-	bool "POSIX reader-writer locks [DEPRECATED]"
-	select DEPRECATED
-	select POSIX_RW_LOCKS
-	help
-	  This option is deprecated. Use POSIX_RW_LOCKS instead.
diff --git a/lib/posix/options/Kconfig.sched b/lib/posix/options/Kconfig.sched
deleted file mode 100644
index 08ca62787b1..00000000000
--- a/lib/posix/options/Kconfig.sched
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (c) 2023 Intel Corporation
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menu "POSIX scheduler options"
-
-config POSIX_PRIORITY_SCHEDULING
-	bool "POSIX priority-based process scheduling"
-	help
-	  This enables POSIX scheduling APIs (_POSIX_PRIORITY_SCHEDULING).
-
-	  Since Zephyr does not yet support processes, most of this behaviour is undefined, except for
-	  use of sched_get_priority_min() and sched_get_priority_max().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_get_priority_max.html
-
-endmenu
diff --git a/lib/posix/options/Kconfig.semaphore b/lib/posix/options/Kconfig.semaphore
deleted file mode 100644
index b2640d97041..00000000000
--- a/lib/posix/options/Kconfig.semaphore
+++ /dev/null
@@ -1,39 +0,0 @@
-# Copyright (c) 2018 Intel Corporation
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_SEMAPHORES
-	bool "POSIX semaphore support"
-	help
-	  Enable this option for POSIX semaphore support.
-
-if POSIX_SEMAPHORES
-
-config POSIX_SEM_VALUE_MAX
-	int "Maximum semaphore value"
-	default $(INT16_MAX)
-	range 1 $(INT16_MAX)
-	help
-	  Maximum semaphore count in POSIX compliant Application.
-
-config POSIX_SEM_NSEMS_MAX
-	int "Maximum number of semaphores"
-	default 256
-	help
-	  Maximum number of semaphores in a POSIX application.
-
-	  Note: currently, in Zephyr, this only limits the number of named semaphores (i.e. those
-	  created via sem_open()).
-
-config POSIX_SEM_NAMELEN_MAX
-	int "Maximum semaphore name length"
-	default 16
-	range 2 $(UINT8_MAX)
-	help
-	  Maximum length of name for a named semaphore.
-	  The max value of 255 corresponds to {NAME_MAX}.
-
-config HEAP_MEM_POOL_ADD_SIZE_POSIX_SEMAPHORES
-	def_int 256
-
-endif # POSIX_SEMAPHORES
diff --git a/lib/posix/options/Kconfig.signal b/lib/posix/options/Kconfig.signal
deleted file mode 100644
index e844ee5eaab..00000000000
--- a/lib/posix/options/Kconfig.signal
+++ /dev/null
@@ -1,46 +0,0 @@
-# Copyright (c) 2023 Meta
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menu "POSIX signals"
-
-config POSIX_REALTIME_SIGNALS
-	bool "POSIX realtime signals"
-	help
-	  Enable support for POSIX realtime signals.
-
-if POSIX_REALTIME_SIGNALS
-
-config POSIX_RTSIG_MAX
-	int "Maximum number of realtime signals"
-	default 8
-	help
-	  Define the maximum number of realtime signals (RTSIG_MAX).
-	  The range of realtime signals is [SIGRTMIN .. (SIGRTMIN+RTSIG_MAX)]
-
-endif # POSIX_REALTIME_SIGNALS
-
-config POSIX_SIGNALS
-	bool "POSIX signals"
-	select POSIX_MULTI_PROCESS
-	help
-	  Enable support for POSIX signals.
-
-if POSIX_SIGNALS
-
-config POSIX_SIGNAL_STRING_DESC
-	bool "Use full description for the strsignal API"
-	default y
-	help
-	  Use full description for the strsignal API.
-	  Will use 256 bytes of ROM.
-
-# These options are intended to be used for compatibility with external POSIX
-# implementations such as those in Newlib or Picolibc.
-
-config POSIX_SIGNALS_ALIAS_KILL
-	bool
-
-endif
-
-endmenu # "Signal support"
diff --git a/lib/posix/options/Kconfig.spinlock b/lib/posix/options/Kconfig.spinlock
deleted file mode 100644
index 312a432ce38..00000000000
--- a/lib/posix/options/Kconfig.spinlock
+++ /dev/null
@@ -1,27 +0,0 @@
-# Copyright (c) 2023 Meta
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_SPIN_LOCKS
-	bool "POSIX spin locks"
-	help
-	  Select 'y' here to enable POSIX spin locks.
-
-	  For more information please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_SPIN_LOCKS
-
-config MAX_PTHREAD_SPINLOCK_COUNT
-	int "Maximum number of POSIX spin locks"
-	default 5
-	help
-	  Maximum simultaneously active spin locks in a POSIX application.
-
-	  Note: this is a non-standard option.
-
-module = PTHREAD_SPINLOCK
-module-str = POSIX Spin Locks
-source "subsys/logging/Kconfig.template.log_config"
-
-endif # POSIX_SPIN_LOCKS
diff --git a/lib/posix/options/Kconfig.sync_io b/lib/posix/options/Kconfig.sync_io
deleted file mode 100644
index 4575ff06020..00000000000
--- a/lib/posix/options/Kconfig.sync_io
+++ /dev/null
@@ -1,39 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menu "POSIX synchronized I/O"
-
-config POSIX_FSYNC
-	bool "Support for fsync()"
-	help
-	  Select 'y' here and Zephyr will provide an implementation of fsync().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html
-
-
-config POSIX_SYNCHRONIZED_IO
-	bool "POSIX synchronized I/O"
-	select POSIX_FSYNC
-	help
-	  Select 'y' here and Zephyr will provide an implementation of fdatasync(), fsync(),
-	  and msync().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/msync.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html
-
-if POSIX_FSYNC
-
-# These options are intended to be used for compatibility with external POSIX
-# implementations such as those in Newlib or Picolibc.
-
-config POSIX_FILE_SYSTEM_ALIAS_FSYNC
-	bool
-	help
-	  Select 'y' here and Zephyr will provide an alias for fsync() as _fsync().
-
-endif # POSIX_FSYNC
-
-endmenu
diff --git a/lib/posix/options/Kconfig.timer b/lib/posix/options/Kconfig.timer
deleted file mode 100644
index 67c6f734c49..00000000000
--- a/lib/posix/options/Kconfig.timer
+++ /dev/null
@@ -1,100 +0,0 @@
-# Copyright (c) 2018 Intel Corporation
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig POSIX_TIMERS
-	bool "POSIX timers, clocks, and sleep functions"
-	help
-	  Select 'y' here and Zephyr will provide implementations of clock_getres(), clock_gettime(),
-	  clock_settime(), nanosleep(), timer_create(), timer_delete(), timer_getoverrun(),
-	  timer_settime(), and timer_gettime().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-if POSIX_TIMERS
-
-config POSIX_THREAD_CPUTIME
-	bool "POSIX per-thread CPU-time clocks"
-	help
-	  This enables CLOCK_THREAD_CPUTIME_ID.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_118
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_08_05_04
-
-config POSIX_MONOTONIC_CLOCK
-	bool "POSIX Monotonic clock support"
-	# TODO: move this to the XSI_ADVANCED_REALTIME option when it is created
-	default y
-	help
-	  This enables CLOCK_MONOTONIC.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_08_05_03
-
-config POSIX_CPUTIME
-	bool "POSIX per-process CPU-time clocks"
-	# TODO: move this to the XSI_ADVANCED_REALTIME option when it is created
-	default y
-	help
-	  This enables CLOCK_PROCESS_CPUTIME_ID.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_118
-	  https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_08_05_04
-
-config POSIX_CLOCK_SELECTION
-	bool "POSIX Clock selection"
-	help
-	  This enables POSIX clock selection.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html#tag_24_03_04
-
-config POSIX_DELAYTIMER_MAX
-	int "Maximum count returned my timer_getoverrun() in POSIX application"
-	default 32
-	help
-	  This controls the maximum number of times a timer can overrun before
-	  timer_getoverrun() in POSIX compliant application.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html
-
-config POSIX_TIMER_MAX
-	int "Maximum number of POSIX timers per process"
-	default 32
-	help
-	  Maximum simultaneously active timer_t in a POSIX application.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html
-
-config POSIX_TIMEOUTS
-	bool "Support timeouts for some blocking POSIX services"
-	help
-	  Enable mandatory timeouts for some blocking operations.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_port.html
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap02.html
-
-config TIMER_CREATE_WAIT
-	int "Time to wait for timer availability (in msec) in POSIX application"
-	default 100
-	range 0 1000
-	help
-	  This controls how long to wait for resources to come available to create
-	  a new timer in POSIX compliant application
-
-module = TIMER
-module-str = POSIX Timers
-source "subsys/logging/Kconfig.template.log_config"
-
-endif # POSIX_TIMERS
diff --git a/lib/posix/options/Kconfig.xsi b/lib/posix/options/Kconfig.xsi
deleted file mode 100644
index 72105b5565a..00000000000
--- a/lib/posix/options/Kconfig.xsi
+++ /dev/null
@@ -1,24 +0,0 @@
-# Copyright (c) 2025 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-menuconfig XSI
-	bool "X/Open System Interfaces (XSI)"
-	select POSIX_FSYNC
-	select POSIX_THREAD_ATTR_STACKADDR
-	select POSIX_THREAD_ATTR_STACKSIZE
-	help
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_04_01
-
-if XSI
-
-# zephyr-keep-sorted-start
-rsource "Kconfig.xsi_realtime"
-rsource "Kconfig.xsi_single_process"
-rsource "Kconfig.xsi_streams"
-rsource "Kconfig.xsi_system_logging"
-rsource "Kconfig.xsi_threads_ext"
-# zephyr-keep-sorted-stop
-
-endif # XSI
diff --git a/lib/posix/options/Kconfig.xsi_realtime b/lib/posix/options/Kconfig.xsi_realtime
deleted file mode 100644
index 4c232b77a1d..00000000000
--- a/lib/posix/options/Kconfig.xsi_realtime
+++ /dev/null
@@ -1,28 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config XSI_REALTIME
-	bool "X/Open realtime"
-	select POSIX_FSYNC
-	select POSIX_MEMLOCK
-	select POSIX_MEMLOCK_RANGE
-	select POSIX_MESSAGE_PASSING
-	# Not yet implemented, but optional
-	# imply POSIX_PRIORITIZED_IO
-	select POSIX_PRIORITY_SCHEDULING
-	select POSIX_SHARED_MEMORY_OBJECTS
-	select POSIX_SYNCHRONIZED_IO
-	help
-	  Select 'y' here and the following functions will be provided:
-
-	  fsync(), mlockall(), munlockall(), mlock(), munlock(), mq_close(), mq_getattr(), mq_notify(),
-	  mq_open(), mq_receive(), mq_send(), mq_setattr(), mq_unlink(), sched_get_priority_max(),
-	  sched_get_priority_min(), sched_getparam(), sched_getscheduler(), sched_rr_get_interval(),
-	  sched_setparam(), sched_setscheduler(), sched_yield(), mmap(), munmap(), shm_open(),
-	  shm_unlink()
-
-	  The functions fsync(), fdatasync(), and open() will provide synchronized I/O capability.
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html
diff --git a/lib/posix/options/Kconfig.xsi_single_process b/lib/posix/options/Kconfig.xsi_single_process
deleted file mode 100644
index 9ef3d3a6dac..00000000000
--- a/lib/posix/options/Kconfig.xsi_single_process
+++ /dev/null
@@ -1,17 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config XSI_SINGLE_PROCESS
-	bool "X/Open single process"
-	select HWINFO
-	help
-	  Select 'y' here and Zephyr will provide implementations of
-	  gethostid(), gettimeofday(), and putenv().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
-
-module = XSI_SINGLE_PROCESS
-module-str = XSI Single Process
-source "subsys/logging/Kconfig.template.log_config"
diff --git a/lib/posix/options/Kconfig.xsi_streams b/lib/posix/options/Kconfig.xsi_streams
deleted file mode 100644
index 06088d48455..00000000000
--- a/lib/posix/options/Kconfig.xsi_streams
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config XSI_STREAMS
-	bool "X/Open streams"
-	help
-	  This option provides support for the X/Open Streams interface, including functions such as
-	  fattach(), fdetach(), getmsg(), getpmsg(), putmsg(), and putpmsg().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_05_09
-
-config XOPEN_STREAMS
-	bool "X/Open Streams [DEPRECATED]"
-	select XSI_STREAMS
-	select DEPRECATED
-	help
-	  This option is deprecated. Please use XSI_STREAMS instead.
diff --git a/lib/posix/options/Kconfig.xsi_system_logging b/lib/posix/options/Kconfig.xsi_system_logging
deleted file mode 100644
index c7d9186bd9b..00000000000
--- a/lib/posix/options/Kconfig.xsi_system_logging
+++ /dev/null
@@ -1,12 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config XSI_SYSTEM_LOGGING
-	bool "X/Open system logging"
-	help
-	  This option provides support for closelog(), openlog(), syslog(),
-	  setlogmask(), and vsyslog().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
diff --git a/lib/posix/options/Kconfig.xsi_threads_ext b/lib/posix/options/Kconfig.xsi_threads_ext
deleted file mode 100644
index b990ff46309..00000000000
--- a/lib/posix/options/Kconfig.xsi_threads_ext
+++ /dev/null
@@ -1,12 +0,0 @@
-# Copyright (c) 2024 Tenstorrent AI ULC
-#
-# SPDX-License-Identifier: Apache-2.0
-
-config XSI_THREADS_EXT
-	bool "X/Open threads extensions"
-	help
-	  This option provides support for pthread_attr_getstack(), pthread_attr_setstack(),
-	  pthread_getconcurrency(), and pthread_setconcurrency().
-
-	  For more information, please see
-	  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html
diff --git a/lib/posix/options/aio.c b/lib/posix/options/aio.c
deleted file mode 100644
index f0a9e55ab15..00000000000
--- a/lib/posix/options/aio.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright 2024 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <aio.h>
-#include <errno.h>
-
-int aio_cancel(int fildes, struct aiocb *aiocbp)
-{
-	ARG_UNUSED(fildes);
-	ARG_UNUSED(aiocbp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int aio_error(const struct aiocb *aiocbp)
-{
-	ARG_UNUSED(aiocbp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int aio_fsync(int fildes, struct aiocb *aiocbp)
-{
-	ARG_UNUSED(fildes);
-	ARG_UNUSED(aiocbp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int aio_read(struct aiocb *aiocbp)
-{
-	ARG_UNUSED(aiocbp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-ssize_t aio_return(struct aiocb *aiocbp)
-{
-	ARG_UNUSED(aiocbp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int aio_suspend(const struct aiocb *const list[], int nent, const struct timespec *timeout)
-{
-	ARG_UNUSED(list);
-	ARG_UNUSED(nent);
-	ARG_UNUSED(timeout);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int aio_write(struct aiocb *aiocbp)
-{
-	ARG_UNUSED(aiocbp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int lio_listio(int mode, struct aiocb *const ZRESTRICT list[], int nent,
-	       struct sigevent *ZRESTRICT sig)
-{
-	ARG_UNUSED(mode);
-	ARG_UNUSED(list);
-	ARG_UNUSED(nent);
-	ARG_UNUSED(sig);
-
-	errno = ENOSYS;
-	return -1;
-}
diff --git a/lib/posix/options/barrier.c b/lib/posix/options/barrier.c
deleted file mode 100644
index 0525a371bb3..00000000000
--- a/lib/posix/options/barrier.c
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Copyright (c) 2017 Intel Corporation
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_internal.h"
-
-#include <zephyr/init.h>
-#include <zephyr/kernel.h>
-#include <pthread.h>
-#include <zephyr/sys/bitarray.h>
-
-struct posix_barrier {
-	struct k_mutex mutex;
-	struct k_condvar cond;
-	uint32_t max;
-	uint32_t count;
-};
-
-struct posix_barrierattr {
-	uint32_t pshared;
-};
-
-__pinned_bss
-static struct posix_barrier posix_barrier_pool[CONFIG_MAX_PTHREAD_BARRIER_COUNT];
-
-SYS_BITARRAY_DEFINE_STATIC(posix_barrier_bitarray, CONFIG_MAX_PTHREAD_BARRIER_COUNT);
-
-/*
- * We reserve the MSB to mark a pthread_barrier_t as initialized (from the
- * perspective of the application). With a linear space, this means that
- * the theoretical pthread_barrier_t range is [0,2147483647].
- */
-BUILD_ASSERT(CONFIG_MAX_PTHREAD_BARRIER_COUNT < PTHREAD_OBJ_MASK_INIT,
-	     "CONFIG_MAX_PTHREAD_BARRIER_COUNT is too high");
-
-static inline size_t posix_barrier_to_offset(struct posix_barrier *bar)
-{
-	return bar - posix_barrier_pool;
-}
-
-static inline size_t to_posix_barrier_idx(pthread_barrier_t b)
-{
-	return mark_pthread_obj_uninitialized(b);
-}
-
-struct posix_barrier *get_posix_barrier(pthread_barrier_t b)
-{
-	int actually_initialized;
-	size_t bit = to_posix_barrier_idx(b);
-
-	/* if the provided barrier does not claim to be initialized, its invalid */
-	if (!is_pthread_obj_initialized(b)) {
-		return NULL;
-	}
-
-	/* Mask off the MSB to get the actual bit index */
-	if (sys_bitarray_test_bit(&posix_barrier_bitarray, bit, &actually_initialized) < 0) {
-		return NULL;
-	}
-
-	if (actually_initialized == 0) {
-		/* The barrier claims to be initialized but is actually not */
-		return NULL;
-	}
-
-	return &posix_barrier_pool[bit];
-}
-
-int pthread_barrier_wait(pthread_barrier_t *b)
-{
-	int ret;
-	int err;
-	pthread_barrier_t bb = *b;
-	struct posix_barrier *bar;
-
-	bar = get_posix_barrier(bb);
-	if (bar == NULL) {
-		return EINVAL;
-	}
-
-	err = k_mutex_lock(&bar->mutex, K_FOREVER);
-	__ASSERT_NO_MSG(err == 0);
-
-	++bar->count;
-
-	if (bar->count == bar->max) {
-		bar->count = 0;
-		ret = PTHREAD_BARRIER_SERIAL_THREAD;
-
-		goto unlock;
-	}
-
-	while (bar->count != 0) {
-		err = k_condvar_wait(&bar->cond, &bar->mutex, K_FOREVER);
-		__ASSERT_NO_MSG(err == 0);
-		/* Note: count is reset to zero by the serialized thread */
-	}
-
-	ret = 0;
-
-unlock:
-	err = k_condvar_signal(&bar->cond);
-	__ASSERT_NO_MSG(err == 0);
-	err = k_mutex_unlock(&bar->mutex);
-	__ASSERT_NO_MSG(err == 0);
-
-	return ret;
-}
-
-int pthread_barrier_init(pthread_barrier_t *b, const pthread_barrierattr_t *attr,
-			 unsigned int count)
-{
-	size_t bit;
-	struct posix_barrier *bar;
-
-	if (count == 0) {
-		return EINVAL;
-	}
-
-	if (sys_bitarray_alloc(&posix_barrier_bitarray, 1, &bit) < 0) {
-		return ENOMEM;
-	}
-
-	bar = &posix_barrier_pool[bit];
-	bar->max = count;
-	bar->count = 0;
-
-	*b = mark_pthread_obj_initialized(bit);
-
-	return 0;
-}
-
-int pthread_barrier_destroy(pthread_barrier_t *b)
-{
-	int err;
-	size_t bit;
-	struct posix_barrier *bar;
-
-	bar = get_posix_barrier(*b);
-	if (bar == NULL) {
-		return EINVAL;
-	}
-
-	err = k_mutex_lock(&bar->mutex, K_FOREVER);
-	if (err < 0) {
-		return -err;
-	}
-	__ASSERT_NO_MSG(err == 0);
-
-	/* An implementation may use this function to set barrier to an invalid value */
-	bar->max = 0;
-	bar->count = 0;
-
-	bit = posix_barrier_to_offset(bar);
-	err = sys_bitarray_free(&posix_barrier_bitarray, 1, bit);
-	__ASSERT_NO_MSG(err == 0);
-
-	err = k_condvar_broadcast(&bar->cond);
-	__ASSERT_NO_MSG(err == 0);
-
-	err = k_mutex_unlock(&bar->mutex);
-	__ASSERT_NO_MSG(err == 0);
-
-	return 0;
-}
-
-int pthread_barrierattr_init(pthread_barrierattr_t *attr)
-{
-	__ASSERT_NO_MSG(attr != NULL);
-	struct posix_barrierattr *_attr = (struct posix_barrierattr *)attr;
-
-#if defined(_POSIX_THREAD_PROCESS_SHARED)
-	_attr->pshared = PTHREAD_PROCESS_PRIVATE;
-#endif
-
-	return 0;
-}
-
-#if defined(_POSIX_THREAD_PROCESS_SHARED)
-int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr, int pshared)
-{
-	__ASSERT_NO_MSG(attr != NULL);
-	struct posix_barrierattr *_attr = (struct posix_barrierattr *)attr;
-
-	if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED) {
-		return -EINVAL;
-	}
-
-	_attr->pshared = pshared;
-	return 0;
-}
-
-int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict attr,
-				   int *restrict pshared)
-{
-	__ASSERT_NO_MSG(attr != NULL);
-	const struct posix_barrierattr *_attr = (const struct posix_barrierattr *)attr;
-
-	*pshared = _attr->pshared;
-
-	return 0;
-}
-#endif
-
-int pthread_barrierattr_destroy(pthread_barrierattr_t *attr)
-{
-	ARG_UNUSED(attr);
-
-	return 0;
-}
-
-__boot_func
-static int pthread_barrier_pool_init(void)
-{
-	int err;
-	size_t i;
-
-	for (i = 0; i < CONFIG_MAX_PTHREAD_BARRIER_COUNT; ++i) {
-		err = k_mutex_init(&posix_barrier_pool[i].mutex);
-		__ASSERT_NO_MSG(err == 0);
-		err = k_condvar_init(&posix_barrier_pool[i].cond);
-		__ASSERT_NO_MSG(err == 0);
-	}
-
-	return 0;
-}
-SYS_INIT(pthread_barrier_pool_init, PRE_KERNEL_1, 0);
diff --git a/lib/posix/options/clock.c b/lib/posix/options/clock.c
deleted file mode 100644
index 2e8b8fdca5e..00000000000
--- a/lib/posix/options/clock.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2018 Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-
-#include <errno.h>
-#include <time.h>
-
-#include <zephyr/kernel.h>
-#include <sys/time.h>
-#include <unistd.h>
-#include <zephyr/sys/clock.h>
-
-int clock_gettime(clockid_t clock_id, struct timespec *ts)
-{
-	int ret;
-
-	ret = sys_clock_gettime(sys_clock_from_clockid((int)clock_id), ts);
-	if (ret < 0) {
-		errno = -ret;
-		return -1;
-	}
-
-	return 0;
-}
-
-int clock_getres(clockid_t clock_id, struct timespec *res)
-{
-	BUILD_ASSERT(CONFIG_SYS_CLOCK_TICKS_PER_SEC > 0 &&
-			     CONFIG_SYS_CLOCK_TICKS_PER_SEC <= NSEC_PER_SEC,
-		     "CONFIG_SYS_CLOCK_TICKS_PER_SEC must be > 0 and <= NSEC_PER_SEC");
-
-	if (!(clock_id == CLOCK_MONOTONIC || clock_id == CLOCK_REALTIME ||
-	      clock_id == CLOCK_PROCESS_CPUTIME_ID)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (res != NULL) {
-		*res = (struct timespec){
-			.tv_sec = 0,
-			.tv_nsec = NSEC_PER_SEC / CONFIG_SYS_CLOCK_TICKS_PER_SEC,
-		};
-	}
-
-	return 0;
-}
-
-/**
- * @brief Set the time of the specified clock.
- *
- * See IEEE 1003.1.
- *
- * Note that only the `CLOCK_REALTIME` clock can be set using this
- * call.
- */
-int clock_settime(clockid_t clock_id, const struct timespec *tp)
-{
-	int ret;
-
-	ret = sys_clock_settime(sys_clock_from_clockid((int)clock_id), tp);
-	if (ret < 0) {
-		errno = -ret;
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
- * Note: usleep() was removed in Issue 7.
- *
- * It is kept here for compatibility purposes.
- *
- * For more information, please see
- * https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap01.html
- * https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap03.html
- */
-int usleep(useconds_t useconds)
-{
-	int32_t rem;
-
-	if (useconds >= USEC_PER_SEC) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	rem = k_usleep(useconds);
-	__ASSERT_NO_MSG(rem >= 0);
-	if (rem > 0) {
-		/* sleep was interrupted by a call to k_wakeup() */
-		errno = EINTR;
-		return -1;
-	}
-
-	return 0;
-}
-
-int nanosleep(const struct timespec *rqtp, struct timespec *rmtp)
-{
-	int ret;
-
-	if (rqtp == NULL) {
-		errno = EFAULT;
-		return -1;
-	}
-
-	ret = sys_clock_nanosleep(SYS_CLOCK_REALTIME, 0, rqtp, rmtp);
-	if (ret < 0) {
-		errno = -ret;
-		return -1;
-	}
-
-	return 0;
-}
-
-int clock_getcpuclockid(pid_t pid, clockid_t *clock_id)
-{
-	/* We don't allow any process ID but our own.  */
-	if (pid != 0) {
-		return EPERM;
-	}
-
-#ifdef CONFIG_POSIX_MULTI_PROCESS
-	if (pid != getpid()) {
-		return EPERM;
-	}
-#endif
-
-	*clock_id = CLOCK_PROCESS_CPUTIME_ID;
-
-	return 0;
-}
diff --git a/lib/posix/options/clock_selection.c b/lib/posix/options/clock_selection.c
deleted file mode 100644
index 67e5a89eacc..00000000000
--- a/lib/posix/options/clock_selection.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2023 Meta
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-#include "posix_internal.h"
-
-#include <stddef.h>
-#include <time.h>
-#include <errno.h>
-
-#include <zephyr/sys/clock.h>
-#include <zephyr/toolchain.h>
-
-int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp,
-		    struct timespec *rmtp)
-{
-	int ret;
-
-	if (rqtp == NULL) {
-		errno = EFAULT;
-		return -1;
-	}
-
-	ret = sys_clock_nanosleep(sys_clock_from_clockid((int)clock_id), flags, rqtp, rmtp);
-	if (ret < 0) {
-		errno = -ret;
-		return -1;
-	}
-
-	return 0;
-}
-
-int pthread_condattr_getclock(const pthread_condattr_t *ZRESTRICT att,
-			      clockid_t *ZRESTRICT clock_id)
-{
-	struct posix_condattr *const attr = (struct posix_condattr *)att;
-
-	if ((attr == NULL) || !attr->initialized) {
-		return EINVAL;
-	}
-
-	*clock_id = attr->clock;
-
-	return 0;
-}
-
-int pthread_condattr_setclock(pthread_condattr_t *att, clockid_t clock_id)
-{
-	struct posix_condattr *const attr = (struct posix_condattr *)att;
-
-	if (clock_id != CLOCK_REALTIME && clock_id != CLOCK_MONOTONIC) {
-		return -EINVAL;
-	}
-
-	if ((attr == NULL) || !attr->initialized) {
-		return EINVAL;
-	}
-
-	attr->clock = clock_id;
-
-	return 0;
-}
diff --git a/lib/posix/options/cond.c b/lib/posix/options/cond.c
deleted file mode 100644
index b508d93e880..00000000000
--- a/lib/posix/options/cond.c
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * Copyright (c) 2017 Intel Corporation
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-#include "posix_internal.h"
-
-#include <zephyr/init.h>
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <pthread.h>
-#include <zephyr/sys/bitarray.h>
-
-struct pthread_condattr {
-	clockid_t clock;
-};
-BUILD_ASSERT(sizeof(pthread_condattr_t) >= sizeof(struct pthread_condattr));
-
-LOG_MODULE_REGISTER(pthread_cond, CONFIG_PTHREAD_COND_LOG_LEVEL);
-
-static __pinned_bss struct posix_cond posix_cond_pool[CONFIG_MAX_PTHREAD_COND_COUNT];
-
-SYS_BITARRAY_DEFINE_STATIC(posix_cond_bitarray, CONFIG_MAX_PTHREAD_COND_COUNT);
-
-BUILD_ASSERT(sizeof(struct posix_condattr) <= sizeof(pthread_condattr_t),
-	     "posix_condattr is too large");
-
-/*
- * We reserve the MSB to mark a pthread_cond_t as initialized (from the
- * perspective of the application). With a linear space, this means that
- * the theoretical pthread_cond_t range is [0,2147483647].
- */
-BUILD_ASSERT(CONFIG_MAX_PTHREAD_COND_COUNT < PTHREAD_OBJ_MASK_INIT,
-	     "CONFIG_MAX_PTHREAD_COND_COUNT is too high");
-
-static inline size_t posix_cond_to_offset(struct posix_cond *cv)
-{
-	return cv - posix_cond_pool;
-}
-
-static inline size_t to_posix_cond_idx(pthread_cond_t cond)
-{
-	return mark_pthread_obj_uninitialized(cond);
-}
-
-static struct posix_cond *get_posix_cond(pthread_cond_t cond)
-{
-	int actually_initialized;
-	size_t bit = to_posix_cond_idx(cond);
-
-	/* if the provided cond does not claim to be initialized, its invalid */
-	if (!is_pthread_obj_initialized(cond)) {
-		LOG_DBG("Cond is uninitialized (%x)", cond);
-		return NULL;
-	}
-
-	/* Mask off the MSB to get the actual bit index */
-	if (sys_bitarray_test_bit(&posix_cond_bitarray, bit, &actually_initialized) < 0) {
-		LOG_DBG("Cond is invalid (%x)", cond);
-		return NULL;
-	}
-
-	if (actually_initialized == 0) {
-		/* The cond claims to be initialized but is actually not */
-		LOG_DBG("Cond claims to be initialized (%x)", cond);
-		return NULL;
-	}
-
-	return &posix_cond_pool[bit];
-}
-
-static struct posix_cond *to_posix_cond(pthread_cond_t *cvar)
-{
-	size_t bit;
-	struct posix_cond *cv;
-
-	if (*cvar != PTHREAD_COND_INITIALIZER) {
-		return get_posix_cond(*cvar);
-	}
-
-	/* Try and automatically associate a posix_cond */
-	if (sys_bitarray_alloc(&posix_cond_bitarray, 1, &bit) < 0) {
-		/* No conds left to allocate */
-		LOG_DBG("Unable to allocate pthread_cond_t");
-		return NULL;
-	}
-
-	/* Record the associated posix_cond in mu and mark as initialized */
-	*cvar = mark_pthread_obj_initialized(bit);
-	cv = &posix_cond_pool[bit];
-	(void)pthread_condattr_init((pthread_condattr_t *)&cv->attr);
-
-	return cv;
-}
-
-static int cond_wait(pthread_cond_t *cond, pthread_mutex_t *mu, const struct timespec *abstime)
-{
-	int ret;
-	struct k_mutex *m;
-	struct posix_cond *cv;
-	k_timeout_t timeout = K_FOREVER;
-
-	m = to_posix_mutex(mu);
-	cv = to_posix_cond(cond);
-	if (cv == NULL || m == NULL) {
-		return EINVAL;
-	}
-
-	if (abstime != NULL) {
-		timeout = K_MSEC(timespec_to_timeoutms(cv->attr.clock, abstime));
-	}
-
-	LOG_DBG("Waiting on cond %p with timeout %" PRIx64, cv, (int64_t)timeout.ticks);
-	ret = k_condvar_wait(&cv->condvar, m, timeout);
-	if (ret == -EAGAIN) {
-		LOG_DBG("Timeout waiting on cond %p", cv);
-		ret = ETIMEDOUT;
-	} else if (ret < 0) {
-		LOG_DBG("k_condvar_wait() failed: %d", ret);
-		ret = -ret;
-	} else {
-		__ASSERT_NO_MSG(ret == 0);
-		LOG_DBG("Cond %p received signal", cv);
-	}
-
-	return ret;
-}
-
-int pthread_cond_signal(pthread_cond_t *cvar)
-{
-	int ret;
-	struct posix_cond *cv;
-
-	cv = to_posix_cond(cvar);
-	if (cv == NULL) {
-		return EINVAL;
-	}
-
-	LOG_DBG("Signaling cond %p", cv);
-	ret = k_condvar_signal(&cv->condvar);
-	if (ret < 0) {
-		LOG_DBG("k_condvar_signal() failed: %d", ret);
-		return -ret;
-	}
-
-	__ASSERT_NO_MSG(ret == 0);
-
-	return 0;
-}
-
-int pthread_cond_broadcast(pthread_cond_t *cvar)
-{
-	int ret;
-	struct posix_cond *cv;
-
-	cv = get_posix_cond(*cvar);
-	if (cv == NULL) {
-		return EINVAL;
-	}
-
-	LOG_DBG("Broadcasting on cond %p", cv);
-	ret = k_condvar_broadcast(&cv->condvar);
-	if (ret < 0) {
-		LOG_DBG("k_condvar_broadcast() failed: %d", ret);
-		return -ret;
-	}
-
-	__ASSERT_NO_MSG(ret >= 0);
-
-	return 0;
-}
-
-int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mut)
-{
-	return cond_wait(cv, mut, NULL);
-}
-
-int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *mut, const struct timespec *abstime)
-{
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		LOG_DBG("%s is invalid", "abstime");
-		return EINVAL;
-	}
-
-	return cond_wait(cv, mut, abstime);
-}
-
-int pthread_cond_init(pthread_cond_t *cvar, const pthread_condattr_t *att)
-{
-	struct posix_cond *cv;
-	struct posix_condattr *attr = (struct posix_condattr *)att;
-
-	*cvar = PTHREAD_COND_INITIALIZER;
-	cv = to_posix_cond(cvar);
-	if (cv == NULL) {
-		return ENOMEM;
-	}
-
-	if (attr != NULL) {
-		if (!attr->initialized) {
-			return EINVAL;
-		}
-
-		(void)pthread_condattr_destroy((pthread_condattr_t *)&cv->attr);
-		cv->attr = *attr;
-	}
-
-	LOG_DBG("Initialized cond %p", cv);
-
-	return 0;
-}
-
-int pthread_cond_destroy(pthread_cond_t *cvar)
-{
-	int err;
-	size_t bit;
-	struct posix_cond *cv;
-
-	cv = get_posix_cond(*cvar);
-	if (cv == NULL) {
-		return EINVAL;
-	}
-
-	bit = posix_cond_to_offset(cv);
-	err = sys_bitarray_free(&posix_cond_bitarray, 1, bit);
-	__ASSERT_NO_MSG(err == 0);
-
-	*cvar = -1;
-
-	LOG_DBG("Destroyed cond %p", cv);
-
-	return 0;
-}
-
-__boot_func
-static int pthread_cond_pool_init(void)
-{
-	int err;
-	size_t i;
-
-	for (i = 0; i < CONFIG_MAX_PTHREAD_COND_COUNT; ++i) {
-		err = k_condvar_init(&posix_cond_pool[i].condvar);
-		__ASSERT_NO_MSG(err == 0);
-	}
-
-	return 0;
-}
-
-int pthread_condattr_init(pthread_condattr_t *att)
-{
-	struct posix_condattr *const attr = (struct posix_condattr *)att;
-
-	if (att == NULL) {
-		return EINVAL;
-	}
-	if (attr->initialized) {
-		LOG_DBG("%s %s initialized", "attribute", "already");
-		return EINVAL;
-	}
-
-	attr->clock = CLOCK_REALTIME;
-	attr->initialized = true;
-
-	return 0;
-}
-
-int pthread_condattr_destroy(pthread_condattr_t *att)
-{
-	struct posix_condattr *const attr = (struct posix_condattr *)att;
-
-	if ((attr == NULL) || !attr->initialized) {
-		LOG_DBG("%s %s initialized", "attribute", "not");
-		return EINVAL;
-	}
-
-	*attr = (struct posix_condattr){0};
-
-	return 0;
-}
-
-SYS_INIT(pthread_cond_pool_init, PRE_KERNEL_1, 0);
diff --git a/lib/posix/options/confstr.c b/lib/posix/options/confstr.c
deleted file mode 100644
index aec796c19fa..00000000000
--- a/lib/posix/options/confstr.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-
-#include <unistd.h>
-
-#ifndef _CS_V6_ENV
-#define _CS_V6_ENV 20
-#endif
-
-size_t confstr(int name, char *buf, size_t len)
-{
-	if (name < 0 || name > _CS_V6_ENV) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	if (buf != NULL && len > 0) {
-		buf[0] = '\0';
-	}
-
-	return 1;
-}
diff --git a/lib/posix/options/device_io.c b/lib/posix/options/device_io.c
deleted file mode 100644
index 66372ff91f7..00000000000
--- a/lib/posix/options/device_io.c
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <stddef.h>
-#include <stdio.h>
-#include <stdint.h>
-
-#include <fcntl.h>
-#include <poll.h>
-#include <unistd.h>
-#include <sys/select.h>
-
-/* prototypes for external, not-yet-public, functions in fdtable.c or fs.c */
-int zvfs_close(int fd);
-FILE *zvfs_fdopen(int fd, const char *mode);
-int zvfs_fileno(FILE *file);
-int zvfs_open(const char *name, int flags, int mode);
-ssize_t zvfs_read(int fd, void *buf, size_t sz, size_t *from_offset);
-ssize_t zvfs_write(int fd, const void *buf, size_t sz, size_t *from_offset);
-
-#undef FD_CLR
-void FD_CLR(int fd, struct zvfs_fd_set *fdset)
-{
-	ZVFS_FD_CLR(fd, fdset);
-}
-
-#undef FD_ISSET
-int FD_ISSET(int fd, struct zvfs_fd_set *fdset)
-{
-	return ZVFS_FD_ISSET(fd, fdset);
-}
-
-#undef FD_SET
-void FD_SET(int fd, struct zvfs_fd_set *fdset)
-{
-	ZVFS_FD_SET(fd, fdset);
-}
-
-#undef FD_ZERO
-void FD_ZERO(struct zvfs_fd_set *fdset)
-{
-	ZVFS_FD_ZERO(fdset);
-}
-
-int close(int fd)
-{
-	return zvfs_close(fd);
-}
-#ifdef CONFIG_POSIX_DEVICE_IO_ALIAS_CLOSE
-FUNC_ALIAS(close, _close, int);
-#endif
-
-FILE *fdopen(int fd, const char *mode)
-{
-	return zvfs_fdopen(fd, mode);
-}
-
-int fileno(FILE *file)
-{
-	return zvfs_fileno(file);
-}
-
-int open(const char *name, int flags, ...)
-{
-	int mode = 0;
-	va_list args;
-
-	if ((flags & O_CREAT) != 0) {
-		va_start(args, flags);
-		mode = va_arg(args, int);
-		va_end(args);
-	}
-
-	return zvfs_open(name, flags, mode);
-}
-#ifdef CONFIG_POSIX_DEVICE_IO_ALIAS_OPEN
-FUNC_ALIAS(open, _open, int);
-#endif
-
-int poll(struct pollfd *fds, int nfds, int timeout)
-{
-	return zvfs_poll(fds, nfds, timeout);
-}
-
-ssize_t pread(int fd, void *buf, size_t count, off_t offset)
-{
-	size_t off = (size_t)offset;
-
-	if (offset < 0) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	return zvfs_read(fd, buf, count, (size_t *)&off);
-}
-
-int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
-	    const struct timespec *timeout, const sigset_t *sigmask)
-{
-	return zvfs_select(nfds, (struct zvfs_fd_set *)readfds, (struct zvfs_fd_set *)writefds,
-			   (struct zvfs_fd_set *)exceptfds, timeout, sigmask);
-}
-
-ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset)
-{
-	size_t off = (size_t)offset;
-
-	if (offset < 0) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	return zvfs_write(fd, buf, count, (size_t *)&off);
-}
-
-ssize_t read(int fd, void *buf, size_t sz)
-{
-	return zvfs_read(fd, buf, sz, NULL);
-}
-#ifdef CONFIG_POSIX_DEVICE_IO_ALIAS_READ
-FUNC_ALIAS(read, _read, ssize_t);
-#endif
-
-int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
-{
-	struct timespec to = {
-		.tv_sec = (timeout == NULL) ? 0 : timeout->tv_sec,
-		.tv_nsec = (long)((timeout == NULL) ? 0 : timeout->tv_usec * NSEC_PER_USEC)};
-
-	return zvfs_select(nfds, (struct zvfs_fd_set *)readfds, (struct zvfs_fd_set *)writefds,
-			   (struct zvfs_fd_set *)exceptfds, &to, NULL);
-}
-
-ssize_t write(int fd, const void *buf, size_t sz)
-{
-	return zvfs_write(fd, buf, sz, NULL);
-}
-#ifdef CONFIG_POSIX_DEVICE_IO_ALIAS_WRITE
-FUNC_ALIAS(write, _write, ssize_t);
-#endif
diff --git a/lib/posix/options/env.c b/lib/posix/options/env.c
deleted file mode 100644
index b8819280d73..00000000000
--- a/lib/posix/options/env.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <stddef.h>
-
-extern char *z_getenv(const char *name);
-extern int z_getenv_r(const char *name, char *buf, size_t len);
-extern int z_setenv(const char *name, const char *val, int overwrite);
-extern int z_unsetenv(const char *name);
-
-char *getenv(const char *name)
-{
-	return z_getenv(name);
-}
-
-int getenv_r(const char *name, char *buf, size_t len)
-{
-	return z_getenv_r(name, buf, len);
-}
-
-int setenv(const char *name, const char *val, int overwrite)
-{
-	return z_setenv(name, val, overwrite);
-}
-
-int unsetenv(const char *name)
-{
-	return z_unsetenv(name);
-}
diff --git a/lib/posix/options/env_common.c b/lib/posix/options/env_common.c
deleted file mode 100644
index 4aa41f63d6e..00000000000
--- a/lib/posix/options/env_common.c
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <zephyr/logging/log.h>
-#include <zephyr/sys/sem.h>
-
-#define TRACK_ALLOC (IS_ENABLED(CONFIG_POSIX_ENV_LOG_LEVEL_DBG) || IS_ENABLED(CONFIG_ZTEST))
-
-LOG_MODULE_REGISTER(posix_env, CONFIG_POSIX_ENV_LOG_LEVEL);
-
-static SYS_SEM_DEFINE(environ_lock, 1, 1);
-static size_t allocated;
-char **environ;
-
-#ifdef CONFIG_ZTEST
-size_t posix_env_get_allocated_space(void)
-{
-	return allocated;
-}
-#endif
-
-static size_t environ_size(void)
-{
-	size_t ret;
-
-	if (environ == NULL) {
-		return 0;
-	}
-
-	for (ret = 0; environ[ret] != NULL; ++ret) {
-	}
-
-	return ret;
-}
-
-static int findenv(const char *name, size_t namelen)
-{
-	const char *env;
-
-	if (name == NULL || namelen == 0 || strchr(name, '=') != NULL) {
-		/* Note: '=' is not a valid name character */
-		return -EINVAL;
-	}
-
-	if (environ == NULL) {
-		return -ENOENT;
-	}
-
-	for (char **envp = &environ[0]; *envp != NULL; ++envp) {
-		env = *envp;
-		if (strncmp(env, name, namelen) == 0 && env[namelen] == '=') {
-			return envp - environ;
-		}
-	}
-
-	return -ENOENT;
-}
-
-char *z_getenv(const char *name)
-{
-	int ret;
-	size_t nsize;
-	char *val = NULL;
-
-	nsize = (name == NULL) ? 0 : strlen(name);
-	SYS_SEM_LOCK(&environ_lock) {
-		ret = findenv(name, nsize);
-		if (ret < 0) {
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		val = environ[ret] + nsize + 1;
-	}
-
-	return val;
-}
-
-int z_getenv_r(const char *name, char *buf, size_t len)
-{
-	int ret = 0;
-	size_t vsize;
-	size_t nsize;
-	char *val = NULL;
-
-	nsize = (name == NULL) ? 0 : strlen(name);
-	SYS_SEM_LOCK(&environ_lock) {
-		ret = findenv(name, nsize);
-		if (ret < 0) {
-			LOG_DBG("No entry for name '%s'", name);
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		val = environ[ret] + nsize + 1;
-		vsize = strlen(val) + 1;
-		if (vsize > len) {
-			ret = -ERANGE;
-			SYS_SEM_LOCK_BREAK;
-		}
-		strcpy(buf, val);
-		LOG_DBG("Found entry %s", environ[ret]);
-	}
-
-	if (ret < 0) {
-		errno = -ret;
-		ret = -1;
-	}
-
-	return ret;
-}
-
-int z_setenv(const char *name, const char *val, int overwrite)
-{
-	int ret = 0;
-	char *env;
-	char **envp;
-	size_t esize;
-	const size_t vsize = (val == NULL) ? 0 : strlen(val);
-	const size_t nsize = (name == NULL) ? 0 : strlen(name);
-	/* total size of name + '=' + val + '\0' */
-	const size_t tsize = nsize + 1 /* '=' */ + vsize + 1 /* '\0' */;
-
-	if (name == NULL || val == NULL) {
-		LOG_DBG("Invalid name '%s' or value '%s'", name, val);
-		errno = EINVAL;
-		return -1;
-	}
-
-	SYS_SEM_LOCK(&environ_lock) {
-		ret = findenv(name, nsize);
-		if (ret == -EINVAL) {
-			LOG_DBG("Invalid name '%s'", name);
-			SYS_SEM_LOCK_BREAK;
-		}
-		if (ret >= 0) {
-			/* name was found in environ */
-			esize = strlen(environ[ret]) + 1;
-			if (overwrite == 0) {
-				LOG_DBG("Found entry %s", environ[ret]);
-				ret = 0;
-				SYS_SEM_LOCK_BREAK;
-			}
-		} else {
-			/* name was not found in environ -> add new entry */
-			esize = environ_size();
-			envp = realloc(environ,
-				       sizeof(void *) * (esize + 1 /* new entry */ + 1 /* NULL */));
-			if (envp == NULL) {
-				ret = -ENOMEM;
-				SYS_SEM_LOCK_BREAK;
-			}
-
-			if (TRACK_ALLOC) {
-				allocated += sizeof(void *) * (esize + 2);
-				LOG_DBG("realloc %zu bytes (allocated: %zu)",
-					sizeof(void *) * (esize + 2), allocated);
-			}
-
-			environ = envp;
-			ret = esize;
-			environ[ret] = NULL;
-			environ[ret + 1] = NULL;
-			esize = 0;
-		}
-
-		if (esize < tsize) {
-			/* need to malloc or realloc space for new environ entry */
-			env = realloc(environ[ret], tsize);
-			if (env == NULL) {
-				ret = -ENOMEM;
-				SYS_SEM_LOCK_BREAK;
-			}
-			if (TRACK_ALLOC) {
-				allocated += tsize - esize;
-				LOG_DBG("realloc %zu bytes (allocated: %zu)", tsize - esize,
-					allocated);
-			}
-			environ[ret] = env;
-		}
-
-		strcpy(environ[ret], name);
-		environ[ret][nsize] = '=';
-		strncpy(environ[ret] + nsize + 1, val, vsize + 1);
-		LOG_DBG("Added entry %s", environ[ret]);
-
-		ret = 0;
-	}
-
-	if (ret < 0) {
-		errno = -ret;
-		ret = -1;
-	}
-
-	return ret;
-}
-
-int z_unsetenv(const char *name)
-{
-	int ret = 0;
-	char **envp;
-	size_t esize;
-	size_t nsize;
-
-	nsize = (name == NULL) ? 0 : strlen(name);
-	SYS_SEM_LOCK(&environ_lock) {
-		ret = findenv(name, nsize);
-		if (ret < 0) {
-			ret = (ret == -EINVAL) ? -EINVAL : 0;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		esize = environ_size();
-		if (TRACK_ALLOC) {
-			allocated -= strlen(environ[ret]) + 1;
-			LOG_DBG("free %zu bytes (allocated: %zu)", strlen(environ[ret]) + 1,
-				allocated);
-		}
-		free(environ[ret]);
-
-		/* shuffle remaining environment variable pointers forward */
-		for (; ret < esize; ++ret) {
-			environ[ret] = environ[ret + 1];
-		}
-		/* environ must be terminated with a NULL pointer */
-		environ[ret] = NULL;
-
-		/* reduce environ size and update allocation */
-		--esize;
-		if (esize == 0) {
-			free(environ);
-			environ = NULL;
-		} else {
-			envp = realloc(environ, (esize + 1 /* NULL */) * sizeof(void *));
-			if (envp != NULL) {
-				environ = envp;
-			}
-		}
-		__ASSERT_NO_MSG((esize >= 1 && environ != NULL) || environ == NULL);
-
-		if (TRACK_ALLOC) {
-			/* recycle nsize here */
-			nsize = ((esize == 0) ? 2 : 1) * sizeof(void *);
-			allocated -= nsize;
-			LOG_DBG("free %zu bytes (allocated: %zu)", nsize, allocated);
-		}
-
-		ret = 0;
-	}
-
-	if (ret < 0) {
-		errno = -ret;
-		ret = -1;
-	}
-
-	return ret;
-}
diff --git a/lib/posix/options/fd_mgmt.c b/lib/posix/options/fd_mgmt.c
deleted file mode 100644
index 7127fa23386..00000000000
--- a/lib/posix/options/fd_mgmt.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <stdarg.h>
-#include <stddef.h>
-#include <stdint.h>
-
-#include <unistd.h>
-#include <sys/select.h>
-#include <sys/socket.h>
-#include <zephyr/sys/fdtable.h>
-
-/* prototypes for external, not-yet-public, functions in fdtable.c or fs.c */
-int zvfs_fcntl(int fd, int cmd, va_list arg);
-int zvfs_ftruncate(int fd, off_t length);
-off_t zvfs_lseek(int fd, off_t offset, int whence);
-
-int fcntl(int fd, int cmd, ...)
-{
-	int ret;
-	va_list args;
-
-	va_start(args, cmd);
-	ret = zvfs_fcntl(fd, cmd, args);
-	va_end(args);
-
-	return ret;
-}
-#ifdef CONFIG_POSIX_FD_MGMT_ALIAS_FCNTL
-FUNC_ALIAS(fcntl, _fcntl, int);
-#endif /* CONFIG_POSIX_FD_MGMT_ALIAS_FCNTL */
-
-int ftruncate(int fd, off_t length)
-{
-	return zvfs_ftruncate(fd, length);
-}
-#ifdef CONFIG_POSIX_FD_MGMT_ALIAS_FTRUNCATE
-FUNC_ALIAS(ftruncate, _ftruncate, int);
-#endif /* CONFIG_POSIX_FD_MGMT_ALIAS_FTRUNCATE */
-
-off_t lseek(int fd, off_t offset, int whence)
-{
-	return zvfs_lseek(fd, offset, whence);
-}
-#ifdef CONFIG_POSIX_FD_MGMT_ALIAS_LSEEK
-FUNC_ALIAS(lseek, _lseek, off_t);
-#endif /* CONFIG_POSIX_FD_MGMT_ALIAS_LSEEK */
diff --git a/lib/posix/options/file_system_r.c b/lib/posix/options/file_system_r.c
deleted file mode 100644
index 5eed4b4a1d7..00000000000
--- a/lib/posix/options/file_system_r.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (c) 2024 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "fs_priv.h"
-
-#include <errno.h>
-#include <string.h>
-
-#include <zephyr/fs/fs.h>
-#include <dirent.h>
-#include <zephyr/sys/util.h>
-
-int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)
-{
-	int rc;
-	struct fs_dirent de;
-	struct posix_fs_desc *const ptr = dirp;
-
-	if (result == NULL) {
-		return EINVAL;
-	}
-
-	if (entry == NULL) {
-		*result = NULL;
-		return EINVAL;
-	}
-
-	if (dirp == NULL) {
-		*result = NULL;
-		return EBADF;
-	}
-
-	rc = fs_readdir(&ptr->dir, &de);
-	if (rc < 0) {
-		*result = NULL;
-		return -rc;
-	}
-
-	strncpy(entry->d_name, de.name, min(sizeof(entry->d_name), sizeof(de.name)));
-	entry->d_name[sizeof(entry->d_name) - 1] = '\0';
-
-	if (entry->d_name[0] == '\0') {
-		*result = NULL;
-		return 0;
-	}
-
-	*result = entry;
-	return 0;
-}
diff --git a/lib/posix/options/fs.c b/lib/posix/options/fs.c
deleted file mode 100644
index b37bb106155..00000000000
--- a/lib/posix/options/fs.c
+++ /dev/null
@@ -1,491 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "fs_priv.h"
-
-#include <errno.h>
-#include <zephyr/kernel.h>
-#include <limits.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <string.h>
-#include <zephyr/sys/fdtable.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <zephyr/fs/fs.h>
-
-int zvfs_fstat(int fd, struct stat *buf);
-
-BUILD_ASSERT(PATH_MAX >= MAX_FILE_NAME, "PATH_MAX is less than MAX_FILE_NAME");
-
-static struct posix_fs_desc desc_array[CONFIG_POSIX_OPEN_MAX];
-
-static struct fs_dirent fdirent;
-static struct dirent pdirent;
-
-static struct fd_op_vtable fs_fd_op_vtable;
-
-static struct posix_fs_desc *posix_fs_alloc_obj(bool is_dir)
-{
-	int i;
-	struct posix_fs_desc *ptr = NULL;
-	unsigned int key = irq_lock();
-
-	for (i = 0; i < CONFIG_POSIX_OPEN_MAX; i++) {
-		if (desc_array[i].used == false) {
-			ptr = &desc_array[i];
-			ptr->used = true;
-			ptr->is_dir = is_dir;
-			break;
-		}
-	}
-	irq_unlock(key);
-
-	return ptr;
-}
-
-static inline void posix_fs_free_obj(struct posix_fs_desc *ptr)
-{
-	ptr->used = false;
-}
-
-static int posix_mode_to_zephyr(int mf)
-{
-	int mode = (mf & O_CREAT) ? FS_O_CREATE : 0;
-
-	mode |= (mf & O_APPEND) ? FS_O_APPEND : 0;
-	mode |= (mf & O_TRUNC) ? FS_O_TRUNC : 0;
-
-	switch (mf & O_ACCMODE) {
-	case O_RDONLY:
-		mode |= FS_O_READ;
-		break;
-	case O_WRONLY:
-		mode |= FS_O_WRITE;
-		break;
-	case O_RDWR:
-		mode |= FS_O_RDWR;
-		break;
-	default:
-		break;
-	}
-
-	return mode;
-}
-
-int zvfs_open(const char *name, int flags, int mode)
-{
-	int rc, fd;
-	struct posix_fs_desc *ptr = NULL;
-	int zmode = posix_mode_to_zephyr(flags);
-
-	if (zmode < 0) {
-		return zmode;
-	}
-
-	fd = zvfs_reserve_fd();
-	if (fd < 0) {
-		return -1;
-	}
-
-	ptr = posix_fs_alloc_obj(false);
-	if (ptr == NULL) {
-		rc = -EMFILE;
-		goto out_err;
-	}
-
-	fs_file_t_init(&ptr->file);
-
-	if (flags & O_CREAT) {
-		flags &= ~O_CREAT;
-
-		rc = fs_open(&ptr->file, name, FS_O_CREATE | (mode & O_ACCMODE));
-		if (rc < 0) {
-			goto out_err;
-		}
-		rc = fs_close(&ptr->file);
-		if (rc < 0) {
-			goto out_err;
-		}
-	}
-
-	rc = fs_open(&ptr->file, name, zmode);
-	if (rc < 0) {
-		goto out_err;
-	}
-
-	zvfs_finalize_fd(fd, ptr, &fs_fd_op_vtable);
-
-	goto out;
-
-out_err:
-	if (ptr != NULL) {
-		posix_fs_free_obj(ptr);
-	}
-
-	zvfs_free_fd(fd);
-	errno = -rc;
-	return -1;
-
-out:
-	return fd;
-}
-
-static int fs_close_vmeth(void *obj)
-{
-	struct posix_fs_desc *ptr = obj;
-	int rc;
-
-	rc = fs_close(&ptr->file);
-	posix_fs_free_obj(ptr);
-
-	return rc;
-}
-
-static int fs_ioctl_vmeth(void *obj, unsigned int request, va_list args)
-{
-	int rc = 0;
-	struct posix_fs_desc *ptr = obj;
-
-	switch (request) {
-	case ZFD_IOCTL_STAT: {
-		struct stat *buf = va_arg(args, struct stat *);
-		long offset = fs_tell(&ptr->file);
-		long current;
-
-		if (offset < 0) {
-			return offset;
-		}
-
-		memset(buf, 0, sizeof(struct stat));
-
-		rc = fs_seek(&ptr->file, 0, FS_SEEK_END);
-		if (rc < 0) {
-			return rc;
-		}
-
-		current = fs_tell(&ptr->file);
-		if (current >= 0) {
-			buf->st_size = current;
-#if defined(_XOPEN_SOURCE)
-			buf->st_mode = ptr->is_dir ? S_IFDIR : S_IFREG;
-#endif
-		}
-
-		rc = fs_seek(&ptr->file, offset, FS_SEEK_SET);
-
-		if (current < 0) {
-			rc = current;
-		}
-		break;
-	}
-	case ZFD_IOCTL_FSYNC: {
-		rc = fs_sync(&ptr->file);
-		break;
-	}
-	case ZFD_IOCTL_LSEEK: {
-		off_t offset;
-		int whence;
-
-		offset = va_arg(args, off_t);
-		whence = va_arg(args, int);
-
-		rc = fs_seek(&ptr->file, offset, whence);
-		if (rc == 0) {
-			rc = fs_tell(&ptr->file);
-		}
-		break;
-	}
-	case ZFD_IOCTL_TRUNCATE: {
-		off_t length;
-
-		length = va_arg(args, off_t);
-
-		rc = fs_truncate(&ptr->file, length);
-		if (rc < 0) {
-			errno = -rc;
-			return -1;
-		}
-		break;
-	}
-	default:
-		errno = EOPNOTSUPP;
-		return -1;
-	}
-
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	return rc;
-}
-
-/**
- * @brief Write to a file.
- *
- * See IEEE 1003.1
- */
-static ssize_t fs_write_vmeth(void *obj, const void *buffer, size_t count)
-{
-	ssize_t rc;
-	struct posix_fs_desc *ptr = obj;
-
-	rc = fs_write(&ptr->file, buffer, count);
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	return rc;
-}
-
-/**
- * @brief Read from a file.
- *
- * See IEEE 1003.1
- */
-static ssize_t fs_read_vmeth(void *obj, void *buffer, size_t count)
-{
-	ssize_t rc;
-	struct posix_fs_desc *ptr = obj;
-
-	rc = fs_read(&ptr->file, buffer, count);
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	return rc;
-}
-
-static struct fd_op_vtable fs_fd_op_vtable = {
-	.read = fs_read_vmeth,
-	.write = fs_write_vmeth,
-	.close = fs_close_vmeth,
-	.ioctl = fs_ioctl_vmeth,
-};
-
-/**
- * @brief Open a directory stream.
- *
- * See IEEE 1003.1
- */
-DIR *opendir(const char *dirname)
-{
-	int rc;
-	struct posix_fs_desc *ptr;
-
-	ptr = posix_fs_alloc_obj(true);
-	if (ptr == NULL) {
-		errno = EMFILE;
-		return NULL;
-	}
-
-	fs_dir_t_init(&ptr->dir);
-
-	rc = fs_opendir(&ptr->dir, dirname);
-	if (rc < 0) {
-		posix_fs_free_obj(ptr);
-		errno = -rc;
-		return NULL;
-	}
-
-	return ptr;
-}
-
-/**
- * @brief Close a directory stream.
- *
- * See IEEE 1003.1
- */
-int closedir(DIR *dirp)
-{
-	int rc;
-	struct posix_fs_desc *ptr = dirp;
-
-	if (dirp == NULL) {
-		errno = EBADF;
-		return -1;
-	}
-
-	rc = fs_closedir(&ptr->dir);
-
-	posix_fs_free_obj(ptr);
-
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	return 0;
-}
-
-/**
- * @brief Read a directory.
- *
- * See IEEE 1003.1
- */
-struct dirent *readdir(DIR *dirp)
-{
-	int rc;
-	struct posix_fs_desc *ptr = dirp;
-
-	if (dirp == NULL) {
-		errno = EBADF;
-		return NULL;
-	}
-
-	rc = fs_readdir(&ptr->dir, &fdirent);
-	if (rc < 0) {
-		errno = -rc;
-		return NULL;
-	}
-
-	if (fdirent.name[0] == 0) {
-		/* assume end-of-dir, leave errno untouched */
-		return NULL;
-	}
-
-	rc = strlen(fdirent.name);
-	rc = (rc < MAX_FILE_NAME) ? rc : (MAX_FILE_NAME - 1);
-	(void)memcpy(pdirent.d_name, fdirent.name, rc);
-
-	/* Make sure the name is NULL terminated */
-	pdirent.d_name[rc] = '\0';
-	return &pdirent;
-}
-
-/**
- * @brief Rename a file.
- *
- * See IEEE 1003.1
- */
-int rename(const char *old, const char *new)
-{
-	int rc;
-
-	rc = fs_rename(old, new);
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	return 0;
-}
-
-/**
- * @brief Remove a directory entry.
- *
- * See IEEE 1003.1
- */
-int unlink(const char *path)
-{
-	int rc;
-
-	rc = fs_unlink(path);
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-	return 0;
-}
-
-/**
- * @brief Get file status.
- *
- * See IEEE 1003.1
- */
-int stat(const char *path, struct stat *buf)
-{
-	int rc;
-	struct fs_statvfs stat_vfs;
-	struct fs_dirent stat_file;
-
-	if (buf == NULL) {
-		errno = EBADF;
-		return -1;
-	}
-
-	rc = fs_statvfs(path, &stat_vfs);
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	rc = fs_stat(path, &stat_file);
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	memset(buf, 0, sizeof(struct stat));
-
-	switch (stat_file.type) {
-	case FS_DIR_ENTRY_FILE:
-#if defined(_XOPEN_SOURCE)
-		buf->st_mode = S_IFREG;
-#endif
-		break;
-	case FS_DIR_ENTRY_DIR:
-#if defined(_XOPEN_SOURCE)
-		buf->st_mode = S_IFDIR;
-#endif
-		break;
-	default:
-		errno = EIO;
-		return -1;
-	}
-	buf->st_size = stat_file.size;
-#if defined(_XOPEN_SOURCE)
-	buf->st_blksize = stat_vfs.f_bsize;
-	/*
-	 * This is a best effort guess, as this information is not provided
-	 * by the fs_stat function.
-	 */
-	buf->st_blocks = (stat_file.size + stat_vfs.f_bsize - 1) / stat_vfs.f_bsize;
-#endif
-
-	return 0;
-}
-
-/**
- * @brief Make a directory.
- *
- * See IEEE 1003.1
- */
-int mkdir(const char *path, mode_t mode)
-{
-	int rc;
-
-	ARG_UNUSED(mode);
-
-	rc = fs_mkdir(path);
-	if (rc < 0) {
-		errno = -rc;
-		return -1;
-	}
-
-	return 0;
-}
-
-int fstat(int fildes, struct stat *buf)
-{
-	return zvfs_fstat(fildes, buf);
-}
-#ifdef CONFIG_POSIX_FILE_SYSTEM_ALIAS_FSTAT
-FUNC_ALIAS(fstat, _fstat, int);
-#endif
-
-/**
- * @brief Remove a directory.
- *
- * See IEEE 1003.1
- */
-int rmdir(const char *path)
-{
-	return unlink(path);
-}
diff --git a/lib/posix/options/fs_priv.h b/lib/posix/options/fs_priv.h
deleted file mode 100644
index 2c3ddb2084e..00000000000
--- a/lib/posix/options/fs_priv.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_LIB_POSIX_OPTIONS_FS_PRIV_H_
-#define ZEPHYR_LIB_POSIX_OPTIONS_FS_PRIV_H_
-
-#include <stdbool.h>
-
-#include <zephyr/fs/fs.h>
-
-struct posix_fs_desc {
-	union {
-		struct fs_file_t file;
-		struct fs_dir_t dir;
-	};
-	bool is_dir: 1;
-	bool used: 1;
-};
-
-#endif
diff --git a/lib/posix/options/fsync.c b/lib/posix/options/fsync.c
deleted file mode 100644
index 1152caf0931..00000000000
--- a/lib/posix/options/fsync.c
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2024 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <unistd.h>
-
-/* prototypes for external, not-yet-public, functions in fdtable.c */
-int zvfs_fsync(int fd);
-
-int fsync(int fd)
-{
-	return zvfs_fsync(fd);
-}
-#ifdef CONFIG_POSIX_FILE_SYSTEM_ALIAS_FSYNC
-FUNC_ALIAS(fsync, _fsync, int);
-#endif
-
-#ifdef CONFIG_POSIX_SYNCHRONIZED_IO
-int fdatasync(int fd)
-{
-	return fsync(fd);
-}
-#endif /* CONFIG_POSIX_SYNCHRONIZED_IO */
diff --git a/lib/posix/options/grp.c b/lib/posix/options/grp.c
deleted file mode 100644
index 1333a1c8ed3..00000000000
--- a/lib/posix/options/grp.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2024 Meta Platforms
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-
-#include <zephyr/sys/util.h>
-#include <grp.h>
-
-int getgrnam_r(const char *name, struct group *grp, char *buffer, size_t bufsize,
-	       struct group **result)
-{
-	ARG_UNUSED(name);
-	ARG_UNUSED(grp);
-	ARG_UNUSED(buffer);
-	ARG_UNUSED(bufsize);
-	ARG_UNUSED(result);
-
-	return ENOSYS;
-}
-
-int getgrgid_r(gid_t gid, struct group *grp, char *buffer, size_t bufsize, struct group **result)
-{
-	ARG_UNUSED(gid);
-	ARG_UNUSED(grp);
-	ARG_UNUSED(buffer);
-	ARG_UNUSED(bufsize);
-	ARG_UNUSED(result);
-
-	return ENOSYS;
-}
diff --git a/lib/posix/options/key.c b/lib/posix/options/key.c
deleted file mode 100644
index 0b481a1f598..00000000000
--- a/lib/posix/options/key.c
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include "posix_internal.h"
-
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <pthread.h>
-#include <zephyr/sys/bitarray.h>
-#include <zephyr/sys/__assert.h>
-#include <zephyr/sys/sem.h>
-
-LOG_MODULE_REGISTER(pthread_key, CONFIG_PTHREAD_KEY_LOG_LEVEL);
-
-SYS_SEM_DEFINE(pthread_key_lock, 1, 1);
-
-/* This is non-standard (i.e. an implementation detail) */
-#define PTHREAD_KEY_INITIALIZER (-1)
-
-/*
- * We reserve the MSB to mark a pthread_key_t as initialized (from the
- * perspective of the application). With a linear space, this means that
- * the theoretical pthread_key_t range is [0,2147483647].
- */
-BUILD_ASSERT(CONFIG_POSIX_THREAD_KEYS_MAX < PTHREAD_OBJ_MASK_INIT,
-	     "CONFIG_POSIX_THREAD_KEYS_MAX is too high");
-
-static pthread_key_obj posix_key_pool[CONFIG_POSIX_THREAD_KEYS_MAX];
-SYS_BITARRAY_DEFINE_STATIC(posix_key_bitarray, CONFIG_POSIX_THREAD_KEYS_MAX);
-
-static inline size_t posix_key_to_offset(pthread_key_obj *k)
-{
-	return k - posix_key_pool;
-}
-
-static inline size_t to_posix_key_idx(pthread_key_t key)
-{
-	return mark_pthread_obj_uninitialized(key);
-}
-
-static pthread_key_obj *get_posix_key(pthread_key_t key)
-{
-	int actually_initialized;
-	size_t bit = to_posix_key_idx(key);
-
-	/* if the provided cond does not claim to be initialized, its invalid */
-	if (!is_pthread_obj_initialized(key)) {
-		LOG_DBG("Key is uninitialized (%x)", key);
-		return NULL;
-	}
-
-	/* Mask off the MSB to get the actual bit index */
-	if (sys_bitarray_test_bit(&posix_key_bitarray, bit, &actually_initialized) < 0) {
-		LOG_DBG("Key is invalid (%x)", key);
-		return NULL;
-	}
-
-	if (actually_initialized == 0) {
-		/* The cond claims to be initialized but is actually not */
-		LOG_DBG("Key claims to be initialized (%x)", key);
-		return NULL;
-	}
-
-	return &posix_key_pool[bit];
-}
-
-static pthread_key_obj *to_posix_key(pthread_key_t *key)
-{
-	size_t bit;
-	pthread_key_obj *k;
-
-	if (*key != PTHREAD_KEY_INITIALIZER) {
-		return get_posix_key(*key);
-	}
-
-	/* Try and automatically associate a pthread_key_obj */
-	if (sys_bitarray_alloc(&posix_key_bitarray, 1, &bit) < 0) {
-		/* No keys left to allocate */
-		return NULL;
-	}
-
-	/* Record the associated posix_cond in mu and mark as initialized */
-	*key = mark_pthread_obj_initialized(bit);
-	k = &posix_key_pool[bit];
-
-	/* Initialize the condition variable here */
-	memset(k, 0, sizeof(*k));
-
-	return k;
-}
-
-/**
- * @brief Create a key for thread-specific data
- *
- * See IEEE 1003.1
- */
-int pthread_key_create(pthread_key_t *key,
-		void (*destructor)(void *))
-{
-	pthread_key_obj *new_key;
-
-	*key = PTHREAD_KEY_INITIALIZER;
-	new_key = to_posix_key(key);
-	if (new_key == NULL) {
-		return ENOMEM;
-	}
-
-	sys_slist_init(&(new_key->key_data_l));
-
-	new_key->destructor = destructor;
-	LOG_DBG("Initialized key %p (%x)", new_key, *key);
-
-	return 0;
-}
-
-/**
- * @brief Delete a key for thread-specific data
- *
- * See IEEE 1003.1
- */
-int pthread_key_delete(pthread_key_t key)
-{
-	size_t bit;
-	int ret = EINVAL;
-	pthread_key_obj *key_obj = NULL;
-	struct pthread_key_data *key_data;
-	sys_snode_t *node_l, *next_node_l;
-
-	SYS_SEM_LOCK(&pthread_key_lock) {
-		key_obj = get_posix_key(key);
-		if (key_obj == NULL) {
-			ret = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		/* Delete thread-specific elements associated with the key */
-		SYS_SLIST_FOR_EACH_NODE_SAFE(&(key_obj->key_data_l), node_l, next_node_l) {
-
-			/* Remove the object from the list key_data_l */
-			key_data = (struct pthread_key_data *)sys_slist_get(&(key_obj->key_data_l));
-
-			/* Deallocate the object's memory */
-			k_free((void *)key_data);
-			LOG_DBG("Freed key data %p for key %x in thread %x", key_data, key,
-				pthread_self());
-		}
-
-		bit = posix_key_to_offset(key_obj);
-		ret = sys_bitarray_free(&posix_key_bitarray, 1, bit);
-		__ASSERT_NO_MSG(ret == 0);
-	}
-
-	if (ret == 0) {
-		LOG_DBG("Deleted key %p (%x)", key_obj, key);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Associate a thread-specific value with a key
- *
- * See IEEE 1003.1
- */
-int pthread_setspecific(pthread_key_t key, const void *value)
-{
-	pthread_key_obj *key_obj = NULL;
-	struct posix_thread *thread;
-	struct pthread_key_data *key_data;
-	sys_snode_t *node_l = NULL;
-	int retval = 0;
-
-	thread = to_posix_thread(pthread_self());
-	if (thread == NULL) {
-		return EINVAL;
-	}
-
-	/* Traverse the list of keys set by the thread, looking for key.
-	 * If the key is already in the list, re-assign its value.
-	 * Else add the key to the thread's list.
-	 */
-	SYS_SEM_LOCK(&pthread_key_lock) {
-		key_obj = get_posix_key(key);
-		if (key_obj == NULL) {
-			retval = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		SYS_SLIST_FOR_EACH_NODE(&(thread->key_list), node_l) {
-			pthread_thread_data *thread_spec_data = (pthread_thread_data *)node_l;
-
-			if (thread_spec_data->key == key_obj) {
-				/* Key is already present so associate thread specific data */
-				thread_spec_data->spec_data = (void *)value;
-				LOG_DBG("Paired key %x to value %p for thread %x", key, value,
-					pthread_self());
-				break;
-			}
-		}
-
-		retval = 0;
-		if (node_l != NULL) {
-			/* Key is already present, so we are done */
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		/* Key and data need to be added */
-		key_data = k_malloc(sizeof(struct pthread_key_data));
-
-		if (key_data == NULL) {
-			LOG_DBG("Failed to allocate key data for key %x", key);
-			retval = ENOMEM;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		LOG_DBG("Allocated key data %p for key %x in thread %x", key_data, key,
-			pthread_self());
-
-		/* Associate thread specific data, initialize new key */
-		key_data->thread_data.key = key_obj;
-		key_data->thread_data.spec_data = (void *)value;
-
-		/* Append new thread key data to thread's key list */
-		sys_slist_append((&thread->key_list), (sys_snode_t *)(&key_data->thread_data));
-
-		/* Append new key data to the key object's list */
-		sys_slist_append(&(key_obj->key_data_l), (sys_snode_t *)key_data);
-
-		LOG_DBG("Paired key %x to value %p for thread %x", key, value, pthread_self());
-	}
-
-	return retval;
-}
-
-/**
- * @brief Get the thread-specific value associated with the key
- *
- * See IEEE 1003.1
- */
-void *pthread_getspecific(pthread_key_t key)
-{
-	pthread_key_obj *key_obj;
-	struct posix_thread *thread;
-	pthread_thread_data *thread_spec_data;
-	void *value = NULL;
-	sys_snode_t *node_l;
-
-	thread = to_posix_thread(pthread_self());
-	if (thread == NULL) {
-		return NULL;
-	}
-
-	SYS_SEM_LOCK(&pthread_key_lock) {
-		key_obj = get_posix_key(key);
-		if (key_obj == NULL) {
-			value = NULL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		/* Traverse the list of keys set by the thread, looking for key */
-
-		SYS_SLIST_FOR_EACH_NODE(&(thread->key_list), node_l) {
-			thread_spec_data = (pthread_thread_data *)node_l;
-			if (thread_spec_data->key == key_obj) {
-				/* Key is present, so get the set thread data */
-				value = thread_spec_data->spec_data;
-				break;
-			}
-		}
-	}
-
-	return value;
-}
diff --git a/lib/posix/options/mlock.c b/lib/posix/options/mlock.c
deleted file mode 100644
index a5b5ece82bb..00000000000
--- a/lib/posix/options/mlock.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <stddef.h>
-
-#include <zephyr/kernel.h>
-#include <sys/mman.h>
-
-#include <zephyr/kernel/mm/demand_paging.h>
-
-int mlock(const void *addr, size_t len)
-{
-	if (IS_ENABLED(CONFIG_DEMAND_PAGING)) {
-		void *const _addr = (void *)addr;
-
-		k_mem_pin(_addr, len);
-
-		return 0;
-	}
-
-	errno = ENOTSUP;
-	return -1;
-}
-
-int munlock(const void *addr, size_t len)
-{
-	if (IS_ENABLED(CONFIG_DEMAND_PAGING)) {
-		void *const _addr = (void *)addr;
-
-		k_mem_unpin(_addr, len);
-
-		return 0;
-	}
-
-	errno = ENOTSUP;
-	return -1;
-}
diff --git a/lib/posix/options/mlockall.c b/lib/posix/options/mlockall.c
deleted file mode 100644
index da0225e8b98..00000000000
--- a/lib/posix/options/mlockall.c
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stddef.h>
-#include <sys/types.h>
-
-#include <sys/mman.h>
-#include <zephyr/toolchain.h>
-
-int mlockall(int flags)
-{
-	ARG_UNUSED(flags);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int munlockall(void)
-{
-	errno = ENOSYS;
-	return -1;
-}
diff --git a/lib/posix/options/mmap.c b/lib/posix/options/mmap.c
deleted file mode 100644
index 08e56d1c635..00000000000
--- a/lib/posix/options/mmap.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stddef.h>
-#include <sys/mman.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include <kernel_arch_interface.h>
-#include <zephyr/kernel.h>
-#include <zephyr/kernel/mm.h>
-#include <zephyr/sys/fdtable.h>
-
-#define _page_size COND_CODE_1(CONFIG_MMU, (CONFIG_MMU_PAGE_SIZE), (CONFIG_POSIX_PAGE_SIZE))
-
-int zvfs_ioctl(int fd, int cmd, va_list args);
-
-static int p2z(int prot, int pflags)
-{
-	bool rw = (prot & PROT_WRITE) != 0;
-	bool ex = (prot & PROT_EXEC) != 0;
-	bool fixed = (pflags & MAP_FIXED) != 0;
-	bool shared = (pflags & MAP_SHARED) != 0;
-	bool private = (pflags & MAP_PRIVATE) != 0;
-
-	if (!(shared ^ private)) {
-		return -1;
-	}
-
-	return (rw * K_MEM_PERM_RW) | (ex * K_MEM_PERM_EXEC) | (fixed * K_MEM_DIRECT_MAP);
-}
-
-static inline int zvfs_ioctl_wrap(int fd, int cmd, ...)
-{
-	int ret;
-	va_list args;
-
-	va_start(args, cmd);
-	ret = zvfs_ioctl(fd, cmd, args);
-	va_end(args);
-
-	return ret;
-}
-
-void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off)
-{
-	void *virt;
-	uintptr_t phys;
-	int zflags = p2z(prot, flags);
-
-	if ((len == 0) || (zflags == -1)) {
-		errno = EINVAL;
-		return MAP_FAILED;
-	}
-
-	if ((flags & MAP_ANONYMOUS) != 0) {
-		/* force behaviour to be in-line with Linux, fd is ignored */
-		fd = -1;
-	}
-
-	if (fd > 0) {
-		/* non-anonymous mapping */
-		virt = NULL;
-		if (zvfs_ioctl_wrap(fd, ZFD_IOCTL_MMAP, addr, len, prot, flags, off, &virt) < 0) {
-			return MAP_FAILED;
-		}
-
-		return virt;
-	}
-
-	if (!IS_ENABLED(CONFIG_MMU)) {
-		errno = ENOTSUP;
-		return MAP_FAILED;
-	}
-
-	if ((flags & MAP_FIXED) == 0) {
-		/* anonymous mapping */
-		virt = k_mem_map(len, zflags);
-	} else {
-		/* a physical mapping. Care should be taken not to map the same page twice */
-		virt = NULL;
-		phys = POINTER_TO_UINT(addr);
-		k_mem_map_phys_bare((uint8_t **)&virt, phys, (size_t)ROUND_UP(len, _page_size),
-				    zflags);
-	}
-
-	if (virt == NULL) {
-		errno = ENOMEM;
-		return MAP_FAILED;
-	}
-
-	return virt;
-}
-
-int msync(void *addr, size_t length, int flags)
-{
-	ARG_UNUSED(addr);
-	ARG_UNUSED(length);
-	ARG_UNUSED(flags);
-
-	return 0;
-}
-
-int munmap(void *addr, size_t len)
-{
-	if (len == 0) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (!IS_ENABLED(CONFIG_MMU)) {
-		/* cannot munmap without an MPU */
-		errno = ENOTSUP;
-		return -1;
-	}
-
-	uintptr_t phys = 0;
-
-	if (arch_page_phys_get(addr, &phys) == 0) {
-		k_mem_unmap(addr, ROUND_UP(len, _page_size));
-	}
-
-	return 0;
-}
diff --git a/lib/posix/options/mprotect.c b/lib/posix/options/mprotect.c
deleted file mode 100644
index 9bc250b967c..00000000000
--- a/lib/posix/options/mprotect.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stddef.h>
-#include <sys/types.h>
-
-#include <sys/mman.h>
-#include <zephyr/toolchain.h>
-
-int mprotect(void *addr, size_t len, int prot)
-{
-	ARG_UNUSED(addr);
-	ARG_UNUSED(len);
-	ARG_UNUSED(prot);
-
-	errno = ENOSYS;
-	return -1;
-}
diff --git a/lib/posix/options/mqueue.c b/lib/posix/options/mqueue.c
deleted file mode 100644
index 2382790f8c2..00000000000
--- a/lib/posix/options/mqueue.c
+++ /dev/null
@@ -1,544 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2024 BayLibre, SAS
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <mqueue.h>
-#include <pthread.h>
-#include <signal.h>
-#include <string.h>
-#include <time.h>
-#include <sys/stat.h>
-
-#include <zephyr/kernel.h>
-#include <zephyr/sys/atomic.h>
-
-#define SIGEV_MASK (SIGEV_NONE | SIGEV_SIGNAL | SIGEV_THREAD)
-
-typedef struct mqueue_object {
-	sys_snode_t snode;
-	char *mem_buffer;
-	char *mem_obj;
-	struct k_msgq queue;
-	atomic_t ref_count;
-	char *name;
-	struct sigevent not;
-} mqueue_object;
-
-typedef struct mqueue_desc {
-	char *mem_desc;
-	mqueue_object *mqueue;
-	uint32_t  flags;
-} mqueue_desc;
-
-K_SEM_DEFINE(mq_sem, 1, 1);
-
-/* Initialize the list */
-sys_slist_t mq_list = SYS_SLIST_STATIC_INIT(&mq_list);
-
-static mqueue_object *find_in_list(const char *name);
-static int32_t send_message(mqueue_desc *mqd, const char *msg_ptr, size_t msg_len,
-			  k_timeout_t timeout);
-static int32_t receive_message(mqueue_desc *mqd, char *msg_ptr, size_t msg_len,
-			   k_timeout_t timeout);
-static void remove_notification(mqueue_object *msg_queue);
-static void remove_mq(mqueue_object *msg_queue);
-static void *mq_notify_thread(void *arg);
-
-/**
- * @brief Open a message queue.
- *
- * Number of message queue and descriptor to message queue are limited by
- * heap size. increase the size through CONFIG_HEAP_MEM_POOL_SIZE.
- *
- * See IEEE 1003.1
- */
-mqd_t mq_open(const char *name, int oflags, ...)
-{
-	va_list va;
-	mode_t mode;
-	struct mq_attr *attrs = NULL;
-	long msg_size = 0U, max_msgs = 0U;
-	mqueue_object *msg_queue;
-	mqueue_desc *msg_queue_desc = NULL, *mqd = (mqueue_desc *)(-1);
-	char *mq_desc_ptr, *mq_obj_ptr, *mq_buf_ptr, *mq_name_ptr;
-
-	va_start(va, oflags);
-	if ((oflags & O_CREAT) != 0) {
-		BUILD_ASSERT(sizeof(mode_t) <= sizeof(int));
-		mode = va_arg(va, unsigned int);
-		attrs = va_arg(va, struct mq_attr*);
-	}
-	va_end(va);
-
-	if (attrs != NULL) {
-		msg_size = attrs->mq_msgsize;
-		max_msgs = attrs->mq_maxmsg;
-	}
-
-	if ((name == NULL) || ((oflags & O_CREAT) != 0 && (msg_size <= 0 ||
-						      max_msgs <= 0))) {
-		errno = EINVAL;
-		return (mqd_t)mqd;
-	}
-
-	if ((strlen(name) + 1)  > CONFIG_MQUEUE_NAMELEN_MAX) {
-		errno = ENAMETOOLONG;
-		return (mqd_t)mqd;
-	}
-
-	/* Check if queue already exists */
-	k_sem_take(&mq_sem, K_FOREVER);
-	msg_queue = find_in_list(name);
-	k_sem_give(&mq_sem);
-
-	if ((msg_queue != NULL) && (oflags & O_CREAT) != 0 &&
-	    (oflags & O_EXCL) != 0) {
-		/* Message queue has already been opened and O_EXCL is set */
-		errno = EEXIST;
-		return (mqd_t)mqd;
-	}
-
-	if ((msg_queue == NULL) && (oflags & O_CREAT) == 0) {
-		errno = ENOENT;
-		return (mqd_t)mqd;
-	}
-
-	mq_desc_ptr = k_malloc(sizeof(struct mqueue_desc));
-	if (mq_desc_ptr != NULL) {
-		(void)memset(mq_desc_ptr, 0, sizeof(struct mqueue_desc));
-		msg_queue_desc = (struct mqueue_desc *)mq_desc_ptr;
-		msg_queue_desc->mem_desc = mq_desc_ptr;
-	} else {
-		goto free_mq_desc;
-	}
-
-
-	/* Allocate mqueue object for new message queue */
-	if (msg_queue == NULL) {
-
-		/* Check for message quantity and size in message queue */
-		if (attrs->mq_msgsize > CONFIG_MSG_SIZE_MAX &&
-		    attrs->mq_maxmsg > CONFIG_POSIX_MQ_OPEN_MAX) {
-			goto free_mq_desc;
-		}
-
-		mq_obj_ptr = k_malloc(sizeof(mqueue_object));
-		if (mq_obj_ptr != NULL) {
-			(void)memset(mq_obj_ptr, 0, sizeof(mqueue_object));
-			msg_queue = (mqueue_object *)mq_obj_ptr;
-			msg_queue->mem_obj = mq_obj_ptr;
-
-		} else {
-			goto free_mq_object;
-		}
-
-		mq_name_ptr = k_malloc(strlen(name) + 1);
-		if (mq_name_ptr != NULL) {
-			(void)memset(mq_name_ptr, 0, strlen(name) + 1);
-			msg_queue->name = mq_name_ptr;
-
-		} else {
-			goto free_mq_name;
-		}
-
-		strcpy(msg_queue->name, name);
-
-		mq_buf_ptr = k_malloc(msg_size * max_msgs * sizeof(uint8_t));
-		if (mq_buf_ptr != NULL) {
-			(void)memset(mq_buf_ptr, 0,
-				     msg_size * max_msgs * sizeof(uint8_t));
-			msg_queue->mem_buffer = mq_buf_ptr;
-		} else {
-			goto free_mq_buffer;
-		}
-
-		(void)atomic_set(&msg_queue->ref_count, 1);
-		/* initialize zephyr message queue */
-		k_msgq_init(&msg_queue->queue, msg_queue->mem_buffer, msg_size,
-			    max_msgs);
-		k_sem_take(&mq_sem, K_FOREVER);
-		sys_slist_append(&mq_list, (sys_snode_t *)&(msg_queue->snode));
-		k_sem_give(&mq_sem);
-
-	} else {
-		atomic_inc(&msg_queue->ref_count);
-	}
-
-	msg_queue_desc->mqueue = msg_queue;
-	msg_queue_desc->flags = (oflags & O_NONBLOCK) != 0 ? O_NONBLOCK : 0;
-	return (mqd_t)msg_queue_desc;
-
-free_mq_buffer:
-	k_free(mq_name_ptr);
-free_mq_name:
-	k_free(mq_obj_ptr);
-free_mq_object:
-	k_free(mq_desc_ptr);
-free_mq_desc:
-	errno = ENOSPC;
-	return (mqd_t)mqd;
-}
-
-/**
- * @brief Close a message queue descriptor.
- *
- * See IEEE 1003.1
- */
-int mq_close(mqd_t mqdes)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-
-	if (mqd == NULL) {
-		errno = EBADF;
-		return -1;
-	}
-
-	atomic_dec(&mqd->mqueue->ref_count);
-
-	/* remove mq if marked for unlink */
-	if (mqd->mqueue->name == NULL) {
-		remove_mq(mqd->mqueue);
-	}
-
-	k_free(mqd->mem_desc);
-	return 0;
-}
-
-/**
- * @brief Remove a message queue.
- *
- * See IEEE 1003.1
- */
-int mq_unlink(const char *name)
-{
-	mqueue_object *msg_queue;
-
-	k_sem_take(&mq_sem, K_FOREVER);
-	msg_queue = find_in_list(name);
-
-	if (msg_queue == NULL) {
-		k_sem_give(&mq_sem);
-		errno = EBADF;
-		return -1;
-	}
-
-	k_free(msg_queue->name);
-	msg_queue->name = NULL;
-	k_sem_give(&mq_sem);
-	remove_mq(msg_queue);
-	return 0;
-}
-
-/**
- * @brief Send a message to a message queue.
- *
- * All messages in message queue are of equal priority.
- *
- * See IEEE 1003.1
- */
-int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
-	    unsigned int msg_prio)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-
-	return send_message(mqd, msg_ptr, msg_len, K_FOREVER);
-}
-
-/**
- * @brief Send message to a message queue within abstime time.
- *
- * All messages in message queue are of equal priority.
- *
- * See IEEE 1003.1
- */
-int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
-		 unsigned int msg_prio, const struct timespec *abstime)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	return send_message(mqd, msg_ptr, msg_len,
-			    K_MSEC(timespec_to_timeoutms(CLOCK_REALTIME, abstime)));
-}
-
-/**
- * @brief Receive a message from a message queue.
- *
- * All messages in message queue are of equal priority.
- *
- * See IEEE 1003.1
- */
-int mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
-		   unsigned int *msg_prio)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-
-	return receive_message(mqd, msg_ptr, msg_len, K_FOREVER);
-}
-
-/**
- * @brief Receive message from a message queue within abstime time.
- *
- * All messages in message queue are of equal priority.
- *
- * See IEEE 1003.1
- */
-int mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
-			unsigned int *msg_prio, const struct timespec *abstime)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	return receive_message(mqd, msg_ptr, msg_len,
-			       K_MSEC(timespec_to_timeoutms(CLOCK_REALTIME, abstime)));
-}
-
-/**
- * @brief Get message queue attributes.
- *
- * See IEEE 1003.1
- */
-int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-	struct k_msgq_attrs attrs;
-
-	if (mqd == NULL) {
-		errno = EBADF;
-		return -1;
-	}
-
-	k_sem_take(&mq_sem, K_FOREVER);
-	k_msgq_get_attrs(&mqd->mqueue->queue, &attrs);
-	mqstat->mq_flags = mqd->flags;
-	mqstat->mq_maxmsg = attrs.max_msgs;
-	mqstat->mq_msgsize = attrs.msg_size;
-	mqstat->mq_curmsgs = attrs.used_msgs;
-	k_sem_give(&mq_sem);
-	return 0;
-}
-
-/**
- * @brief Set message queue attributes.
- *
- * See IEEE 1003.1
- */
-int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat,
-	       struct mq_attr *omqstat)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-
-	if (mqd == NULL) {
-		errno = EBADF;
-		return -1;
-	}
-
-	if (mqstat->mq_flags != 0 && mqstat->mq_flags != O_NONBLOCK) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (omqstat != NULL) {
-		mq_getattr(mqdes, omqstat);
-	}
-
-	k_sem_take(&mq_sem, K_FOREVER);
-	mqd->flags = mqstat->mq_flags;
-	k_sem_give(&mq_sem);
-
-	return 0;
-}
-
-/**
- * @brief Notify process that a message is available.
- *
- * See IEEE 1003.1
- */
-int mq_notify(mqd_t mqdes, const struct sigevent *notification)
-{
-	mqueue_desc *mqd = (mqueue_desc *)mqdes;
-
-	if (mqd == NULL) {
-		errno = EBADF;
-		return -1;
-	}
-
-	mqueue_object *msg_queue = mqd->mqueue;
-
-	if (notification == NULL) {
-		if ((msg_queue->not.sigev_notify & SIGEV_MASK) == 0) {
-			errno = EINVAL;
-			return -1;
-		}
-		remove_notification(msg_queue);
-		return 0;
-	}
-
-	if ((msg_queue->not.sigev_notify & SIGEV_MASK) != 0) {
-		errno = EBUSY;
-		return -1;
-	}
-	if (notification->sigev_notify == SIGEV_SIGNAL) {
-		errno = ENOSYS;
-		return -1;
-	}
-	if (notification->sigev_notify_attributes != NULL) {
-		int ret = pthread_attr_setdetachstate(notification->sigev_notify_attributes,
-						      PTHREAD_CREATE_DETACHED);
-		if (ret != 0) {
-			errno = ret;
-			return -1;
-		}
-	}
-
-	k_sem_take(&mq_sem, K_FOREVER);
-	memcpy(&msg_queue->not, notification, sizeof(struct sigevent));
-	k_sem_give(&mq_sem);
-
-	return 0;
-}
-
-static void *mq_notify_thread(void *arg)
-{
-	mqueue_object *mqueue = (mqueue_object *)arg;
-	struct sigevent *sevp = &mqueue->not;
-
-	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
-
-	if (sevp->sigev_notify_attributes == NULL) {
-		pthread_detach(pthread_self());
-	}
-
-	sevp->sigev_notify_function(sevp->sigev_value);
-
-	remove_notification(mqueue);
-
-	return NULL;
-}
-
-/* Internal functions */
-static mqueue_object *find_in_list(const char *name)
-{
-	sys_snode_t *mq;
-	mqueue_object *msg_queue;
-
-	mq = mq_list.head;
-
-	while (mq != NULL) {
-		msg_queue = (mqueue_object *)mq;
-		if ((msg_queue->name != NULL) && (strcmp(msg_queue->name, name) == 0)) {
-			return msg_queue;
-		}
-
-		mq = mq->next;
-	}
-
-	return NULL;
-}
-
-static int32_t send_message(mqueue_desc *mqd, const char *msg_ptr, size_t msg_len,
-			  k_timeout_t timeout)
-{
-	int32_t ret = -1;
-
-	if (mqd == NULL) {
-		errno = EBADF;
-		return ret;
-	}
-
-	if ((mqd->flags & O_NONBLOCK) != 0U) {
-		timeout = K_NO_WAIT;
-	}
-
-	if (msg_len >  mqd->mqueue->queue.msg_size) {
-		errno = EMSGSIZE;
-		return ret;
-	}
-
-	uint32_t msgq_num = k_msgq_num_used_get(&mqd->mqueue->queue);
-
-	if (k_msgq_put(&mqd->mqueue->queue, (void *)msg_ptr, timeout) != 0) {
-		errno = K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? EAGAIN : ETIMEDOUT;
-		return ret;
-	}
-
-	if (k_msgq_num_used_get(&mqd->mqueue->queue) - msgq_num > 0) {
-		struct sigevent *sevp = &mqd->mqueue->not;
-
-		if (sevp->sigev_notify == SIGEV_NONE) {
-			sevp->sigev_notify_function(sevp->sigev_value);
-		} else if (sevp->sigev_notify == SIGEV_THREAD) {
-			pthread_t th;
-
-			ret = pthread_create(&th,
-					     sevp->sigev_notify_attributes,
-					     mq_notify_thread,
-					     mqd->mqueue);
-		}
-	}
-
-	return 0;
-}
-
-static int32_t receive_message(mqueue_desc *mqd, char *msg_ptr, size_t msg_len,
-			     k_timeout_t timeout)
-{
-	int ret = -1;
-
-	if (mqd == NULL) {
-		errno = EBADF;
-		return ret;
-	}
-
-	if (msg_len < mqd->mqueue->queue.msg_size) {
-		errno = EMSGSIZE;
-		return ret;
-	}
-
-	if ((mqd->flags & O_NONBLOCK) != 0U) {
-		timeout = K_NO_WAIT;
-	}
-
-	if (k_msgq_get(&mqd->mqueue->queue, (void *)msg_ptr, timeout) != 0) {
-		errno = K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? EAGAIN : ETIMEDOUT;
-	} else {
-		ret = mqd->mqueue->queue.msg_size;
-	}
-
-	return ret;
-}
-
-static void remove_mq(mqueue_object *msg_queue)
-{
-	if (atomic_cas(&msg_queue->ref_count, 0, 0)) {
-		k_sem_take(&mq_sem, K_FOREVER);
-		sys_slist_find_and_remove(&mq_list, (sys_snode_t *) msg_queue);
-		k_sem_give(&mq_sem);
-
-		/* Free mq buffer and pbject */
-		k_free(msg_queue->mem_buffer);
-		k_free(msg_queue->mem_obj);
-	}
-}
-
-static void remove_notification(mqueue_object *msg_queue)
-{
-	k_sem_take(&mq_sem, K_FOREVER);
-	memset(&msg_queue->not, 0, sizeof(struct sigevent));
-	k_sem_give(&mq_sem);
-}
diff --git a/lib/posix/options/multi_process.c b/lib/posix/options/multi_process.c
deleted file mode 100644
index 81e8652e9c5..00000000000
--- a/lib/posix/options/multi_process.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <sys/times.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <zephyr/kernel.h>
-#include <zephyr/sys/clock.h>
-#include <zephyr/sys/time_units.h>
-#include <zephyr/sys/util.h>
-#include <zephyr/toolchain.h>
-
-pid_t getpid(void)
-{
-	/*
-	 * To maintain compatibility with some other POSIX operating systems,
-	 * a PID of zero is used to indicate that the process exists in another namespace.
-	 * PID zero is also used by the scheduler in some cases.
-	 * PID one is usually reserved for the init process.
-	 * Also note, that negative PIDs may be used by kill()
-	 * to send signals to process groups in some implementations.
-	 *
-	 * At the moment, getpid just returns an arbitrary number >= 2
-	 */
-
-	return 42;
-}
-#ifdef CONFIG_POSIX_MULTI_PROCESS_ALIAS_GETPID
-FUNC_ALIAS(getpid, _getpid, pid_t);
-#endif /* CONFIG_POSIX_MULTI_PROCESS_ALIAS_GETPID */
-
-clock_t times(struct tms *buffer)
-{
-	int ret;
-	clock_t utime; /* user time */
-	k_thread_runtime_stats_t stats;
-
-	ret = k_thread_runtime_stats_all_get(&stats);
-	if (ret < 0) {
-		errno = -ret;
-		return (clock_t)-1;
-	}
-
-	utime = z_tmcvt(stats.total_cycles, sys_clock_hw_cycles_per_sec(), USEC_PER_SEC,
-			IS_ENABLED(CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME) ? false : true,
-			sizeof(clock_t) == sizeof(uint32_t), false, false);
-
-	*buffer = (struct tms){
-		.tms_utime = utime,
-		.tms_stime = 0,
-		.tms_cutime = 0,
-		.tms_cstime = 0,
-	};
-
-	return utime;
-}
diff --git a/lib/posix/options/mutex.c b/lib/posix/options/mutex.c
deleted file mode 100644
index 9b46110ea48..00000000000
--- a/lib/posix/options/mutex.c
+++ /dev/null
@@ -1,485 +0,0 @@
-/*
- * Copyright (c) 2017 Intel Corporation
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-#include "posix_internal.h"
-
-#include <pthread.h>
-#include <sys/types.h>
-
-#include <zephyr/init.h>
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <zephyr/sys/bitarray.h>
-#include <zephyr/sys/sem.h>
-
-LOG_MODULE_REGISTER(pthread_mutex, CONFIG_PTHREAD_MUTEX_LOG_LEVEL);
-
-static SYS_SEM_DEFINE(lock, 1, 1);
-
-#define MUTEX_MAX_REC_LOCK 32767
-
-struct pthread_mutexattr {
-	unsigned char type: 2;
-	bool initialized: 1;
-};
-BUILD_ASSERT(sizeof(pthread_mutexattr_t) >= sizeof(struct pthread_mutexattr));
-
-/*
- *  Default mutex attrs.
- */
-static const struct pthread_mutexattr def_attr = {
-	.type = PTHREAD_MUTEX_DEFAULT,
-};
-
-__pinned_bss
-static struct k_mutex posix_mutex_pool[CONFIG_MAX_PTHREAD_MUTEX_COUNT];
-
-static uint8_t posix_mutex_type[CONFIG_MAX_PTHREAD_MUTEX_COUNT];
-SYS_BITARRAY_DEFINE_STATIC(posix_mutex_bitarray, CONFIG_MAX_PTHREAD_MUTEX_COUNT);
-
-/*
- * We reserve the MSB to mark a pthread_mutex_t as initialized (from the
- * perspective of the application). With a linear space, this means that
- * the theoretical pthread_mutex_t range is [0,2147483647].
- */
-BUILD_ASSERT(CONFIG_MAX_PTHREAD_MUTEX_COUNT < PTHREAD_OBJ_MASK_INIT,
-	"CONFIG_MAX_PTHREAD_MUTEX_COUNT is too high");
-
-static inline size_t posix_mutex_to_offset(struct k_mutex *m)
-{
-	return m - posix_mutex_pool;
-}
-
-static inline size_t to_posix_mutex_idx(pthread_mutex_t mut)
-{
-	return mark_pthread_obj_uninitialized(mut);
-}
-
-static struct k_mutex *get_posix_mutex(pthread_mutex_t mu)
-{
-	int actually_initialized;
-	size_t bit = to_posix_mutex_idx(mu);
-
-	/* if the provided mutex does not claim to be initialized, its invalid */
-	if (!is_pthread_obj_initialized(mu)) {
-		LOG_DBG("Mutex is uninitialized (%x)", mu);
-		return NULL;
-	}
-
-	/* Mask off the MSB to get the actual bit index */
-	if (sys_bitarray_test_bit(&posix_mutex_bitarray, bit, &actually_initialized) < 0) {
-		LOG_DBG("Mutex is invalid (%x)", mu);
-		return NULL;
-	}
-
-	if (actually_initialized == 0) {
-		/* The mutex claims to be initialized but is actually not */
-		LOG_DBG("Mutex claims to be initialized (%x)", mu);
-		return NULL;
-	}
-
-	return &posix_mutex_pool[bit];
-}
-
-struct k_mutex *to_posix_mutex(pthread_mutex_t *mu)
-{
-	int err;
-	size_t bit;
-	struct k_mutex *m;
-
-	if (*mu != PTHREAD_MUTEX_INITIALIZER) {
-		return get_posix_mutex(*mu);
-	}
-
-	/* Try and automatically associate a posix_mutex */
-	if (sys_bitarray_alloc(&posix_mutex_bitarray, 1, &bit) < 0) {
-		LOG_DBG("Unable to allocate pthread_mutex_t");
-		return NULL;
-	}
-
-	/* Record the associated posix_mutex in mu and mark as initialized */
-	*mu = mark_pthread_obj_initialized(bit);
-
-	/* Initialize the posix_mutex */
-	m = &posix_mutex_pool[bit];
-
-	err = k_mutex_init(m);
-	__ASSERT_NO_MSG(err == 0);
-
-	return m;
-}
-
-static int acquire_mutex(pthread_mutex_t *mu, k_timeout_t timeout)
-{
-	int type = -1;
-	size_t bit = -1;
-	int ret = EINVAL;
-	size_t lock_count = -1;
-	struct k_mutex *m = NULL;
-	struct k_thread *owner = NULL;
-
-	SYS_SEM_LOCK(&lock) {
-		m = to_posix_mutex(mu);
-		if (m == NULL) {
-			ret = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		LOG_DBG("Locking mutex %p with timeout %" PRIx64, m, (int64_t)timeout.ticks);
-
-		ret = 0;
-		bit = posix_mutex_to_offset(m);
-		type = posix_mutex_type[bit];
-		owner = m->owner;
-		lock_count = m->lock_count;
-	}
-
-	if (ret != 0) {
-		goto handle_error;
-	}
-
-	if (owner == k_current_get()) {
-		switch (type) {
-		case PTHREAD_MUTEX_DEFAULT:
-		case PTHREAD_MUTEX_NORMAL:
-			if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
-				LOG_DBG("Timeout locking mutex %p", m);
-				ret = EBUSY;
-				break;
-			}
-			/* On most POSIX systems, this usually results in an infinite loop */
-			LOG_DBG("Attempt to relock non-recursive mutex %p", m);
-			do {
-				(void)k_sleep(K_FOREVER);
-			} while (true);
-			CODE_UNREACHABLE;
-			break;
-		case PTHREAD_MUTEX_RECURSIVE:
-			if (lock_count >= MUTEX_MAX_REC_LOCK) {
-				LOG_DBG("Mutex %p locked recursively too many times", m);
-				ret = EAGAIN;
-			}
-			break;
-		case PTHREAD_MUTEX_ERRORCHECK:
-			LOG_DBG("Attempt to recursively lock non-recursive mutex %p", m);
-			ret = EDEADLK;
-			break;
-		default:
-			__ASSERT(false, "invalid pthread type %d", type);
-			ret = EINVAL;
-			break;
-		}
-	}
-
-	if (ret == 0) {
-		ret = k_mutex_lock(m, timeout);
-		if (ret == -EAGAIN) {
-			LOG_DBG("Timeout locking mutex %p", m);
-			/*
-			 * special quirk - k_mutex_lock() returns EAGAIN if a timeout occurs, but
-			 * for pthreads, that means something different
-			 */
-			ret = ETIMEDOUT;
-		}
-	}
-
-handle_error:
-	if (ret < 0) {
-		LOG_DBG("k_mutex_unlock() failed: %d", ret);
-		ret = -ret;
-	}
-
-	if (ret == 0) {
-		LOG_DBG("Locked mutex %p", m);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Lock POSIX mutex with non-blocking call.
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_trylock(pthread_mutex_t *m)
-{
-	return acquire_mutex(m, K_NO_WAIT);
-}
-
-/**
- * @brief Lock POSIX mutex with timeout.
- *
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_timedlock(pthread_mutex_t *m,
-			    const struct timespec *abstime)
-{
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		LOG_DBG("%s is invalid", "abstime");
-		return EINVAL;
-	}
-
-	return acquire_mutex(m, K_MSEC(timespec_to_timeoutms(CLOCK_REALTIME, abstime)));
-}
-
-/**
- * @brief Initialize POSIX mutex.
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_init(pthread_mutex_t *mu, const pthread_mutexattr_t *_attr)
-{
-	size_t bit;
-	struct k_mutex *m;
-	const struct pthread_mutexattr *attr = (const struct pthread_mutexattr *)_attr;
-
-	*mu = PTHREAD_MUTEX_INITIALIZER;
-
-	m = to_posix_mutex(mu);
-	if (m == NULL) {
-		return ENOMEM;
-	}
-
-	bit = posix_mutex_to_offset(m);
-	if (attr == NULL) {
-		posix_mutex_type[bit] = def_attr.type;
-	} else {
-		posix_mutex_type[bit] = attr->type;
-	}
-
-	LOG_DBG("Initialized mutex %p", m);
-
-	return 0;
-}
-
-
-/**
- * @brief Lock POSIX mutex with blocking call.
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_lock(pthread_mutex_t *m)
-{
-	return acquire_mutex(m, K_FOREVER);
-}
-
-/**
- * @brief Unlock POSIX mutex.
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_unlock(pthread_mutex_t *mu)
-{
-	int ret;
-	struct k_mutex *m;
-
-	m = get_posix_mutex(*mu);
-	if (m == NULL) {
-		return EINVAL;
-	}
-
-	ret = k_mutex_unlock(m);
-	if (ret < 0) {
-		LOG_DBG("k_mutex_unlock() failed: %d", ret);
-		return -ret;
-	}
-
-	__ASSERT_NO_MSG(ret == 0);
-	LOG_DBG("Unlocked mutex %p", m);
-
-	return 0;
-}
-
-/**
- * @brief Destroy POSIX mutex.
- *
- * See IEEE 1003.1
- */
-int pthread_mutex_destroy(pthread_mutex_t *mu)
-{
-	int err;
-	size_t bit;
-	struct k_mutex *m;
-
-	m = get_posix_mutex(*mu);
-	if (m == NULL) {
-		return EINVAL;
-	}
-
-	bit = to_posix_mutex_idx(*mu);
-	err = sys_bitarray_free(&posix_mutex_bitarray, 1, bit);
-	__ASSERT_NO_MSG(err == 0);
-
-	LOG_DBG("Destroyed mutex %p", m);
-
-	return 0;
-}
-
-#if defined(_POSIX_THREAD_PRIO_PROTECT)
-/**
- * @brief Read protocol attribute for mutex.
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *attr,
-				  int *protocol)
-{
-	if ((attr == NULL) || (protocol == NULL)) {
-		return EINVAL;
-	}
-
-	*protocol = PTHREAD_PRIO_NONE;
-	return 0;
-}
-
-/**
- * @brief Set protocol attribute for mutex.
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_setprotocol(pthread_mutexattr_t *attr, int protocol)
-{
-	if (attr == NULL) {
-		return EINVAL;
-	}
-
-	switch (protocol) {
-	case PTHREAD_PRIO_NONE:
-		return 0;
-	case PTHREAD_PRIO_INHERIT:
-		return ENOTSUP;
-	case PTHREAD_PRIO_PROTECT:
-		return ENOTSUP;
-	default:
-		return EINVAL;
-	}
-}
-#endif
-
-int pthread_mutexattr_init(pthread_mutexattr_t *attr)
-{
-	struct pthread_mutexattr *const a = (struct pthread_mutexattr *)attr;
-
-	if (a == NULL) {
-		return EINVAL;
-	}
-
-	a->type = PTHREAD_MUTEX_DEFAULT;
-	a->initialized = true;
-
-	return 0;
-}
-
-int pthread_mutexattr_destroy(pthread_mutexattr_t *attr)
-{
-	struct pthread_mutexattr *const a = (struct pthread_mutexattr *)attr;
-
-	if (a == NULL || !a->initialized) {
-		return EINVAL;
-	}
-
-	*a = (struct pthread_mutexattr){0};
-
-	return 0;
-}
-
-/**
- * @brief Read type attribute for mutex.
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type)
-{
-	const struct pthread_mutexattr *a = (const struct pthread_mutexattr *)attr;
-
-	if (a == NULL || type == NULL || !a->initialized) {
-		return EINVAL;
-	}
-
-	*type = a->type;
-
-	return 0;
-}
-
-/**
- * @brief Set type attribute for mutex.
- *
- * See IEEE 1003.1
- */
-int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type)
-{
-	struct pthread_mutexattr *const a = (struct pthread_mutexattr *)attr;
-
-	if (a == NULL || !a->initialized) {
-		return EINVAL;
-	}
-
-	switch (type) {
-	case PTHREAD_MUTEX_NORMAL:
-	case PTHREAD_MUTEX_RECURSIVE:
-	case PTHREAD_MUTEX_ERRORCHECK:
-	case PTHREAD_MUTEX_DEFAULT:
-		a->type = type;
-		return 0;
-	default:
-		return EINVAL;
-	}
-}
-
-#ifdef CONFIG_POSIX_THREAD_PRIO_PROTECT
-int pthread_mutex_getprioceiling(const pthread_mutex_t *mutex, int *prioceiling)
-{
-	ARG_UNUSED(mutex);
-	ARG_UNUSED(prioceiling);
-
-	return ENOSYS;
-}
-
-int pthread_mutex_setprioceiling(pthread_mutex_t *mutex, int prioceiling, int *old_ceiling)
-{
-	ARG_UNUSED(mutex);
-	ARG_UNUSED(prioceiling);
-	ARG_UNUSED(old_ceiling);
-
-	return ENOSYS;
-}
-
-int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *attr, int *prioceiling)
-{
-	ARG_UNUSED(attr);
-	ARG_UNUSED(prioceiling);
-
-	return ENOSYS;
-}
-
-int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *attr, int prioceiling)
-{
-	ARG_UNUSED(attr);
-	ARG_UNUSED(prioceiling);
-
-	return ENOSYS;
-}
-
-#endif /* CONFIG_POSIX_THREAD_PRIO_PROTECT */
-
-__boot_func
-static int pthread_mutex_pool_init(void)
-{
-	int err;
-	size_t i;
-
-	for (i = 0; i < CONFIG_MAX_PTHREAD_MUTEX_COUNT; ++i) {
-		err = k_mutex_init(&posix_mutex_pool[i]);
-		__ASSERT_NO_MSG(err == 0);
-		posix_mutex_type[i] = PTHREAD_MUTEX_DEFAULT;
-	}
-
-	return 0;
-}
-SYS_INIT(pthread_mutex_pool_init, PRE_KERNEL_1, 0);
diff --git a/lib/posix/options/net.c b/lib/posix/options/net.c
deleted file mode 100644
index 9f403aa2d19..00000000000
--- a/lib/posix/options/net.c
+++ /dev/null
@@ -1,407 +0,0 @@
-/*
- * Copyright (c) 2019 Linaro Limited
- * Copyright (c) 2024, Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <ctype.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <zephyr/net/hostname.h>
-#include <zephyr/net/net_if.h>
-#include <zephyr/net/socket.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <net/if.h>
-#include <sys/socket.h>
-
-/* From arpa/inet.h */
-
-in_addr_t inet_addr(const char *cp)
-{
-	unsigned int val = 0;
-	int len = 0;
-	int dots = 0;
-	int digits = 0;
-
-	/* error checking */
-	if (cp == NULL) {
-		return -1;
-	}
-
-	for (int i = 0, subdigits = 0; i <= INET_ADDRSTRLEN; ++i, ++len) {
-		if (subdigits > 3) {
-			return -1;
-		}
-		if (cp[i] == '\0') {
-			break;
-		} else if (cp[i] == '.') {
-			if (subdigits == 0) {
-				return -1;
-			}
-			++dots;
-			subdigits = 0;
-			continue;
-		} else if (isdigit((int)cp[i])) {
-			++digits;
-			++subdigits;
-			continue;
-		} else if (isspace((int)cp[i])) {
-			break;
-		}
-
-		return -1;
-	}
-
-	if (dots != 3 || digits < 4) {
-		return -1;
-	}
-
-	/* conversion */
-	for (int i = 0, tmp = 0; i < len; ++i, ++cp) {
-		if (*cp != '.') {
-			tmp *= 10;
-			tmp += *cp - '0';
-		}
-
-		if (*cp == '.' || i == len - 1) {
-			val <<= 8;
-			val |= tmp;
-			tmp = 0;
-		}
-	}
-
-	return htonl(val);
-}
-
-char *inet_ntoa(struct in_addr in)
-{
-	static char buf[INET_ADDRSTRLEN];
-	unsigned char *bytes = (unsigned char *)&in.s_addr;
-
-	snprintf(buf, sizeof(buf), "%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3]);
-
-	return buf;
-}
-
-char *inet_ntop(sa_family_t family, const void *src, char *dst, size_t size)
-{
-	return zsock_inet_ntop(family, src, dst, size);
-}
-
-int inet_pton(sa_family_t family, const char *src, void *dst)
-{
-	return zsock_inet_pton(family, src, dst);
-}
-
-/* From net/if.h */
-
-char *if_indextoname(unsigned int ifindex, char *ifname)
-{
-	int ret;
-
-	ret = net_if_get_name(net_if_get_by_index(ifindex), ifname, IF_NAMESIZE);
-	if (ret < 0) {
-		errno = ENXIO;
-		return NULL;
-	}
-
-	return ifname;
-}
-
-void if_freenameindex(struct if_nameindex *ptr)
-{
-	size_t n;
-
-	if (ptr == NULL) {
-		return;
-	}
-
-	NET_IFACE_COUNT(&n);
-
-	for (size_t i = 0; i < n; ++i) {
-		if (ptr[i].if_name != NULL) {
-			free(ptr[i].if_name);
-		}
-	}
-
-	free(ptr);
-}
-
-struct if_nameindex *if_nameindex(void)
-{
-	size_t n;
-	char *name;
-	struct if_nameindex *ni;
-
-	/* FIXME: would be nice to use this without malloc */
-	NET_IFACE_COUNT(&n);
-	ni = malloc((n + 1) * sizeof(*ni));
-	if (ni == NULL) {
-		goto return_err;
-	}
-
-	for (size_t i = 0; i < n; ++i) {
-		ni[i].if_index = i + 1;
-
-		ni[i].if_name = malloc(IF_NAMESIZE);
-		if (ni[i].if_name == NULL) {
-			goto return_err;
-		}
-
-		name = if_indextoname(i + 1, ni[i].if_name);
-		__ASSERT_NO_MSG(name != NULL);
-	}
-
-	ni[n].if_index = 0;
-	ni[n].if_name = NULL;
-
-	return ni;
-
-return_err:
-	if_freenameindex(ni);
-	errno = ENOBUFS;
-
-	return NULL;
-}
-
-unsigned int if_nametoindex(const char *ifname)
-{
-	int ret;
-
-	ret = net_if_get_by_name(ifname);
-	if (ret < 0) {
-		return 0;
-	}
-
-	return ret;
-}
-
-/* From netdb.h */
-
-void endhostent(void)
-{
-}
-
-void endnetent(void)
-{
-}
-
-void endprotoent(void)
-{
-}
-
-void endservent(void)
-{
-}
-
-void freeaddrinfo(struct zsock_addrinfo *ai)
-{
-	zsock_freeaddrinfo(ai);
-}
-
-const char *gai_strerror(int errcode)
-{
-	return zsock_gai_strerror(errcode);
-}
-
-int getaddrinfo(const char *host, const char *service, const struct zsock_addrinfo *hints,
-		struct zsock_addrinfo **res)
-{
-	return zsock_getaddrinfo(host, service, hints, res);
-}
-
-struct hostent *gethostent(void)
-{
-	return NULL;
-}
-
-int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen,
-		char *serv, socklen_t servlen, int flags)
-{
-	return zsock_getnameinfo(addr, addrlen, host, hostlen, serv, servlen, flags);
-}
-
-struct netent *getnetbyaddr(uint32_t net, int type)
-{
-	ARG_UNUSED(net);
-	ARG_UNUSED(type);
-
-	return NULL;
-}
-
-struct netent *getnetbyname(const char *name)
-{
-	ARG_UNUSED(name);
-
-	return NULL;
-}
-
-struct netent *getnetent(void)
-{
-	return NULL;
-}
-
-int getpeername(int sock, struct sockaddr *addr, socklen_t *addrlen)
-{
-	return zsock_getpeername(sock, addr, addrlen);
-}
-
-struct protoent *getprotobyname(const char *name)
-{
-	ARG_UNUSED(name);
-
-	return NULL;
-}
-
-struct protoent *getprotobynumber(int proto)
-{
-	ARG_UNUSED(proto);
-
-	return NULL;
-}
-
-struct protoent *getprotoent(void)
-{
-	return NULL;
-}
-
-struct servent *getservbyname(const char *name, const char *proto)
-{
-	ARG_UNUSED(name);
-	ARG_UNUSED(proto);
-
-	return NULL;
-}
-
-struct servent *getservbyport(int port, const char *proto)
-{
-	ARG_UNUSED(port);
-	ARG_UNUSED(proto);
-
-	return NULL;
-}
-
-struct servent *getservent(void)
-{
-	return NULL;
-}
-
-void sethostent(int stayopen)
-{
-	ARG_UNUSED(stayopen);
-}
-
-void setnetent(int stayopen)
-{
-	ARG_UNUSED(stayopen);
-}
-
-void setprotoent(int stayopen)
-{
-	ARG_UNUSED(stayopen);
-}
-
-void setservent(int stayopen)
-{
-	ARG_UNUSED(stayopen);
-}
-
-/* From sys/socket.h */
-
-int accept(int sock, struct sockaddr *addr, socklen_t *addrlen)
-{
-	return zsock_accept(sock, addr, addrlen);
-}
-
-int bind(int sock, const struct sockaddr *addr, socklen_t addrlen)
-{
-	return zsock_bind(sock, addr, addrlen);
-}
-
-int connect(int sock, const struct sockaddr *addr, socklen_t addrlen)
-{
-	return zsock_connect(sock, addr, addrlen);
-}
-
-int gethostname(char *name, size_t namelen)
-{
-	return zsock_gethostname(name, namelen);
-}
-
-int getsockname(int sock, struct sockaddr *addr, socklen_t *addrlen)
-{
-	return zsock_getsockname(sock, addr, addrlen);
-}
-
-int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen)
-{
-	return zsock_getsockopt(sock, level, optname, optval, optlen);
-}
-
-int listen(int sock, int backlog)
-{
-	return zsock_listen(sock, backlog);
-}
-
-ssize_t recv(int sock, void *buf, size_t max_len, int flags)
-{
-	return zsock_recv(sock, buf, max_len, flags);
-}
-
-ssize_t recvfrom(int sock, void *buf, size_t max_len, int flags, struct sockaddr *src_addr,
-		 socklen_t *addrlen)
-{
-	return zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
-}
-
-ssize_t recvmsg(int sock, struct msghdr *msg, int flags)
-{
-	return zsock_recvmsg(sock, msg, flags);
-}
-
-ssize_t send(int sock, const void *buf, size_t len, int flags)
-{
-	return zsock_send(sock, buf, len, flags);
-}
-
-ssize_t sendmsg(int sock, const struct msghdr *message, int flags)
-{
-	return zsock_sendmsg(sock, message, flags);
-}
-
-ssize_t sendto(int sock, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr,
-	       socklen_t addrlen)
-{
-	return zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
-}
-
-int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen)
-{
-	return zsock_setsockopt(sock, level, optname, optval, optlen);
-}
-
-int shutdown(int sock, int how)
-{
-	return zsock_shutdown(sock, how);
-}
-
-int sockatmark(int s)
-{
-	ARG_UNUSED(s);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int socket(int family, int type, int proto)
-{
-	return zsock_socket(family, type, proto);
-}
-
-int socketpair(int family, int type, int proto, int sv[2])
-{
-	return zsock_socketpair(family, type, proto, sv);
-}
diff --git a/lib/posix/options/perror.c b/lib/posix/options/perror.c
deleted file mode 100644
index 5e237d1428f..00000000000
--- a/lib/posix/options/perror.c
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
-
-/*
- * See https://pubs.opengroup.org/onlinepubs/9699919799/functions/perror.html
- */
-void perror(const char *s)
-{
-	fprintf(stderr, "%s%s%s\n", s == NULL ? "" : s, s == NULL ? "" : ": ",
-		strerror(errno));
-}
diff --git a/lib/posix/options/posix_clock.h b/lib/posix/options/posix_clock.h
deleted file mode 100644
index d2b72f4d885..00000000000
--- a/lib/posix/options/posix_clock.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_LIB_POSIX_POSIX_CLOCK_H_
-#define ZEPHYR_LIB_POSIX_POSIX_CLOCK_H_
-
-#include <errno.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <time.h>
-
-#include <sys/time.h>
-#include <zephyr/sys/clock.h>
-#include <zephyr/sys/timeutil.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** @cond INTERNAL_HIDDEN */
-
-static inline int64_t ts_to_ns(const struct timespec *ts)
-{
-	return ts->tv_sec * NSEC_PER_SEC + ts->tv_nsec;
-}
-
-static inline int64_t ts_to_ms(const struct timespec *ts)
-{
-	return ts->tv_sec * MSEC_PER_SEC + ts->tv_nsec / NSEC_PER_MSEC;
-}
-
-static inline void tv_to_ts(const struct timeval *tv, struct timespec *ts)
-{
-	ts->tv_sec = tv->tv_sec;
-	ts->tv_nsec = tv->tv_usec * NSEC_PER_USEC;
-}
-
-static inline bool tp_ge(const struct timespec *a, const struct timespec *b)
-{
-	return timespec_compare(a, b) >= 0;
-}
-
-static inline int64_t tp_diff(const struct timespec *a, const struct timespec *b)
-{
-	return ts_to_ns(a) - ts_to_ns(b);
-}
-
-/* lo <= (a - b) < hi */
-static inline bool tp_diff_in_range_ns(const struct timespec *a, const struct timespec *b,
-				       int64_t lo, int64_t hi)
-{
-	int64_t diff = tp_diff(a, b);
-
-	return diff >= lo && diff < hi;
-}
-
-uint32_t timespec_to_timeoutms(int clock_id, const struct timespec *abstime);
-
-/* Convert a POSIX clock (cast to int) to a sys_clock identifier */
-static inline int sys_clock_from_clockid(int clock_id)
-{
-	switch (clock_id) {
-	case (int)CLOCK_REALTIME:
-		return SYS_CLOCK_REALTIME;
-#if defined(_POSIX_MONOTONIC_CLOCK)
-	case (int)CLOCK_MONOTONIC:
-		return SYS_CLOCK_MONOTONIC;
-#endif
-	default:
-		return -EINVAL;
-	}
-}
-
-/** INTERNAL_HIDDEN @endcond */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/lib/posix/options/posix_internal.h b/lib/posix/options/posix_internal.h
deleted file mode 100644
index 3cd8e3f324d..00000000000
--- a/lib/posix/options/posix_internal.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_LIB_POSIX_POSIX_INTERNAL_H_
-#define ZEPHYR_LIB_POSIX_POSIX_INTERNAL_H_
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <signal.h>
-
-#include <zephyr/kernel.h>
-#include <pthread.h>
-#include <zephyr/sys/dlist.h>
-#include <zephyr/sys/slist.h>
-
-/*
- * Bit used to mark a pthread object as initialized. Initialization status is
- * verified (against internal status) in lock / unlock / destroy functions.
- */
-#define PTHREAD_OBJ_MASK_INIT 0x80000000
-
-#ifdef CONFIG_RX
-struct __packed posix_thread_attr
-#else
-struct posix_thread_attr
-#endif
-{
-	void *stack;
-	/* the following two bitfields should combine to be 32-bits in size */
-	uint32_t stacksize: CONFIG_POSIX_PTHREAD_ATTR_STACKSIZE_BITS;
-	uint16_t guardsize: CONFIG_POSIX_PTHREAD_ATTR_GUARDSIZE_BITS;
-	int8_t priority;
-	uint8_t schedpolicy: 2;
-	bool contentionscope: 1;
-	bool inheritsched: 1;
-	union {
-		bool caller_destroys: 1;
-		bool initialized: 1;
-	};
-	bool cancelpending: 1;
-	bool cancelstate: 1;
-	bool canceltype: 1;
-	bool detachstate: 1;
-};
-
-struct posix_thread {
-	struct k_thread thread;
-
-	/* List nodes for pthread_cleanup_push() / pthread_cleanup_pop() */
-	sys_slist_t cleanup_list;
-
-	/* List node for ready_q, run_q, or done_q */
-	sys_dnode_t q_node;
-
-	/* List of keys that thread has called pthread_setspecific() on */
-	sys_slist_t key_list;
-
-	/* pthread_attr_t */
-	struct posix_thread_attr attr;
-
-	/* Exit status */
-	void *retval;
-
-	/* Signal mask */
-	sigset_t sigset;
-
-	/* Queue ID (internal-only) */
-	uint8_t qid;
-};
-
-struct posix_condattr {
-	/* leaves room for CLOCK_REALTIME (1, default) and CLOCK_MONOTONIC (4) */
-	unsigned char clock: 3;
-	char initialized: 1;
-#ifdef _POSIX_THREAD_PROCESS_SHARED
-	unsigned char pshared: 1;
-#endif
-};
-
-struct pthread_once {
-	bool flag;
-};
-BUILD_ASSERT(sizeof(pthread_once_t) >= sizeof(struct pthread_once));
-
-struct posix_cond {
-	struct k_condvar condvar;
-	struct posix_condattr attr;
-};
-
-typedef struct pthread_key_obj {
-	/* List of pthread_key_data objects that contain thread
-	 * specific data for the key
-	 */
-	sys_slist_t key_data_l;
-
-	/* Optional destructor that is passed to pthread_key_create() */
-	void (*destructor)(void *value);
-} pthread_key_obj;
-
-typedef struct pthread_thread_data {
-	sys_snode_t node;
-
-	/* Key and thread specific data passed to pthread_setspecific() */
-	pthread_key_obj *key;
-	void *spec_data;
-} pthread_thread_data;
-
-struct pthread_key_data {
-	sys_snode_t node;
-	pthread_thread_data thread_data;
-};
-
-static inline bool is_pthread_obj_initialized(uint32_t obj)
-{
-	return (obj & PTHREAD_OBJ_MASK_INIT) != 0;
-}
-
-static inline uint32_t mark_pthread_obj_initialized(uint32_t obj)
-{
-	return obj | PTHREAD_OBJ_MASK_INIT;
-}
-
-static inline uint32_t mark_pthread_obj_uninitialized(uint32_t obj)
-{
-	return obj & ~PTHREAD_OBJ_MASK_INIT;
-}
-
-struct posix_thread *to_posix_thread(pthread_t pth);
-
-/* get and possibly initialize a posix_mutex */
-struct k_mutex *to_posix_mutex(pthread_mutex_t *mu);
-
-int posix_to_zephyr_priority(int priority, int policy);
-int zephyr_to_posix_priority(int priority, int *policy);
-
-#endif
diff --git a/lib/posix/options/pthread.c b/lib/posix/options/pthread.c
deleted file mode 100644
index 9df377adc5b..00000000000
--- a/lib/posix/options/pthread.c
+++ /dev/null
@@ -1,1578 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-#include "posix_internal.h"
-#include "pthread_sched.h"
-
-#include <stdio.h>
-
-#include <zephyr/init.h>
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <zephyr/sys/atomic.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <zephyr/sys/sem.h>
-#include <zephyr/sys/slist.h>
-#include <zephyr/sys/util.h>
-
-#define ZEPHYR_TO_POSIX_PRIORITY(_zprio)                                                           \
-	(((_zprio) < 0) ? (-1 * ((_zprio) + 1)) : (CONFIG_NUM_PREEMPT_PRIORITIES - (_zprio)-1))
-
-#define POSIX_TO_ZEPHYR_PRIORITY(_prio, _pol)                                                      \
-	(((_pol) == SCHED_FIFO) ? (-1 * ((_prio) + 1))                                             \
-				: (CONFIG_NUM_PREEMPT_PRIORITIES - (_prio)-1))
-
-#define DEFAULT_PTHREAD_PRIORITY                                                                   \
-	POSIX_TO_ZEPHYR_PRIORITY(K_LOWEST_APPLICATION_THREAD_PRIO, DEFAULT_PTHREAD_POLICY)
-#define DEFAULT_PTHREAD_POLICY (IS_ENABLED(CONFIG_PREEMPT_ENABLED) ? SCHED_RR : SCHED_FIFO)
-
-#define PTHREAD_STACK_MAX BIT(CONFIG_POSIX_PTHREAD_ATTR_STACKSIZE_BITS)
-#define PTHREAD_GUARD_MAX BIT_MASK(CONFIG_POSIX_PTHREAD_ATTR_GUARDSIZE_BITS)
-
-LOG_MODULE_REGISTER(pthread, CONFIG_PTHREAD_LOG_LEVEL);
-
-#ifdef CONFIG_DYNAMIC_THREAD_STACK_SIZE
-#define DYNAMIC_STACK_SIZE CONFIG_DYNAMIC_THREAD_STACK_SIZE
-#else
-#define DYNAMIC_STACK_SIZE 0
-#endif
-
-static inline size_t __get_attr_stacksize(const struct posix_thread_attr *attr)
-{
-	return attr->stacksize + 1;
-}
-
-static inline void __set_attr_stacksize(struct posix_thread_attr *attr, size_t stacksize)
-{
-	attr->stacksize = stacksize - 1;
-}
-
-struct __pthread_cleanup {
-	void (*routine)(void *arg);
-	void *arg;
-	sys_snode_t node;
-};
-
-enum posix_thread_qid {
-	/* ready to be started via pthread_create() */
-	POSIX_THREAD_READY_Q,
-	/* running */
-	POSIX_THREAD_RUN_Q,
-	/* exited (either joinable or detached) */
-	POSIX_THREAD_DONE_Q,
-	/* invalid */
-	POSIX_THREAD_INVALID_Q,
-};
-
-/* only 2 bits in struct posix_thread_attr for schedpolicy */
-BUILD_ASSERT(SCHED_OTHER < BIT(2) && SCHED_FIFO < BIT(2) && SCHED_RR < BIT(2));
-
-BUILD_ASSERT((PTHREAD_CREATE_DETACHED == 0 || PTHREAD_CREATE_JOINABLE == 0) &&
-	     (PTHREAD_CREATE_DETACHED == 1 || PTHREAD_CREATE_JOINABLE == 1));
-
-BUILD_ASSERT((PTHREAD_CANCEL_ENABLE == 0 || PTHREAD_CANCEL_DISABLE == 0) &&
-	     (PTHREAD_CANCEL_ENABLE == 1 || PTHREAD_CANCEL_DISABLE == 1));
-
-BUILD_ASSERT(CONFIG_POSIX_PTHREAD_ATTR_STACKSIZE_BITS + CONFIG_POSIX_PTHREAD_ATTR_GUARDSIZE_BITS <=
-	     32);
-
-static void posix_thread_recycle(void);
-
-__pinned_data
-static sys_dlist_t posix_thread_q[] = {
-	SYS_DLIST_STATIC_INIT(&posix_thread_q[POSIX_THREAD_READY_Q]),
-	SYS_DLIST_STATIC_INIT(&posix_thread_q[POSIX_THREAD_RUN_Q]),
-	SYS_DLIST_STATIC_INIT(&posix_thread_q[POSIX_THREAD_DONE_Q]),
-};
-
-static __pinned_bss struct posix_thread posix_thread_pool[CONFIG_POSIX_THREAD_THREADS_MAX];
-
-static SYS_SEM_DEFINE(pthread_pool_lock, 1, 1);
-static int pthread_concurrency;
-
-static inline void posix_thread_q_set(struct posix_thread *t, enum posix_thread_qid qid)
-{
-	switch (qid) {
-	case POSIX_THREAD_READY_Q:
-	case POSIX_THREAD_RUN_Q:
-	case POSIX_THREAD_DONE_Q:
-		sys_dlist_append(&posix_thread_q[qid], &t->q_node);
-		t->qid = qid;
-		break;
-	default:
-		__ASSERT(false, "cannot set invalid qid %d for posix thread %p", qid, t);
-		break;
-	}
-}
-
-static inline enum posix_thread_qid posix_thread_q_get(struct posix_thread *t)
-{
-	switch (t->qid) {
-	case POSIX_THREAD_READY_Q:
-	case POSIX_THREAD_RUN_Q:
-	case POSIX_THREAD_DONE_Q:
-		return t->qid;
-	default:
-		__ASSERT(false, "posix thread %p has invalid qid: %d", t, t->qid);
-		return POSIX_THREAD_INVALID_Q;
-	}
-}
-
-/*
- * We reserve the MSB to mark a pthread_t as initialized (from the
- * perspective of the application). With a linear space, this means that
- * the theoretical pthread_t range is [0,2147483647].
- */
-BUILD_ASSERT(CONFIG_POSIX_THREAD_THREADS_MAX < PTHREAD_OBJ_MASK_INIT,
-	     "CONFIG_POSIX_THREAD_THREADS_MAX is too high");
-
-static inline size_t posix_thread_to_offset(struct posix_thread *t)
-{
-	return t - posix_thread_pool;
-}
-
-static inline size_t get_posix_thread_idx(pthread_t pth)
-{
-	return mark_pthread_obj_uninitialized(pth);
-}
-
-struct posix_thread *to_posix_thread(pthread_t pthread)
-{
-	struct posix_thread *t;
-	bool actually_initialized;
-	size_t bit = get_posix_thread_idx(pthread);
-
-	/* if the provided thread does not claim to be initialized, its invalid */
-	if (!is_pthread_obj_initialized(pthread)) {
-		LOG_DBG("pthread is not initialized (%x)", pthread);
-		return NULL;
-	}
-
-	if (bit >= ARRAY_SIZE(posix_thread_pool)) {
-		LOG_DBG("Invalid pthread (%x)", pthread);
-		return NULL;
-	}
-
-	t = &posix_thread_pool[bit];
-
-	/*
-	 * Denote a pthread as "initialized" (i.e. allocated) if it is not in ready_q.
-	 * This differs from other posix object allocation strategies because they use
-	 * a bitarray to indicate whether an object has been allocated.
-	 */
-	actually_initialized = !(posix_thread_q_get(t) == POSIX_THREAD_READY_Q ||
-				 (posix_thread_q_get(t) == POSIX_THREAD_DONE_Q &&
-				  t->attr.detachstate == PTHREAD_CREATE_DETACHED));
-
-	if (!actually_initialized) {
-		LOG_DBG("Pthread claims to be initialized (%x)", pthread);
-		return NULL;
-	}
-
-	return &posix_thread_pool[bit];
-}
-
-pthread_t pthread_self(void)
-{
-	size_t bit;
-	struct posix_thread *t;
-
-	t = (struct posix_thread *)CONTAINER_OF(k_current_get(), struct posix_thread, thread);
-	bit = posix_thread_to_offset(t);
-
-	return mark_pthread_obj_initialized(bit);
-}
-
-int pthread_equal(pthread_t pt1, pthread_t pt2)
-{
-	return (pt1 == pt2);
-}
-
-static inline void __z_pthread_cleanup_init(struct __pthread_cleanup *c, void (*routine)(void *arg),
-					    void *arg)
-{
-	*c = (struct __pthread_cleanup){
-		.routine = routine,
-		.arg = arg,
-		.node = {0},
-	};
-}
-
-void __z_pthread_cleanup_push(void *cleanup[3], void (*routine)(void *arg), void *arg)
-{
-	struct posix_thread *t = NULL;
-	struct __pthread_cleanup *const c = (struct __pthread_cleanup *)cleanup;
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread_self());
-		BUILD_ASSERT(3 * sizeof(void *) == sizeof(*c));
-		__ASSERT_NO_MSG(t != NULL);
-		__ASSERT_NO_MSG(c != NULL);
-		__ASSERT_NO_MSG(routine != NULL);
-		__z_pthread_cleanup_init(c, routine, arg);
-		sys_slist_prepend(&t->cleanup_list, &c->node);
-	}
-}
-
-void __z_pthread_cleanup_pop(int execute)
-{
-	sys_snode_t *node;
-	struct __pthread_cleanup *c = NULL;
-	struct posix_thread *t = NULL;
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread_self());
-		__ASSERT_NO_MSG(t != NULL);
-		node = sys_slist_get(&t->cleanup_list);
-		__ASSERT_NO_MSG(node != NULL);
-		c = CONTAINER_OF(node, struct __pthread_cleanup, node);
-		__ASSERT_NO_MSG(c != NULL);
-		__ASSERT_NO_MSG(c->routine != NULL);
-	}
-	if (execute) {
-		c->routine(c->arg);
-	}
-}
-
-static bool is_posix_policy_prio_valid(int priority, int policy)
-{
-	if (priority >= posix_sched_priority_min(policy) &&
-	    priority <= posix_sched_priority_max(policy)) {
-		return true;
-	}
-
-	LOG_DBG("Invalid priority %d and / or policy %d", priority, policy);
-
-	return false;
-}
-
-/* Non-static so that they can be tested in ztest */
-int zephyr_to_posix_priority(int z_prio, int *policy)
-{
-	int priority;
-
-	if (z_prio < 0) {
-		__ASSERT_NO_MSG(-z_prio <= CONFIG_NUM_COOP_PRIORITIES);
-	} else {
-		__ASSERT_NO_MSG(z_prio < CONFIG_NUM_PREEMPT_PRIORITIES);
-	}
-
-	*policy = (z_prio < 0) ? SCHED_FIFO : SCHED_RR;
-	priority = ZEPHYR_TO_POSIX_PRIORITY(z_prio);
-	__ASSERT_NO_MSG(is_posix_policy_prio_valid(priority, *policy));
-
-	return priority;
-}
-
-/* Non-static so that they can be tested in ztest */
-int posix_to_zephyr_priority(int priority, int policy)
-{
-	__ASSERT_NO_MSG(is_posix_policy_prio_valid(priority, policy));
-
-	return POSIX_TO_ZEPHYR_PRIORITY(priority, policy);
-}
-
-static bool __attr_is_runnable(const struct posix_thread_attr *attr)
-{
-	size_t stacksize;
-
-	if (attr == NULL || attr->stack == NULL) {
-		LOG_DBG("attr %p is not initialized", attr);
-		return false;
-	}
-
-	stacksize = __get_attr_stacksize(attr);
-	if (stacksize < PTHREAD_STACK_MIN) {
-		LOG_DBG("attr %p has stacksize %zu is smaller than PTHREAD_STACK_MIN (%zu)", attr,
-			stacksize, (size_t)PTHREAD_STACK_MIN);
-		return false;
-	}
-
-	/* require a valid scheduler policy */
-	if (!valid_posix_policy(attr->schedpolicy)) {
-		LOG_DBG("Invalid scheduler policy %d", attr->schedpolicy);
-		return false;
-	}
-
-	return true;
-}
-
-static bool __attr_is_initialized(const struct posix_thread_attr *attr)
-{
-	if (IS_ENABLED(CONFIG_DYNAMIC_THREAD)) {
-		return __attr_is_runnable(attr);
-	}
-
-	if (attr == NULL || !attr->initialized) {
-		LOG_DBG("attr %p is not initialized", attr);
-		return false;
-	}
-
-	return true;
-}
-
-/**
- * @brief Set scheduling parameter attributes in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_setschedparam(pthread_attr_t *_attr, const struct sched_param *schedparam)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || schedparam == NULL ||
-	    !is_posix_policy_prio_valid(schedparam->sched_priority, attr->schedpolicy)) {
-		LOG_DBG("Invalid pthread_attr_t or sched_param");
-		return EINVAL;
-	}
-
-	attr->priority = schedparam->sched_priority;
-	return 0;
-}
-
-/**
- * @brief Set stack attributes in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_setstack(pthread_attr_t *_attr, void *stackaddr, size_t stacksize)
-{
-	int ret;
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (stackaddr == NULL) {
-		LOG_DBG("NULL stack address");
-		return EACCES;
-	}
-
-	if (!__attr_is_initialized(attr) || stacksize == 0 || stacksize < PTHREAD_STACK_MIN ||
-	    stacksize > PTHREAD_STACK_MAX) {
-		LOG_DBG("Invalid stacksize %zu", stacksize);
-		return EINVAL;
-	}
-
-	if (attr->stack != NULL) {
-		ret = k_thread_stack_free(attr->stack);
-		if (ret == 0) {
-			LOG_DBG("Freed attr %p thread stack %zu@%p", _attr,
-				__get_attr_stacksize(attr), attr->stack);
-		}
-	}
-
-	attr->stack = stackaddr;
-	__set_attr_stacksize(attr, stacksize);
-
-	LOG_DBG("Assigned thread stack %zu@%p to attr %p", __get_attr_stacksize(attr), attr->stack,
-		_attr);
-
-	return 0;
-}
-
-/**
- * @brief Get scope attributes in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_getscope(const pthread_attr_t *_attr, int *contentionscope)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || contentionscope == NULL) {
-		return EINVAL;
-	}
-	*contentionscope = attr->contentionscope;
-	return 0;
-}
-
-/**
- * @brief Set scope attributes in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_setscope(pthread_attr_t *_attr, int contentionscope)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr)) {
-		LOG_DBG("attr %p is not initialized", attr);
-		return EINVAL;
-	}
-	if (!(contentionscope == PTHREAD_SCOPE_PROCESS ||
-	      contentionscope == PTHREAD_SCOPE_SYSTEM)) {
-		LOG_DBG("%s contentionscope %d", "Invalid", contentionscope);
-		return EINVAL;
-	}
-	if (contentionscope == PTHREAD_SCOPE_PROCESS) {
-		/* Zephyr does not yet support processes or process scheduling */
-		LOG_DBG("%s contentionscope %d", "Unsupported", contentionscope);
-		return ENOTSUP;
-	}
-	attr->contentionscope = contentionscope;
-	return 0;
-}
-
-/**
- * @brief Get inherit scheduler attributes in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_getinheritsched(const pthread_attr_t *_attr, int *inheritsched)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || inheritsched == NULL) {
-		return EINVAL;
-	}
-	*inheritsched = attr->inheritsched;
-	return 0;
-}
-
-/**
- * @brief Set inherit scheduler attributes in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_setinheritsched(pthread_attr_t *_attr, int inheritsched)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr)) {
-		LOG_DBG("attr %p is not initialized", attr);
-		return EINVAL;
-	}
-
-	if (inheritsched != PTHREAD_INHERIT_SCHED && inheritsched != PTHREAD_EXPLICIT_SCHED) {
-		LOG_DBG("Invalid inheritsched %d", inheritsched);
-		return EINVAL;
-	}
-
-	attr->inheritsched = inheritsched;
-	return 0;
-}
-
-static void posix_thread_recycle_work_handler(struct k_work *work)
-{
-	ARG_UNUSED(work);
-	posix_thread_recycle();
-}
-static K_WORK_DELAYABLE_DEFINE(posix_thread_recycle_work, posix_thread_recycle_work_handler);
-
-extern struct sys_sem pthread_key_lock;
-
-static void posix_thread_finalize(struct posix_thread *t, void *retval)
-{
-	sys_snode_t *node_l, *node_s;
-	pthread_key_obj *key_obj;
-	pthread_thread_data *thread_spec_data;
-	sys_snode_t *node_key_data, *node_key_data_s, *node_key_data_prev = NULL;
-	struct pthread_key_data *key_data;
-
-	SYS_SLIST_FOR_EACH_NODE_SAFE(&t->key_list, node_l, node_s) {
-		thread_spec_data = (pthread_thread_data *)node_l;
-		if (thread_spec_data != NULL) {
-			key_obj = thread_spec_data->key;
-			if (key_obj->destructor != NULL) {
-				(key_obj->destructor)(thread_spec_data->spec_data);
-			}
-
-			SYS_SEM_LOCK(&pthread_key_lock) {
-				SYS_SLIST_FOR_EACH_NODE_SAFE(
-					&key_obj->key_data_l,
-					node_key_data,
-					node_key_data_s) {
-					key_data = (struct pthread_key_data *)node_key_data;
-					if (&key_data->thread_data == thread_spec_data) {
-						sys_slist_remove(
-							&key_obj->key_data_l,
-							node_key_data_prev,
-							node_key_data
-						);
-						k_free(key_data);
-						break;
-					}
-					node_key_data_prev = node_key_data;
-				}
-			}
-		}
-	}
-
-	/* move thread from run_q to done_q */
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		sys_dlist_remove(&t->q_node);
-		posix_thread_q_set(t, POSIX_THREAD_DONE_Q);
-		t->retval = retval;
-	}
-
-	/* trigger recycle work */
-	(void)k_work_schedule(&posix_thread_recycle_work, K_MSEC(CONFIG_PTHREAD_RECYCLER_DELAY_MS));
-
-	/* abort the underlying k_thread */
-	k_thread_abort(&t->thread);
-}
-
-FUNC_NORETURN
-static void zephyr_thread_wrapper(void *arg1, void *arg2, void *arg3)
-{
-	void *(*fun_ptr)(void *arg) = arg2;
-	struct posix_thread *t = CONTAINER_OF(k_current_get(), struct posix_thread, thread);
-
-#if defined(CONFIG_PTHREAD_CREATE_BARRIER)
-	int err;
-	int barrier;
-
-	/* cross the barrier so that pthread_create() can continue */
-	barrier = POINTER_TO_UINT(arg3);
-	err = pthread_barrier_wait(&barrier);
-	__ASSERT_NO_MSG(err == 0 || err == PTHREAD_BARRIER_SERIAL_THREAD);
-#endif
-
-	posix_thread_finalize(t, fun_ptr(arg1));
-
-	CODE_UNREACHABLE;
-}
-
-static void posix_thread_recycle(void)
-{
-	struct posix_thread *t;
-	struct posix_thread *safe_t;
-	sys_dlist_t recyclables = SYS_DLIST_STATIC_INIT(&recyclables);
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		SYS_DLIST_FOR_EACH_CONTAINER_SAFE(&posix_thread_q[POSIX_THREAD_DONE_Q], t, safe_t,
-						  q_node) {
-			if (t->attr.detachstate == PTHREAD_CREATE_JOINABLE) {
-				/* thread has not been joined yet */
-				continue;
-			}
-
-			sys_dlist_remove(&t->q_node);
-			sys_dlist_append(&recyclables, &t->q_node);
-		}
-	}
-
-	if (sys_dlist_is_empty(&recyclables)) {
-		return;
-	}
-
-	LOG_DBG("Recycling %zu threads", sys_dlist_len(&recyclables));
-
-	SYS_DLIST_FOR_EACH_CONTAINER(&recyclables, t, q_node) {
-		if (t->attr.caller_destroys) {
-			t->attr = (struct posix_thread_attr){0};
-		} else {
-			(void)pthread_attr_destroy((pthread_attr_t *)&t->attr);
-		}
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		while (!sys_dlist_is_empty(&recyclables)) {
-			t = CONTAINER_OF(sys_dlist_get(&recyclables), struct posix_thread, q_node);
-			posix_thread_q_set(t, POSIX_THREAD_READY_Q);
-		}
-	}
-}
-
-/**
- * @brief Create a new thread.
- *
- * Pthread attribute should not be NULL. API will return Error on NULL
- * attribute value.
- *
- * See IEEE 1003.1
- */
-int pthread_create(pthread_t *th, const pthread_attr_t *_attr, void *(*threadroutine)(void *),
-		   void *arg)
-{
-	int err;
-	void *barrier_ptr = NULL;
-	struct posix_thread *t = NULL;
-
-	if (!(_attr == NULL || __attr_is_runnable((struct posix_thread_attr *)_attr))) {
-		return EINVAL;
-	}
-
-	/* reclaim resources greedily */
-	posix_thread_recycle();
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		if (!sys_dlist_is_empty(&posix_thread_q[POSIX_THREAD_READY_Q])) {
-			t = CONTAINER_OF(sys_dlist_get(&posix_thread_q[POSIX_THREAD_READY_Q]),
-					 struct posix_thread, q_node);
-
-			/* initialize thread state */
-			posix_thread_q_set(t, POSIX_THREAD_RUN_Q);
-			sys_slist_init(&t->key_list);
-			sys_slist_init(&t->cleanup_list);
-		}
-	}
-
-#if defined(CONFIG_PTHREAD_CREATE_BARRIER)
-	struct pthread_barrier barrier;
-
-	/* use a barrier to ensure that the new thread has started
-	 * before pthread_create() returns
-	 */
-	barrier_ptr = &barrier;
-
-	if (t != NULL) {
-		err = pthread_barrier_init(&barrier, NULL, 2);
-		if (err != 0) {
-			/* cannot allocate barrier. move thread back to ready_q */
-			SYS_SEM_LOCK(&pthread_pool_lock) {
-				sys_dlist_remove(&t->q_node);
-				posix_thread_q_set(t, POSIX_THREAD_READY_Q);
-			}
-			t = NULL;
-		}
-	}
-#endif
-
-	if (t == NULL) {
-		/* no threads are ready */
-		LOG_DBG("No threads are ready");
-		return EAGAIN;
-	}
-
-	if (_attr == NULL) {
-		err = pthread_attr_init((pthread_attr_t *)&t->attr);
-		if (err == 0 && !__attr_is_runnable(&t->attr)) {
-			(void)pthread_attr_destroy((pthread_attr_t *)&t->attr);
-			err = EINVAL;
-		}
-		if (err != 0) {
-			/* cannot allocate pthread attributes (e.g. stack) */
-			SYS_SEM_LOCK(&pthread_pool_lock) {
-				sys_dlist_remove(&t->q_node);
-				posix_thread_q_set(t, POSIX_THREAD_READY_Q);
-			}
-			return err;
-		}
-		/* caller not responsible for destroying attr */
-		t->attr.caller_destroys = false;
-	} else {
-		/* copy user-provided attr into thread, caller must destroy attr at a later time */
-		t->attr = *(struct posix_thread_attr *)_attr;
-	}
-
-	if (t->attr.inheritsched == PTHREAD_INHERIT_SCHED) {
-		int pol;
-
-		t->attr.priority =
-			zephyr_to_posix_priority(k_thread_priority_get(k_current_get()), &pol);
-		t->attr.schedpolicy = pol;
-	}
-
-	/* spawn the thread */
-	k_thread_create(
-		&t->thread, t->attr.stack, __get_attr_stacksize(&t->attr) + t->attr.guardsize,
-		zephyr_thread_wrapper, (void *)arg, threadroutine, barrier_ptr,
-		posix_to_zephyr_priority(t->attr.priority, t->attr.schedpolicy), 0, K_NO_WAIT);
-
-#if defined(CONFIG_PTHREAD_CREATE_BARRIER)
-	/* wait for the spawned thread to cross our barrier */
-	err = pthread_barrier_wait(&barrier);
-	__ASSERT_NO_MSG(err == 0 || err == PTHREAD_BARRIER_SERIAL_THREAD);
-	err = pthread_barrier_destroy(&barrier);
-	__ASSERT_NO_MSG(err == 0);
-#endif
-
-	/* finally provide the initialized thread to the caller */
-	*th = mark_pthread_obj_initialized(posix_thread_to_offset(t));
-
-	LOG_DBG("Created pthread %p", &t->thread);
-
-	return 0;
-}
-
-int pthread_getconcurrency(void)
-{
-	int ret = 0;
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		ret = pthread_concurrency;
-	}
-
-	return ret;
-}
-
-int pthread_setconcurrency(int new_level)
-{
-	if (new_level < 0) {
-		return EINVAL;
-	}
-
-	if (new_level > CONFIG_MP_MAX_NUM_CPUS) {
-		return EAGAIN;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		pthread_concurrency = new_level;
-	}
-
-	return 0;
-}
-
-/**
- * @brief Set cancelability State.
- *
- * See IEEE 1003.1
- */
-int pthread_setcancelstate(int state, int *oldstate)
-{
-	int ret = EINVAL;
-	bool cancel_pending = false;
-	struct posix_thread *t = NULL;
-	bool cancel_type = -1;
-
-	if (state != PTHREAD_CANCEL_ENABLE && state != PTHREAD_CANCEL_DISABLE) {
-		LOG_DBG("Invalid pthread state %d", state);
-		return EINVAL;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread_self());
-		if (t == NULL) {
-			ret = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (oldstate != NULL) {
-			*oldstate = t->attr.cancelstate;
-		}
-
-		t->attr.cancelstate = state;
-		cancel_pending = t->attr.cancelpending;
-		cancel_type = t->attr.canceltype;
-
-		ret = 0;
-	}
-
-	if (ret == 0 && state == PTHREAD_CANCEL_ENABLE &&
-	    cancel_type == PTHREAD_CANCEL_ASYNCHRONOUS && cancel_pending) {
-		posix_thread_finalize(t, PTHREAD_CANCELED);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Set cancelability Type.
- *
- * See IEEE 1003.1
- */
-int pthread_setcanceltype(int type, int *oldtype)
-{
-	int ret = EINVAL;
-	struct posix_thread *t;
-
-	if (type != PTHREAD_CANCEL_DEFERRED && type != PTHREAD_CANCEL_ASYNCHRONOUS) {
-		LOG_DBG("Invalid pthread cancel type %d", type);
-		return EINVAL;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread_self());
-		if (t == NULL) {
-			ret = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (oldtype != NULL) {
-			*oldtype = t->attr.canceltype;
-		}
-		t->attr.canceltype = type;
-
-		ret = 0;
-	}
-
-	return ret;
-}
-
-/**
- * @brief Create a cancellation point in the calling thread.
- *
- * See IEEE 1003.1
- */
-void pthread_testcancel(void)
-{
-	bool cancel_pended = false;
-	struct posix_thread *t = NULL;
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread_self());
-		if (t == NULL) {
-			SYS_SEM_LOCK_BREAK;
-		}
-		if (t->attr.cancelstate != PTHREAD_CANCEL_ENABLE) {
-			SYS_SEM_LOCK_BREAK;
-		}
-		if (t->attr.cancelpending) {
-			cancel_pended = true;
-			t->attr.cancelstate = PTHREAD_CANCEL_DISABLE;
-		}
-	}
-
-	if (cancel_pended) {
-		posix_thread_finalize(t, PTHREAD_CANCELED);
-	}
-}
-
-/**
- * @brief Cancel execution of a thread.
- *
- * See IEEE 1003.1
- */
-int pthread_cancel(pthread_t pthread)
-{
-	int ret = ESRCH;
-	bool cancel_state = PTHREAD_CANCEL_ENABLE;
-	bool cancel_type = PTHREAD_CANCEL_DEFERRED;
-	struct posix_thread *t = NULL;
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread);
-		if (t == NULL) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (!__attr_is_initialized(&t->attr)) {
-			/* thread has already terminated */
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		ret = 0;
-		t->attr.cancelpending = true;
-		cancel_state = t->attr.cancelstate;
-		cancel_type = t->attr.canceltype;
-	}
-
-	if (ret == 0 && cancel_state == PTHREAD_CANCEL_ENABLE &&
-	    cancel_type == PTHREAD_CANCEL_ASYNCHRONOUS) {
-		posix_thread_finalize(t, PTHREAD_CANCELED);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Set thread scheduling policy and parameters.
- *
- * See IEEE 1003.1
- */
-int pthread_setschedparam(pthread_t pthread, int policy, const struct sched_param *param)
-{
-	int ret = ESRCH;
-	int new_prio = K_LOWEST_APPLICATION_THREAD_PRIO;
-	struct posix_thread *t = NULL;
-
-	if (param == NULL || !valid_posix_policy(policy) ||
-	    !is_posix_policy_prio_valid(param->sched_priority, policy)) {
-		return EINVAL;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread);
-		if (t == NULL) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		ret = 0;
-		new_prio = posix_to_zephyr_priority(param->sched_priority, policy);
-	}
-
-	if (ret == 0) {
-		k_thread_priority_set(&t->thread, new_prio);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Set thread scheduling priority.
- *
- * See IEEE 1003.1
- */
-int pthread_setschedprio(pthread_t thread, int prio)
-{
-	int ret;
-	int new_prio = K_LOWEST_APPLICATION_THREAD_PRIO;
-	struct posix_thread *t = NULL;
-	int policy = -1;
-	struct sched_param param;
-
-	ret = pthread_getschedparam(thread, &policy, &param);
-	if (ret != 0) {
-		return ret;
-	}
-
-	if (!is_posix_policy_prio_valid(prio, policy)) {
-		return EINVAL;
-	}
-
-	ret = ESRCH;
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(thread);
-		if (t == NULL) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		ret = 0;
-		new_prio = posix_to_zephyr_priority(prio, policy);
-	}
-
-	if (ret == 0) {
-		k_thread_priority_set(&t->thread, new_prio);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Initialise threads attribute object
- *
- * See IEEE 1003.1
- */
-int pthread_attr_init(pthread_attr_t *_attr)
-{
-	struct posix_thread_attr *const attr = (struct posix_thread_attr *)_attr;
-
-	if (attr == NULL) {
-		LOG_DBG("Invalid attr pointer");
-		return ENOMEM;
-	}
-
-	BUILD_ASSERT(DYNAMIC_STACK_SIZE <= PTHREAD_STACK_MAX);
-
-	*attr = (struct posix_thread_attr){
-		.guardsize = CONFIG_POSIX_PTHREAD_ATTR_GUARDSIZE_DEFAULT,
-		.contentionscope = PTHREAD_SCOPE_SYSTEM,
-		.inheritsched = PTHREAD_INHERIT_SCHED,
-		.detachstate = PTHREAD_CREATE_JOINABLE,
-		.cancelstate = PTHREAD_CANCEL_ENABLE,
-		.canceltype = PTHREAD_CANCEL_DEFERRED,
-		.priority = DEFAULT_PTHREAD_PRIORITY,
-		.schedpolicy = DEFAULT_PTHREAD_POLICY,
-		.stack = NULL,
-		.stacksize = 0,
-		.initialized = false,
-		.caller_destroys = true,
-	};
-
-	if (DYNAMIC_STACK_SIZE > 0) {
-		attr->stack = k_thread_stack_alloc(DYNAMIC_STACK_SIZE + attr->guardsize,
-						   k_is_user_context() ? K_USER : 0);
-		if (attr->stack == NULL) {
-			LOG_DBG("Did not auto-allocate thread stack");
-		} else {
-			__set_attr_stacksize(attr, DYNAMIC_STACK_SIZE);
-			__ASSERT_NO_MSG(__attr_is_initialized(attr));
-			LOG_DBG("Allocated thread stack %zu@%p", __get_attr_stacksize(attr),
-				attr->stack);
-		}
-	}
-
-	/* caller responsible for destroying attr */
-	attr->initialized = true;
-
-	LOG_DBG("Initialized attr %p", _attr);
-
-	return 0;
-}
-
-/**
- * @brief Get thread scheduling policy and parameters
- *
- * See IEEE 1003.1
- */
-int pthread_getschedparam(pthread_t pthread, int *policy, struct sched_param *param)
-{
-	int ret = ESRCH;
-	struct posix_thread *t;
-
-	if (policy == NULL || param == NULL) {
-		return EINVAL;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread);
-		if (t == NULL) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (!__attr_is_initialized(&t->attr)) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		ret = 0;
-		param->sched_priority =
-			zephyr_to_posix_priority(k_thread_priority_get(&t->thread), policy);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Dynamic package initialization
- *
- * See IEEE 1003.1
- */
-int pthread_once(pthread_once_t *once, void (*init_func)(void))
-{
-	int ret = EINVAL;
-	bool run_init_func = false;
-	struct pthread_once *const _once = (struct pthread_once *)once;
-
-	if (init_func == NULL) {
-		return EINVAL;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		if (!_once->flag) {
-			run_init_func = true;
-			_once->flag = true;
-		}
-		ret = 0;
-	}
-
-	if (ret == 0 && run_init_func) {
-		init_func();
-	}
-
-	return ret;
-}
-
-/**
- * @brief Terminate calling thread.
- *
- * See IEEE 1003.1
- */
-FUNC_NORETURN
-void pthread_exit(void *retval)
-{
-	struct posix_thread *self = NULL;
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		self = to_posix_thread(pthread_self());
-		if (self == NULL) {
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		/* Mark a thread as cancellable before exiting */
-		self->attr.cancelstate = PTHREAD_CANCEL_ENABLE;
-	}
-
-	if (self == NULL) {
-		/* not a valid posix_thread */
-		LOG_DBG("Aborting non-pthread %p", k_current_get());
-		k_thread_abort(k_current_get());
-
-		CODE_UNREACHABLE;
-	}
-
-	posix_thread_finalize(self, retval);
-	CODE_UNREACHABLE;
-}
-
-static int pthread_timedjoin_internal(pthread_t pthread, void **status, k_timeout_t timeout)
-{
-	int ret = ESRCH;
-	struct posix_thread *t = NULL;
-
-	if (pthread == pthread_self()) {
-		LOG_DBG("Pthread attempted to join itself (%x)", pthread);
-		return EDEADLK;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread);
-		if (t == NULL) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		LOG_DBG("Pthread %p joining..", &t->thread);
-
-		if (t->attr.detachstate != PTHREAD_CREATE_JOINABLE) {
-			/* undefined behaviour */
-			ret = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (posix_thread_q_get(t) == POSIX_THREAD_READY_Q) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		/*
-		 * thread is joinable and is in run_q or done_q.
-		 * let's ensure that the thread cannot be joined again after this point.
-		 */
-		ret = 0;
-		t->attr.detachstate = PTHREAD_CREATE_DETACHED;
-	}
-
-	switch (ret) {
-	case ESRCH:
-		LOG_DBG("Pthread %p has already been joined", &t->thread);
-		return ret;
-	case EINVAL:
-		LOG_DBG("Pthread %p is not a joinable", &t->thread);
-		return ret;
-	case 0:
-		break;
-	}
-
-	ret = k_thread_join(&t->thread, timeout);
-	if (ret != 0) {
-		/* when joining failed, ensure that the thread can be joined later */
-		SYS_SEM_LOCK(&pthread_pool_lock) {
-			t->attr.detachstate = PTHREAD_CREATE_JOINABLE;
-		}
-	}
-	if (ret == -EBUSY) {
-		return EBUSY;
-	} else if (ret == -EAGAIN) {
-		return ETIMEDOUT;
-	}
-	/* Can only be ok or -EDEADLK, which should never occur for pthreads */
-	__ASSERT_NO_MSG(ret == 0);
-
-	LOG_DBG("Joined pthread %p", &t->thread);
-
-	if (status != NULL) {
-		LOG_DBG("Writing status to %p", status);
-		*status = t->retval;
-	}
-
-	posix_thread_recycle();
-
-	return 0;
-}
-
-/**
- * @brief Await a thread termination with timeout.
- *
- * Non-portable GNU extension of IEEE 1003.1
- */
-int pthread_timedjoin_np(pthread_t pthread, void **status, const struct timespec *abstime)
-{
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		LOG_DBG("%s is invalid", "abstime");
-		return EINVAL;
-	}
-
-	return pthread_timedjoin_internal(pthread, status,
-					  K_MSEC(timespec_to_timeoutms(CLOCK_REALTIME, abstime)));
-}
-
-/**
- * @brief Check a thread for termination.
- *
- * Non-portable GNU extension of IEEE 1003.1
- */
-int pthread_tryjoin_np(pthread_t pthread, void **status)
-{
-	return pthread_timedjoin_internal(pthread, status, K_NO_WAIT);
-}
-
-/**
- * @brief Await a thread termination.
- *
- * See IEEE 1003.1
- */
-int pthread_join(pthread_t pthread, void **status)
-{
-	return pthread_timedjoin_internal(pthread, status, K_FOREVER);
-}
-
-/**
- * @brief Detach a thread.
- *
- * See IEEE 1003.1
- */
-int pthread_detach(pthread_t pthread)
-{
-	int ret = ESRCH;
-	struct posix_thread *t = NULL;
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread);
-		if (t == NULL) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (posix_thread_q_get(t) == POSIX_THREAD_READY_Q ||
-		    t->attr.detachstate != PTHREAD_CREATE_JOINABLE) {
-			LOG_DBG("Pthread %p cannot be detached", &t->thread);
-			ret = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		ret = 0;
-		t->attr.detachstate = PTHREAD_CREATE_DETACHED;
-	}
-
-	if (ret == 0) {
-		LOG_DBG("Pthread %p detached", &t->thread);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Get detach state attribute in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_getdetachstate(const pthread_attr_t *_attr, int *detachstate)
-{
-	const struct posix_thread_attr *attr = (const struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || (detachstate == NULL)) {
-		return EINVAL;
-	}
-
-	*detachstate = attr->detachstate;
-	return 0;
-}
-
-/**
- * @brief Set detach state attribute in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_setdetachstate(pthread_attr_t *_attr, int detachstate)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || ((detachstate != PTHREAD_CREATE_DETACHED) &&
-					     (detachstate != PTHREAD_CREATE_JOINABLE))) {
-		return EINVAL;
-	}
-
-	attr->detachstate = detachstate;
-	return 0;
-}
-
-/**
- * @brief Get scheduling policy attribute in Thread attributes.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_getschedpolicy(const pthread_attr_t *_attr, int *policy)
-{
-	const struct posix_thread_attr *attr = (const struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || (policy == NULL)) {
-		return EINVAL;
-	}
-
-	*policy = attr->schedpolicy;
-	return 0;
-}
-
-/**
- * @brief Set scheduling policy attribute in Thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_setschedpolicy(pthread_attr_t *_attr, int policy)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || !valid_posix_policy(policy)) {
-		return EINVAL;
-	}
-
-	attr->schedpolicy = policy;
-	return 0;
-}
-
-/**
- * @brief Get stack size attribute in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_getstacksize(const pthread_attr_t *_attr, size_t *stacksize)
-{
-	const struct posix_thread_attr *attr = (const struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || (stacksize == NULL)) {
-		return EINVAL;
-	}
-
-	*stacksize = __get_attr_stacksize(attr);
-	return 0;
-}
-
-/**
- * @brief Set stack size attribute in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_setstacksize(pthread_attr_t *_attr, size_t stacksize)
-{
-	int ret;
-	void *new_stack;
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || stacksize == 0 || stacksize < PTHREAD_STACK_MIN ||
-	    stacksize > PTHREAD_STACK_MAX) {
-		return EINVAL;
-	}
-
-	if (__get_attr_stacksize(attr) == stacksize) {
-		return 0;
-	}
-
-	new_stack =
-		k_thread_stack_alloc(stacksize + attr->guardsize, k_is_user_context() ? K_USER : 0);
-	if (new_stack == NULL) {
-		if (stacksize < __get_attr_stacksize(attr)) {
-			__set_attr_stacksize(attr, stacksize);
-			return 0;
-		}
-
-		LOG_DBG("k_thread_stack_alloc(%zu) failed",
-			__get_attr_stacksize(attr) + attr->guardsize);
-		return ENOMEM;
-	}
-	LOG_DBG("Allocated thread stack %zu@%p", stacksize + attr->guardsize, new_stack);
-
-	if (attr->stack != NULL) {
-		ret = k_thread_stack_free(attr->stack);
-		if (ret == 0) {
-			LOG_DBG("Freed attr %p thread stack %zu@%p", _attr,
-				__get_attr_stacksize(attr), attr->stack);
-		}
-	}
-
-	__set_attr_stacksize(attr, stacksize);
-	attr->stack = new_stack;
-
-	return 0;
-}
-
-/**
- * @brief Get stack attributes in thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_getstack(const pthread_attr_t *_attr, void **stackaddr, size_t *stacksize)
-{
-	const struct posix_thread_attr *attr = (const struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || (stackaddr == NULL) || (stacksize == NULL)) {
-		return EINVAL;
-	}
-
-	*stackaddr = attr->stack;
-	*stacksize = __get_attr_stacksize(attr);
-	return 0;
-}
-
-int pthread_attr_getguardsize(const pthread_attr_t *ZRESTRICT _attr, size_t *ZRESTRICT guardsize)
-{
-	struct posix_thread_attr *const attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || guardsize == NULL) {
-		return EINVAL;
-	}
-
-	*guardsize = attr->guardsize;
-
-	return 0;
-}
-
-int pthread_attr_setguardsize(pthread_attr_t *_attr, size_t guardsize)
-{
-	struct posix_thread_attr *const attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || guardsize > PTHREAD_GUARD_MAX) {
-		return EINVAL;
-	}
-
-	attr->guardsize = guardsize;
-
-	return 0;
-}
-
-/**
- * @brief Get thread attributes object scheduling parameters.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_getschedparam(const pthread_attr_t *_attr, struct sched_param *schedparam)
-{
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr) || (schedparam == NULL)) {
-		return EINVAL;
-	}
-
-	schedparam->sched_priority = attr->priority;
-	return 0;
-}
-
-/**
- * @brief Destroy thread attributes object.
- *
- * See IEEE 1003.1
- */
-int pthread_attr_destroy(pthread_attr_t *_attr)
-{
-	int ret;
-	struct posix_thread_attr *attr = (struct posix_thread_attr *)_attr;
-
-	if (!__attr_is_initialized(attr)) {
-		return EINVAL;
-	}
-
-	ret = k_thread_stack_free(attr->stack);
-	if (ret == 0) {
-		LOG_DBG("Freed attr %p thread stack %zu@%p", _attr, __get_attr_stacksize(attr),
-			attr->stack);
-	}
-
-	*attr = (struct posix_thread_attr){0};
-	LOG_DBG("Destroyed attr %p", _attr);
-
-	return 0;
-}
-
-int pthread_setname_np(pthread_t thread, const char *name)
-{
-#ifdef CONFIG_THREAD_NAME
-	k_tid_t kthread;
-
-	thread = get_posix_thread_idx(thread);
-	if (thread >= ARRAY_SIZE(posix_thread_pool)) {
-		return ESRCH;
-	}
-
-	kthread = &posix_thread_pool[thread].thread;
-
-	if (name == NULL) {
-		return EINVAL;
-	}
-
-	return k_thread_name_set(kthread, name);
-#else
-	ARG_UNUSED(thread);
-	ARG_UNUSED(name);
-	return 0;
-#endif
-}
-
-int pthread_getname_np(pthread_t thread, char *name, size_t len)
-{
-#ifdef CONFIG_THREAD_NAME
-	k_tid_t kthread;
-
-	thread = get_posix_thread_idx(thread);
-	if (thread >= ARRAY_SIZE(posix_thread_pool)) {
-		return ESRCH;
-	}
-
-	if (name == NULL) {
-		return EINVAL;
-	}
-
-	memset(name, '\0', len);
-	kthread = &posix_thread_pool[thread].thread;
-	return k_thread_name_copy(kthread, name, len - 1);
-#else
-	ARG_UNUSED(thread);
-	ARG_UNUSED(name);
-	ARG_UNUSED(len);
-	return 0;
-#endif
-}
-
-int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))
-{
-	ARG_UNUSED(prepare);
-	ARG_UNUSED(parent);
-	ARG_UNUSED(child);
-
-	return ENOSYS;
-}
-
-/* this should probably go into signal.c but we need access to the lock */
-int pthread_sigmask(int how, const sigset_t *ZRESTRICT set, sigset_t *ZRESTRICT oset)
-{
-	int ret = ESRCH;
-	struct posix_thread *t = NULL;
-
-	if (!(how == SIG_BLOCK || how == SIG_SETMASK || how == SIG_UNBLOCK)) {
-		return EINVAL;
-	}
-
-	SYS_SEM_LOCK(&pthread_pool_lock) {
-		t = to_posix_thread(pthread_self());
-		if (t == NULL) {
-			ret = ESRCH;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (oset != NULL) {
-			*oset = t->sigset;
-		}
-
-		ret = 0;
-		if (set == NULL) {
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		const unsigned long *const x = (const unsigned long *)set;
-		unsigned long *const y = (unsigned long *)&t->sigset;
-
-		switch (how) {
-		case SIG_BLOCK:
-			for (size_t i = 0; i < sizeof(sigset_t) / sizeof(unsigned long); ++i) {
-				y[i] |= x[i];
-			}
-			break;
-		case SIG_SETMASK:
-			t->sigset = *set;
-			break;
-		case SIG_UNBLOCK:
-			for (size_t i = 0; i < sizeof(sigset_t) / sizeof(unsigned long); ++i) {
-				y[i] &= ~x[i];
-			}
-			break;
-		}
-	}
-
-	return ret;
-}
-
-__boot_func
-static int posix_thread_pool_init(void)
-{
-	ARRAY_FOR_EACH_PTR(posix_thread_pool, th) {
-		posix_thread_q_set(th, POSIX_THREAD_READY_Q);
-	}
-
-	return 0;
-}
-SYS_INIT(posix_thread_pool_init, PRE_KERNEL_1, 0);
-
-int sched_yield(void)
-{
-	k_yield();
-	return 0;
-}
diff --git a/lib/posix/options/pthread_sched.h b/lib/posix/options/pthread_sched.h
deleted file mode 100644
index 990e0f4aad3..00000000000
--- a/lib/posix/options/pthread_sched.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_LIB_POSIX_POSIX_PTHREAD_SCHED_H_
-#define ZEPHYR_LIB_POSIX_POSIX_PTHREAD_SCHED_H_
-
-#include <errno.h>
-#include <sched.h>
-#include <stdbool.h>
-
-#include <zephyr/sys/util.h>
-
-static inline bool valid_posix_policy(int policy)
-{
-	return policy == SCHED_FIFO || policy == SCHED_RR || policy == SCHED_OTHER;
-}
-
-static inline int posix_sched_priority_min(int policy)
-{
-	if (!valid_posix_policy(policy)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	return 0;
-}
-
-static inline int posix_sched_priority_max(int policy)
-{
-	if (IS_ENABLED(CONFIG_COOP_ENABLED) && policy == SCHED_FIFO) {
-		return CONFIG_NUM_COOP_PRIORITIES - 1;
-	} else if (IS_ENABLED(CONFIG_PREEMPT_ENABLED) &&
-		   (policy == SCHED_RR || policy == SCHED_OTHER)) {
-		return CONFIG_NUM_PREEMPT_PRIORITIES - 1;
-	}
-
-	errno = EINVAL;
-	return -1;
-}
-
-#endif
diff --git a/lib/posix/options/pwd.c b/lib/posix/options/pwd.c
deleted file mode 100644
index 1d656f9dec9..00000000000
--- a/lib/posix/options/pwd.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2024 Meta Platforms
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-
-#include <zephyr/sys/util.h>
-#include <pwd.h>
-
-int getpwnam_r(const char *nam, struct passwd *pwd, char *buffer, size_t bufsize,
-	       struct passwd **result)
-{
-	ARG_UNUSED(nam);
-	ARG_UNUSED(pwd);
-	ARG_UNUSED(buffer);
-	ARG_UNUSED(bufsize);
-	ARG_UNUSED(result);
-
-	return ENOSYS;
-}
-
-int getpwuid_r(uid_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
-{
-	ARG_UNUSED(uid);
-	ARG_UNUSED(pwd);
-	ARG_UNUSED(buffer);
-	ARG_UNUSED(bufsize);
-	ARG_UNUSED(result);
-
-	return ENOSYS;
-}
diff --git a/lib/posix/options/rwlock.c b/lib/posix/options/rwlock.c
deleted file mode 100644
index 4067ef6d83e..00000000000
--- a/lib/posix/options/rwlock.c
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-#include "posix_internal.h"
-
-#include <zephyr/init.h>
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <pthread.h>
-#include <zephyr/sys/bitarray.h>
-#include <zephyr/sys/sem.h>
-
-#define CONCURRENT_READER_LIMIT  (CONFIG_POSIX_THREAD_THREADS_MAX + 1)
-
-struct posix_rwlock {
-	struct sys_sem rd_sem;
-	struct sys_sem wr_sem;
-	struct sys_sem reader_active; /* blocks WR till reader has acquired lock */
-	k_tid_t wr_owner;
-};
-
-struct posix_rwlockattr {
-	bool initialized: 1;
-	bool pshared: 1;
-};
-
-static uint32_t read_lock_acquire(struct posix_rwlock *rwl, uint32_t timeout);
-static uint32_t write_lock_acquire(struct posix_rwlock *rwl, uint32_t timeout);
-
-LOG_MODULE_REGISTER(pthread_rwlock, CONFIG_PTHREAD_RWLOCK_LOG_LEVEL);
-
-static SYS_SEM_DEFINE(posix_rwlock_lock, 1, 1);
-
-static struct posix_rwlock posix_rwlock_pool[CONFIG_MAX_PTHREAD_RWLOCK_COUNT];
-SYS_BITARRAY_DEFINE_STATIC(posix_rwlock_bitarray, CONFIG_MAX_PTHREAD_RWLOCK_COUNT);
-
-/*
- * We reserve the MSB to mark a pthread_rwlock_t as initialized (from the
- * perspective of the application). With a linear space, this means that
- * the theoretical pthread_rwlock_t range is [0,2147483647].
- */
-BUILD_ASSERT(CONFIG_MAX_PTHREAD_RWLOCK_COUNT < PTHREAD_OBJ_MASK_INIT,
-	     "CONFIG_MAX_PTHREAD_RWLOCK_COUNT is too high");
-
-static inline size_t posix_rwlock_to_offset(struct posix_rwlock *rwl)
-{
-	return rwl - posix_rwlock_pool;
-}
-
-static inline size_t to_posix_rwlock_idx(pthread_rwlock_t rwlock)
-{
-	return mark_pthread_obj_uninitialized(rwlock);
-}
-
-static struct posix_rwlock *get_posix_rwlock(pthread_rwlock_t rwlock)
-{
-	int actually_initialized;
-	size_t bit = to_posix_rwlock_idx(rwlock);
-
-	/* if the provided rwlock does not claim to be initialized, its invalid */
-	if (!is_pthread_obj_initialized(rwlock)) {
-		LOG_DBG("RWlock is uninitialized (%x)", rwlock);
-		return NULL;
-	}
-
-	/* Mask off the MSB to get the actual bit index */
-	if (sys_bitarray_test_bit(&posix_rwlock_bitarray, bit, &actually_initialized) < 0) {
-		LOG_DBG("RWlock is invalid (%x)", rwlock);
-		return NULL;
-	}
-
-	if (actually_initialized == 0) {
-		/* The rwlock claims to be initialized but is actually not */
-		LOG_DBG("RWlock claims to be initialized (%x)", rwlock);
-		return NULL;
-	}
-
-	return &posix_rwlock_pool[bit];
-}
-
-struct posix_rwlock *to_posix_rwlock(pthread_rwlock_t *rwlock)
-{
-	size_t bit;
-	struct posix_rwlock *rwl;
-
-	if (*rwlock != PTHREAD_RWLOCK_INITIALIZER) {
-		return get_posix_rwlock(*rwlock);
-	}
-
-	/* Try and automatically associate a posix_rwlock */
-	if (sys_bitarray_alloc(&posix_rwlock_bitarray, 1, &bit) < 0) {
-		LOG_DBG("Unable to allocate pthread_rwlock_t");
-		return NULL;
-	}
-
-	/* Record the associated posix_rwlock in rwl and mark as initialized */
-	*rwlock = mark_pthread_obj_initialized(bit);
-
-	/* Initialize the posix_rwlock */
-	rwl = &posix_rwlock_pool[bit];
-
-	return rwl;
-}
-
-/**
- * @brief Initialize read-write lock object.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_init(pthread_rwlock_t *rwlock,
-			const pthread_rwlockattr_t *attr)
-{
-	struct posix_rwlock *rwl;
-
-	ARG_UNUSED(attr);
-	*rwlock = PTHREAD_RWLOCK_INITIALIZER;
-
-	rwl = to_posix_rwlock(rwlock);
-	if (rwl == NULL) {
-		return ENOMEM;
-	}
-
-	sys_sem_init(&rwl->rd_sem, CONCURRENT_READER_LIMIT, CONCURRENT_READER_LIMIT);
-	sys_sem_init(&rwl->wr_sem, 1, 1);
-	sys_sem_init(&rwl->reader_active, 1, 1);
-	rwl->wr_owner = NULL;
-
-	LOG_DBG("Initialized rwlock %p", rwl);
-
-	return 0;
-}
-
-/**
- * @brief Destroy read-write lock object.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)
-{
-	int err;
-	size_t bit;
-	int ret = EINVAL;
-	struct posix_rwlock *rwl;
-
-	SYS_SEM_LOCK(&posix_rwlock_lock) {
-		rwl = get_posix_rwlock(*rwlock);
-		if (rwl == NULL) {
-			ret = EINVAL;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		if (rwl->wr_owner != NULL) {
-			ret = EBUSY;
-			SYS_SEM_LOCK_BREAK;
-		}
-
-		ret = 0;
-		bit = posix_rwlock_to_offset(rwl);
-		err = sys_bitarray_free(&posix_rwlock_bitarray, 1, bit);
-		__ASSERT_NO_MSG(err == 0);
-	}
-
-	return ret;
-}
-
-/**
- * @brief Lock a read-write lock object for reading.
- *
- * API behaviour is unpredictable if number of concurrent reader
- * lock held is greater than CONCURRENT_READER_LIMIT.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)
-{
-	struct posix_rwlock *rwl;
-
-	rwl = get_posix_rwlock(*rwlock);
-	if (rwl == NULL) {
-		return EINVAL;
-	}
-
-	return read_lock_acquire(rwl, SYS_FOREVER_MS);
-}
-
-/**
- * @brief Lock a read-write lock object for reading within specific time.
- *
- * API behaviour is unpredictable if number of concurrent reader
- * lock held is greater than CONCURRENT_READER_LIMIT.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock,
-			       const struct timespec *abstime)
-{
-	uint32_t ret = 0U;
-	struct posix_rwlock *rwl;
-
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		LOG_DBG("%s is invalid", "abstime");
-		return EINVAL;
-	}
-
-	rwl = get_posix_rwlock(*rwlock);
-	if (rwl == NULL) {
-		return EINVAL;
-	}
-
-	if (read_lock_acquire(rwl, timespec_to_timeoutms(CLOCK_REALTIME, abstime)) != 0U) {
-		ret = ETIMEDOUT;
-	}
-
-	return ret;
-}
-
-/**
- * @brief Lock a read-write lock object for reading immediately.
- *
- * API behaviour is unpredictable if number of concurrent reader
- * lock held is greater than CONCURRENT_READER_LIMIT.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)
-{
-	struct posix_rwlock *rwl;
-
-	rwl = get_posix_rwlock(*rwlock);
-	if (rwl == NULL) {
-		return EINVAL;
-	}
-
-	return read_lock_acquire(rwl, 0);
-}
-
-/**
- * @brief Lock a read-write lock object for writing.
- *
- * Write lock does not have priority over reader lock,
- * threads get lock based on priority.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)
-{
-	struct posix_rwlock *rwl;
-
-	rwl = get_posix_rwlock(*rwlock);
-	if (rwl == NULL) {
-		return EINVAL;
-	}
-
-	return write_lock_acquire(rwl, SYS_FOREVER_MS);
-}
-
-/**
- * @brief Lock a read-write lock object for writing within specific time.
- *
- * Write lock does not have priority over reader lock,
- * threads get lock based on priority.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock,
-			       const struct timespec *abstime)
-{
-	uint32_t ret = 0U;
-	struct posix_rwlock *rwl;
-
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		LOG_DBG("%s is invalid", "abstime");
-		return EINVAL;
-	}
-
-	rwl = get_posix_rwlock(*rwlock);
-	if (rwl == NULL) {
-		return EINVAL;
-	}
-
-	if (write_lock_acquire(rwl, timespec_to_timeoutms(CLOCK_REALTIME, abstime)) != 0U) {
-		ret = ETIMEDOUT;
-	}
-
-	return ret;
-}
-
-/**
- * @brief Lock a read-write lock object for writing immediately.
- *
- * Write lock does not have priority over reader lock,
- * threads get lock based on priority.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)
-{
-	struct posix_rwlock *rwl;
-
-	rwl = get_posix_rwlock(*rwlock);
-	if (rwl == NULL) {
-		return EINVAL;
-	}
-
-	return write_lock_acquire(rwl, 0);
-}
-
-/**
- *
- * @brief Unlock a read-write lock object.
- *
- * See IEEE 1003.1
- */
-int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)
-{
-	struct posix_rwlock *rwl;
-
-	rwl = get_posix_rwlock(*rwlock);
-	if (rwl == NULL) {
-		return EINVAL;
-	}
-
-	if (k_current_get() == rwl->wr_owner) {
-		/* Write unlock */
-		rwl->wr_owner = NULL;
-		(void)sys_sem_give(&rwl->reader_active);
-		(void)sys_sem_give(&rwl->wr_sem);
-	} else {
-		/* Read unlock */
-		(void)sys_sem_give(&rwl->rd_sem);
-
-		if (sys_sem_count_get(&rwl->rd_sem) == CONCURRENT_READER_LIMIT) {
-			/* Last read lock, unlock writer */
-			(void)sys_sem_give(&rwl->reader_active);
-		}
-	}
-	return 0;
-}
-
-static uint32_t read_lock_acquire(struct posix_rwlock *rwl, uint32_t timeout)
-{
-	uint32_t ret = 0U;
-
-	if (sys_sem_take(&rwl->wr_sem, SYS_TIMEOUT_MS(timeout)) == 0) {
-		(void)sys_sem_take(&rwl->reader_active, K_NO_WAIT);
-		(void)sys_sem_take(&rwl->rd_sem, K_NO_WAIT);
-		(void)sys_sem_give(&rwl->wr_sem);
-	} else {
-		ret = EBUSY;
-	}
-
-	return ret;
-}
-
-static uint32_t write_lock_acquire(struct posix_rwlock *rwl, uint32_t timeout)
-{
-	uint32_t ret = 0U;
-	int64_t elapsed_time, st_time = k_uptime_get();
-	k_timeout_t k_timeout;
-
-	k_timeout = SYS_TIMEOUT_MS(timeout);
-
-	/* waiting for release of write lock */
-	if (sys_sem_take(&rwl->wr_sem, k_timeout) == 0) {
-		/* update remaining timeout time for 2nd sem */
-		if (timeout != SYS_FOREVER_MS) {
-			elapsed_time = k_uptime_get() - st_time;
-			timeout = timeout <= elapsed_time ? 0 :
-				  timeout - elapsed_time;
-		}
-
-		k_timeout = SYS_TIMEOUT_MS(timeout);
-
-		/* waiting for reader to complete operation */
-		if (sys_sem_take(&rwl->reader_active, k_timeout) == 0) {
-			rwl->wr_owner = k_current_get();
-		} else {
-			(void)sys_sem_give(&rwl->wr_sem);
-			ret = EBUSY;
-		}
-
-	} else {
-		ret = EBUSY;
-	}
-	return ret;
-}
-
-int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *ZRESTRICT attr,
-				  int *ZRESTRICT pshared)
-{
-	struct posix_rwlockattr *const a = (struct posix_rwlockattr *)attr;
-
-	if (a == NULL || !a->initialized) {
-		return EINVAL;
-	}
-
-	*pshared = a->pshared;
-
-	return 0;
-}
-
-int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared)
-{
-	struct posix_rwlockattr *const a = (struct posix_rwlockattr *)attr;
-
-	if (a == NULL || !a->initialized) {
-		return EINVAL;
-	}
-
-	if (!(pshared == PTHREAD_PROCESS_PRIVATE || pshared == PTHREAD_PROCESS_SHARED)) {
-		return EINVAL;
-	}
-
-	a->pshared = pshared;
-
-	return 0;
-}
-
-int pthread_rwlockattr_init(pthread_rwlockattr_t *attr)
-{
-	struct posix_rwlockattr *const a = (struct posix_rwlockattr *)attr;
-
-	if (a == NULL) {
-		return EINVAL;
-	}
-
-	*a = (struct posix_rwlockattr){
-		.initialized = true,
-		.pshared = PTHREAD_PROCESS_PRIVATE,
-	};
-
-	return 0;
-}
-
-int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr)
-{
-	struct posix_rwlockattr *const a = (struct posix_rwlockattr *)attr;
-
-	if (a == NULL || !a->initialized) {
-		return EINVAL;
-	}
-
-	*a = (struct posix_rwlockattr){0};
-
-	return 0;
-}
diff --git a/lib/posix/options/sched.c b/lib/posix/options/sched.c
deleted file mode 100644
index 270332e77be..00000000000
--- a/lib/posix/options/sched.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (c) 2018-2023 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "pthread_sched.h"
-
-#include <zephyr/kernel.h>
-#include <sched.h>
-
-/**
- * @brief Get minimum priority value for a given policy
- *
- * See IEEE 1003.1
- */
-int sched_get_priority_min(int policy)
-{
-	return posix_sched_priority_min(policy);
-}
-
-/**
- * @brief Get maximum priority value for a given policy
- *
- * See IEEE 1003.1
- */
-int sched_get_priority_max(int policy)
-{
-	return posix_sched_priority_max(policy);
-}
-
-/**
- * @brief Get scheduling parameters
- *
- * See IEEE 1003.1
- */
-int sched_getparam(pid_t pid, struct sched_param *param)
-{
-	ARG_UNUSED(pid);
-	ARG_UNUSED(param);
-
-	errno = ENOSYS;
-
-	return -1;
-}
-
-/**
- * @brief Get scheduling policy
- *
- * See IEEE 1003.1
- */
-int sched_getscheduler(pid_t pid)
-{
-	ARG_UNUSED(pid);
-
-	errno = ENOSYS;
-
-	return -1;
-}
-
-/**
- * @brief Set scheduling parameters
- *
- * See IEEE 1003.1
- */
-int sched_setparam(pid_t pid, const struct sched_param *param)
-{
-	ARG_UNUSED(pid);
-	ARG_UNUSED(param);
-
-	errno = ENOSYS;
-
-	return -1;
-}
-
-/**
- * @brief Set scheduling policy
- *
- * See IEEE 1003.1
- */
-int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param)
-{
-	ARG_UNUSED(pid);
-	ARG_UNUSED(policy);
-	ARG_UNUSED(param);
-
-	errno = ENOSYS;
-
-	return -1;
-}
-
-int sched_rr_get_interval(pid_t pid, struct timespec *interval)
-{
-	ARG_UNUSED(pid);
-	ARG_UNUSED(interval);
-
-	errno = ENOSYS;
-
-	return -1;
-}
diff --git a/lib/posix/options/semaphore.c b/lib/posix/options/semaphore.c
deleted file mode 100644
index 263af275982..00000000000
--- a/lib/posix/options/semaphore.c
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-
-#include <errno.h>
-#include <zephyr/kernel.h>
-#include <zephyr/sys/atomic.h>
-#include <fcntl.h>
-#include <pthread.h>
-#include <semaphore.h>
-
-struct nsem_obj {
-	sys_snode_t snode;
-	sem_t sem;
-	int ref_count;
-	char *name;
-};
-
-/* Initialize the list */
-static sys_slist_t nsem_list = SYS_SLIST_STATIC_INIT(&nsem_list);
-
-static K_MUTEX_DEFINE(nsem_mutex);
-
-static inline void nsem_list_lock(void)
-{
-	__unused int ret = k_mutex_lock(&nsem_mutex, K_FOREVER);
-
-	__ASSERT(ret == 0, "nsem_list_lock() failed: %d", ret);
-}
-
-static inline void nsem_list_unlock(void)
-{
-	(void)k_mutex_unlock(&nsem_mutex);
-}
-
-static struct nsem_obj *nsem_find(const char *name)
-{
-	struct nsem_obj *nsem;
-
-	SYS_SLIST_FOR_EACH_CONTAINER(&nsem_list, nsem, snode) {
-		if ((nsem->name != NULL) && (strcmp(nsem->name, name) == 0)) {
-			return nsem;
-		}
-	}
-
-	return NULL;
-}
-
-/* Clean up a named semaphore object completely (incl its `name` buffer) */
-static void nsem_cleanup(struct nsem_obj *nsem)
-{
-	if (nsem != NULL) {
-		if (nsem->name != NULL) {
-			k_free(nsem->name);
-		}
-		k_free(nsem);
-	}
-}
-
-/* Remove a named semaphore if it isn't used */
-static void nsem_unref(struct nsem_obj *nsem)
-{
-	nsem->ref_count -= 1;
-	__ASSERT(nsem->ref_count >= 0, "ref_count may not be negative");
-
-	if (nsem->ref_count == 0) {
-		__ASSERT(nsem->name == NULL, "ref_count is 0 but sem is not unlinked");
-
-		sys_slist_find_and_remove(&nsem_list, (sys_snode_t *) nsem);
-
-		/* Free nsem */
-		nsem_cleanup(nsem);
-	}
-}
-
-/**
- * @brief Destroy semaphore.
- *
- * see IEEE 1003.1
- */
-int sem_destroy(sem_t *semaphore)
-{
-	if (semaphore == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (k_sem_count_get(semaphore)) {
-		errno = EBUSY;
-		return -1;
-	}
-
-	k_sem_reset(semaphore);
-	return 0;
-}
-
-/**
- * @brief Get value of semaphore.
- *
- * See IEEE 1003.1
- */
-int sem_getvalue(sem_t *semaphore, int *value)
-{
-	if (semaphore == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	*value = (int) k_sem_count_get(semaphore);
-
-	return 0;
-}
-/**
- * @brief Initialize semaphore.
- *
- * See IEEE 1003.1
- */
-int sem_init(sem_t *semaphore, int pshared, unsigned int value)
-{
-	if (value > CONFIG_POSIX_SEM_VALUE_MAX) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	/*
-	 * Zephyr has no concept of process, so only thread shared
-	 * semaphore makes sense in here.
-	 */
-	__ASSERT(pshared == 0, "pshared should be 0");
-
-	k_sem_init(semaphore, value, CONFIG_POSIX_SEM_VALUE_MAX);
-
-	return 0;
-}
-
-/**
- * @brief Unlock a semaphore.
- *
- * See IEEE 1003.1
- */
-int sem_post(sem_t *semaphore)
-{
-	if (semaphore == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	k_sem_give(semaphore);
-	return 0;
-}
-
-/**
- * @brief Try time limited locking a semaphore.
- *
- * See IEEE 1003.1
- */
-int sem_timedwait(sem_t *semaphore, struct timespec *abstime)
-{
-	if ((abstime == NULL) || !timespec_is_valid(abstime)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (k_sem_take(semaphore, K_MSEC(timespec_to_timeoutms(CLOCK_REALTIME, abstime)))) {
-		errno = ETIMEDOUT;
-		return -1;
-	}
-
-	return 0;
-}
-
-/**
- * @brief Lock a semaphore if not taken.
- *
- * See IEEE 1003.1
- */
-int sem_trywait(sem_t *semaphore)
-{
-	if (k_sem_take(semaphore, K_NO_WAIT) == -EBUSY) {
-		errno = EAGAIN;
-		return -1;
-	} else {
-		return 0;
-	}
-}
-
-/**
- * @brief Lock a semaphore.
- *
- * See IEEE 1003.1
- */
-int sem_wait(sem_t *semaphore)
-{
-	/* With K_FOREVER, may return only success. */
-	(void)k_sem_take(semaphore, K_FOREVER);
-	return 0;
-}
-
-sem_t *sem_open(const char *name, int oflags, ...)
-{
-	va_list va;
-	mode_t mode;
-	unsigned int value;
-	struct nsem_obj *nsem = NULL;
-	size_t namelen;
-
-	va_start(va, oflags);
-	BUILD_ASSERT(sizeof(mode_t) <= sizeof(int));
-	mode = va_arg(va, int);
-	value = va_arg(va, unsigned int);
-	va_end(va);
-
-	if (value > CONFIG_POSIX_SEM_VALUE_MAX) {
-		errno = EINVAL;
-		return (sem_t *)SEM_FAILED;
-	}
-
-	if (name == NULL) {
-		errno = EINVAL;
-		return (sem_t *)SEM_FAILED;
-	}
-
-	namelen = strlen(name);
-	if ((namelen + 1) > CONFIG_POSIX_SEM_NAMELEN_MAX) {
-		errno = ENAMETOOLONG;
-		return (sem_t *)SEM_FAILED;
-	}
-
-	/* Lock before checking to make sure that the call is atomic */
-	nsem_list_lock();
-
-	/* Check if the named semaphore exists */
-	nsem = nsem_find(name);
-
-	if (nsem != NULL) { /* Named semaphore exists */
-		if (((oflags & O_CREAT) != 0) && ((oflags & O_EXCL) != 0)) {
-			errno = EEXIST;
-			goto error_unlock;
-		}
-
-		__ASSERT_NO_MSG(nsem->ref_count != INT_MAX);
-		nsem->ref_count++;
-		goto unlock;
-	}
-
-	/* Named semaphore doesn't exist, try to create new one */
-
-	if ((oflags & O_CREAT) == 0) {
-		errno = ENOENT;
-		goto error_unlock;
-	}
-
-	nsem = k_calloc(1, sizeof(struct nsem_obj));
-	if (nsem == NULL) {
-		errno = ENOSPC;
-		goto error_unlock;
-	}
-
-	/* goto `cleanup_error_unlock` past this point to avoid memory leak */
-
-	nsem->name = k_calloc(namelen + 1, sizeof(uint8_t));
-	if (nsem->name == NULL) {
-		errno = ENOSPC;
-		goto cleanup_error_unlock;
-	}
-
-	strcpy(nsem->name, name);
-
-	/* 1 for this open instance, +1 for the linked name */
-	nsem->ref_count = 2;
-
-	(void)k_sem_init(&nsem->sem, value, CONFIG_POSIX_SEM_VALUE_MAX);
-
-	sys_slist_append(&nsem_list, (sys_snode_t *)&(nsem->snode));
-
-	goto unlock;
-
-cleanup_error_unlock:
-	nsem_cleanup(nsem);
-
-error_unlock:
-	nsem = NULL;
-
-unlock:
-	nsem_list_unlock();
-	return nsem == NULL ? SEM_FAILED : &nsem->sem;
-}
-
-int sem_unlink(const char *name)
-{
-	int ret = 0;
-	struct nsem_obj *nsem;
-
-	if (name == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if ((strlen(name) + 1)  > CONFIG_POSIX_SEM_NAMELEN_MAX) {
-		errno = ENAMETOOLONG;
-		return -1;
-	}
-
-	nsem_list_lock();
-
-	/* Check if queue already exists */
-	nsem = nsem_find(name);
-	if (nsem == NULL) {
-		ret = -1;
-		errno = ENOENT;
-		goto unlock;
-	}
-
-	k_free(nsem->name);
-	nsem->name = NULL;
-	nsem_unref(nsem);
-
-unlock:
-	nsem_list_unlock();
-	return ret;
-}
-
-int sem_close(sem_t *sem)
-{
-	struct nsem_obj *nsem = CONTAINER_OF(sem, struct nsem_obj, sem);
-
-	if (sem == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	nsem_list_lock();
-	nsem_unref(nsem);
-	nsem_list_unlock();
-	return 0;
-}
-
-#ifdef CONFIG_ZTEST
-/* Used by ztest to get the ref count of a named semaphore */
-int nsem_get_ref_count(sem_t *sem)
-{
-	struct nsem_obj *nsem = CONTAINER_OF(sem, struct nsem_obj, sem);
-	int ref_count;
-
-	__ASSERT_NO_MSG(sem != NULL);
-	__ASSERT_NO_MSG(nsem != NULL);
-
-	nsem_list_lock();
-	ref_count = nsem->ref_count;
-	nsem_list_unlock();
-
-	return ref_count;
-}
-
-/* Used by ztest to get the length of the named semaphore */
-size_t nsem_get_list_len(void)
-{
-	size_t len;
-
-	nsem_list_lock();
-	len = sys_slist_len(&nsem_list);
-	nsem_list_unlock();
-
-	return len;
-}
-#endif
diff --git a/lib/posix/options/shm.c b/lib/posix/options/shm.c
deleted file mode 100644
index b2b15da4ea3..00000000000
--- a/lib/posix/options/shm.c
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#undef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 200809L
-
-#include <fcntl.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <kernel_arch_interface.h>
-#include <zephyr/kernel.h>
-#include <zephyr/kernel/mm.h>
-#include <zephyr/sys/dlist.h>
-#include <zephyr/sys/fdtable.h>
-#include <zephyr/sys/hash_function.h>
-
-#define _page_size COND_CODE_1(CONFIG_MMU, (CONFIG_MMU_PAGE_SIZE), (CONFIG_POSIX_PAGE_SIZE))
-
-static const struct fd_op_vtable shm_vtable;
-
-static sys_dlist_t shm_list = SYS_DLIST_STATIC_INIT(&shm_list);
-
-struct shm_obj {
-	uint8_t *mem;
-	sys_dnode_t node;
-	size_t refs;
-	size_t size;
-	uint32_t hash;
-	bool unlinked: 1;
-	bool mapped: 1;
-};
-
-static inline uint32_t hash32(const char *str, size_t n)
-{
-	/* we need a hasher that is not sensitive to input alignment */
-	return sys_hash32_djb2(str, n);
-}
-
-static bool shm_obj_name_valid(const char *name, size_t len)
-{
-	if (name == NULL) {
-		return false;
-	}
-
-	if (name[0] != '/') {
-		return false;
-	}
-
-	if (len < 2) {
-		return false;
-	}
-
-	return true;
-}
-
-static struct shm_obj *shm_obj_find(uint32_t key)
-{
-	struct shm_obj *shm;
-
-	SYS_DLIST_FOR_EACH_CONTAINER(&shm_list, shm, node) {
-		if (shm->hash == key) {
-			return shm;
-		}
-	}
-
-	return NULL;
-}
-
-static void shm_obj_add(struct shm_obj *shm)
-{
-	sys_dlist_init(&shm->node);
-	sys_dlist_append(&shm_list, &shm->node);
-}
-
-static void shm_obj_remove(struct shm_obj *shm)
-{
-	sys_dlist_remove(&shm->node);
-	if (shm->size > 0) {
-		if (IS_ENABLED(CONFIG_MMU)) {
-			uintptr_t phys = 0;
-
-			if (arch_page_phys_get(shm->mem, &phys) == 0) {
-				k_mem_unmap(shm->mem, ROUND_UP(shm->size, _page_size));
-			}
-		} else {
-			k_free(shm->mem);
-		}
-	}
-	k_free(shm);
-}
-
-static int shm_fstat(struct shm_obj *shm, struct stat *st)
-{
-	*st = (struct stat){0};
-	st->st_mode = ZVFS_MODE_IFSHM;
-	st->st_size = shm->size;
-
-	return 0;
-}
-
-static int shm_ftruncate(struct shm_obj *shm, off_t length)
-{
-	void *virt;
-
-	if (length < 0) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (length == 0) {
-		if (shm->size != 0) {
-			/* only allow resizing this once, for consistence */
-			errno = EBUSY;
-			return -1;
-		}
-
-		return 0;
-	}
-
-	if (IS_ENABLED(CONFIG_MMU)) {
-		virt = k_mem_map(ROUND_UP(length, _page_size), K_MEM_PERM_RW);
-	} else {
-		virt = k_calloc(1, length);
-	}
-
-	if (virt == NULL) {
-		errno = ENOMEM;
-		return -1;
-	}
-
-	shm->mem = virt;
-	shm->size = length;
-
-	return 0;
-}
-
-static off_t shm_lseek(struct shm_obj *shm, off_t offset, int whence, size_t cur)
-{
-	size_t addend;
-
-	switch (whence) {
-	case SEEK_SET:
-		addend = 0;
-		break;
-	case SEEK_CUR:
-		addend = cur;
-		break;
-	case SEEK_END:
-		addend = shm->size;
-		break;
-	default:
-		errno = EINVAL;
-		return -1;
-	}
-
-	if ((addend > INTPTR_MAX) || ((INTPTR_MAX - addend) < offset)) {
-		errno = EOVERFLOW;
-		return -1;
-	}
-
-	offset += addend;
-	if (offset < 0) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	return offset;
-}
-
-static int shm_mmap(struct shm_obj *shm, void *addr, size_t len, int prot, int flags, off_t off,
-		    void **virt)
-{
-	ARG_UNUSED(addr);
-	ARG_UNUSED(prot);
-	__ASSERT_NO_MSG(virt != NULL);
-
-	if ((len == 0) || (off < 0) || ((flags & MAP_FIXED) != 0) ||
-	    ((off & (_page_size - 1)) != 0) || ((len + off) > shm->size)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (!IS_ENABLED(CONFIG_MMU)) {
-		errno = ENOTSUP;
-		return -1;
-	}
-
-	if (shm->mem == NULL) {
-		errno = ENOMEM;
-		return -1;
-	}
-
-	/*
-	 * Note: due to Zephyr's page mapping algorithm, physical pages can only have 1
-	 * mapping, so different file handles will have the same virtual memory address
-	 * underneath.
-	 */
-	*virt = shm->mem + off;
-
-	return 0;
-}
-
-static ssize_t shm_rw(struct shm_obj *shm, void *buf, size_t size, bool is_write, size_t offset)
-{
-	if (offset >= shm->size) {
-		size = 0;
-	} else {
-		size = min(size, shm->size - offset);
-	}
-
-	if (size > 0) {
-		if (is_write) {
-			memcpy(&shm->mem[offset], buf, size);
-		} else {
-			memcpy(buf, &shm->mem[offset], size);
-		}
-	}
-
-	return size;
-}
-
-static ssize_t shm_read(void *obj, void *buf, size_t sz, size_t offset)
-{
-	return shm_rw((struct shm_obj *)obj, buf, sz, false, offset);
-}
-
-static ssize_t shm_write(void *obj, const void *buf, size_t sz, size_t offset)
-{
-	return shm_rw((struct shm_obj *)obj, (void *)buf, sz, true, offset);
-}
-
-static int shm_close(void *obj)
-{
-	struct shm_obj *shm = obj;
-
-	shm->refs -= (shm->refs > 0) ? 1 : 0;
-	if (shm->unlinked && (shm->refs == 0)) {
-		shm_obj_remove(shm);
-	}
-
-	return 0;
-}
-
-static int shm_ioctl(void *obj, unsigned int request, va_list args)
-{
-	struct shm_obj *shm = obj;
-
-	switch (request) {
-	case ZFD_IOCTL_LSEEK: {
-		off_t offset = va_arg(args, off_t);
-		int whence = va_arg(args, int);
-		size_t cur = va_arg(args, size_t);
-
-		return shm_lseek(shm, offset, whence, cur);
-	} break;
-	case ZFD_IOCTL_MMAP: {
-		void *addr = va_arg(args, void *);
-		size_t len = va_arg(args, size_t);
-		int prot = va_arg(args, int);
-		int flags = va_arg(args, int);
-		off_t off = va_arg(args, off_t);
-		void **maddr = va_arg(args, void **);
-
-		return shm_mmap(shm, addr, len, prot, flags, off, maddr);
-	} break;
-	case ZFD_IOCTL_SET_LOCK:
-		break;
-	case ZFD_IOCTL_STAT: {
-		struct stat *st = va_arg(args, struct stat *);
-
-		return shm_fstat(shm, st);
-	} break;
-	case ZFD_IOCTL_TRUNCATE: {
-		off_t length = va_arg(args, off_t);
-
-		return shm_ftruncate(shm, length);
-	} break;
-	default:
-		errno = ENOTSUP;
-		return -1;
-	}
-
-	return 0;
-}
-
-static const struct fd_op_vtable shm_vtable = {
-	.read_offs = shm_read,
-	.write_offs = shm_write,
-	.close = shm_close,
-	.ioctl = shm_ioctl,
-};
-
-int shm_open(const char *name, int oflag, mode_t mode)
-{
-	int fd;
-	uint32_t key;
-	struct shm_obj *shm;
-	bool rd = (oflag & O_RDONLY) != 0;
-	bool rw = (oflag & O_RDWR) != 0;
-	bool creat = (oflag & O_CREAT) != 0;
-	bool excl = (oflag & O_EXCL) != 0;
-	bool trunc = (oflag & O_TRUNC) != 0;
-	size_t name_len = (name == NULL) ? 0 : strnlen(name, PATH_MAX);
-
-	/* revisit when file-based permissions are available */
-	if ((mode & 0777) == 0) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (!(rd ^ rw)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (rd && trunc) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (!shm_obj_name_valid(name, name_len)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	fd = zvfs_reserve_fd();
-	if (fd < 0) {
-		errno = EMFILE;
-		return -1;
-	}
-
-	key = hash32(name, name_len);
-	shm = shm_obj_find(key);
-	if ((shm != NULL) && shm->unlinked) {
-		/* we cannot open a shm object that has already been unlinked */
-		errno = EACCES;
-		return -1;
-	}
-
-	if (creat) {
-		if ((shm != NULL) && excl) {
-			zvfs_free_fd(fd);
-			errno = EEXIST;
-			return -1;
-		}
-
-		if (shm == NULL) {
-			shm = k_calloc(1, sizeof(*shm));
-			if (shm == NULL) {
-				zvfs_free_fd(fd);
-				errno = ENOSPC;
-				return -1;
-			}
-
-			shm->hash = key;
-			shm_obj_add(shm);
-		}
-	} else if (shm == NULL) {
-		errno = ENOENT;
-		return -1;
-	}
-
-	++shm->refs;
-	zvfs_finalize_typed_fd(fd, shm, &shm_vtable, ZVFS_MODE_IFSHM);
-
-	return fd;
-}
-
-int shm_unlink(const char *name)
-{
-	uint32_t key;
-	struct shm_obj *shm;
-	size_t name_len = (name == NULL) ? 0 : strnlen(name, PATH_MAX);
-
-	if (!shm_obj_name_valid(name, name_len)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	key = hash32(name, name_len);
-	shm = shm_obj_find(key);
-	if ((shm == NULL) || shm->unlinked) {
-		errno = ENOENT;
-		return -1;
-	}
-
-	shm->unlinked = true;
-	if (shm->refs == 0) {
-		shm_obj_remove(shm);
-	}
-
-	return 0;
-}
diff --git a/lib/posix/options/signal.c b/lib/posix/options/signal.c
deleted file mode 100644
index f7f0a7fd421..00000000000
--- a/lib/posix/options/signal.c
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include "posix/strsignal_table.h"
-
-#include <errno.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdio.h>
-#include <time.h>
-
-#include <zephyr/sys/util.h>
-
-#define SIGNO_WORD_IDX(_signo) (_signo / BITS_PER_LONG)
-#define SIGNO_WORD_BIT(_signo) (_signo & BIT_MASK(LOG2(BITS_PER_LONG)))
-
-#define SIGSET_NLONGS (sizeof(sigset_t) / sizeof(unsigned long))
-
-static inline bool signo_valid(int signo)
-{
-	return ((signo > 0) && (signo <= SIGRTMAX));
-}
-
-static inline bool signo_is_rt(int signo)
-{
-	return ((signo >= SIGRTMIN) && (signo <= SIGRTMAX));
-}
-
-static inline bool signo_fits(int signo)
-{
-	/* technically, 0 is not a valid signal number, but it still fits */
-	return ((signo >= 0) && (signo < SIGSET_NLONGS * BITS_PER_LONG));
-}
-
-#undef sigemptyset
-int sigemptyset(sigset_t *set)
-{
-	*set = (sigset_t){0};
-	return 0;
-}
-
-#undef sigfillset
-int sigfillset(sigset_t *set)
-{
-	unsigned long *const _set = (unsigned long *)set;
-
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		_set[i] = -1;
-	}
-
-	return 0;
-}
-
-#undef sigaddset
-int sigaddset(sigset_t *set, int signo)
-{
-	unsigned long *_set = (unsigned long *)set;
-
-	if (!signo_valid(signo)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (!signo_fits(signo)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	WRITE_BIT(_set[SIGNO_WORD_IDX(signo)], SIGNO_WORD_BIT(signo), 1);
-
-	return 0;
-}
-
-#undef sigdelset
-int sigdelset(sigset_t *set, int signo)
-{
-	unsigned long *_set = (unsigned long *)set;
-
-	if (!signo_valid(signo)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (!signo_fits(signo)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	WRITE_BIT(_set[SIGNO_WORD_IDX(signo)], SIGNO_WORD_BIT(signo), 0);
-
-	return 0;
-}
-
-#undef sigismember
-int sigismember(const sigset_t *set, int signo)
-{
-	const unsigned long *const _set = (const unsigned long *)set;
-
-	if (!signo_valid(signo)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (!signo_fits(signo)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	return 1 & (_set[SIGNO_WORD_IDX(signo)] >> SIGNO_WORD_BIT(signo));
-}
-
-char *strsignal(int signum)
-{
-	/* Using -INT_MAX here because compiler resolves INT_MIN to (-2147483647 - 1) */
-	static char buf[sizeof("RT signal -" STRINGIFY(INT_MAX))];
-
-	if (!signo_valid(signum)) {
-		errno = EINVAL;
-		return "Invalid signal";
-	}
-
-	if (signo_is_rt(signum)) {
-		snprintf(buf, sizeof(buf), "RT signal %d", signum - SIGRTMIN);
-		return buf;
-	}
-
-	if (IS_ENABLED(CONFIG_POSIX_SIGNAL_STRING_DESC)) {
-		if (strsignal_list[signum] != NULL) {
-			return (char *)strsignal_list[signum];
-		}
-	}
-
-	snprintf(buf, sizeof(buf), "Signal %d", signum);
-
-	return buf;
-}
-
-int sigprocmask(int how, const sigset_t *ZRESTRICT set, sigset_t *ZRESTRICT oset)
-{
-	if (!IS_ENABLED(CONFIG_MULTITHREADING)) {
-		return pthread_sigmask(how, set, oset);
-	}
-
-	/*
-	 * Until Zephyr supports processes and specifically querying the number of active threads in
-	 * a process For more information, see
-	 * https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_sigmask.html
-	 */
-	__ASSERT(false, "In multi-threaded environments, please use pthread_sigmask() instead of "
-			"%s()", __func__);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-/*
- * The functions below are provided so that conformant POSIX applications and libraries can still
- * link.
- */
-
-unsigned int alarm(unsigned int seconds)
-{
-	ARG_UNUSED(seconds);
-	return 0;
-}
-
-int kill(pid_t pid, int sig)
-{
-	ARG_UNUSED(pid);
-	ARG_UNUSED(sig);
-	errno = ENOSYS;
-	return -1;
-}
-#ifdef CONFIG_POSIX_SIGNALS_ALIAS_KILL
-FUNC_ALIAS(kill, _kill, int);
-#endif /* CONFIG_POSIX_SIGNALS_ALIAS_KILL */
-
-int pause(void)
-{
-	errno = ENOSYS;
-	return -1;
-}
-
-int sigaction(int sig, const struct sigaction *ZRESTRICT act, struct sigaction *ZRESTRICT oact)
-{
-	ARG_UNUSED(sig);
-	ARG_UNUSED(act);
-	ARG_UNUSED(oact);
-	errno = ENOSYS;
-	return -1;
-}
-
-int sigpending(sigset_t *set)
-{
-	ARG_UNUSED(set);
-	errno = ENOSYS;
-	return -1;
-}
-
-int sigsuspend(const sigset_t *sigmask)
-{
-	ARG_UNUSED(sigmask);
-	errno = ENOSYS;
-	return -1;
-}
-
-int sigwait(const sigset_t *ZRESTRICT set, int *ZRESTRICT sig)
-{
-	ARG_UNUSED(set);
-	ARG_UNUSED(sig);
-	errno = ENOSYS;
-	return -1;
-}
diff --git a/lib/posix/options/sleep.c b/lib/posix/options/sleep.c
deleted file mode 100644
index d45cb3e6a82..00000000000
--- a/lib/posix/options/sleep.c
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-
-#include <zephyr/kernel.h>
-#include <unistd.h>
-
-/**
- * @brief Sleep for a specified number of seconds.
- *
- * See IEEE 1003.1
- */
-unsigned sleep(unsigned int seconds)
-{
-	int rem;
-
-	rem = k_sleep(K_SECONDS(seconds));
-	__ASSERT_NO_MSG(rem >= 0);
-
-	return rem / MSEC_PER_SEC;
-}
diff --git a/lib/posix/options/spinlock.c b/lib/posix/options/spinlock.c
deleted file mode 100644
index 54ee44f4834..00000000000
--- a/lib/posix/options/spinlock.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_internal.h"
-
-#include <pthread.h>
-
-#include <zephyr/init.h>
-#include <zephyr/kernel.h>
-#include <zephyr/sys/bitarray.h>
-
-union _spinlock_storage {
-	struct k_spinlock lock;
-	uint8_t byte;
-};
-#if !defined(CONFIG_CPP) && !defined(CONFIG_SMP) && !defined(CONFIG_SPIN_VALIDATE)
-BUILD_ASSERT(sizeof(struct k_spinlock) == 0,
-	     "please remove the _spinlock_storage workaround if, at some point, k_spinlock is no "
-	     "longer zero bytes when CONFIG_SMP=n && CONFIG_SPIN_VALIDATE=n");
-#endif
-
-static union _spinlock_storage posix_spinlock_pool[CONFIG_MAX_PTHREAD_SPINLOCK_COUNT];
-static k_spinlock_key_t posix_spinlock_key[CONFIG_MAX_PTHREAD_SPINLOCK_COUNT];
-SYS_BITARRAY_DEFINE_STATIC(posix_spinlock_bitarray, CONFIG_MAX_PTHREAD_SPINLOCK_COUNT);
-
-/*
- * We reserve the MSB to mark a pthread_spinlock_t as initialized (from the
- * perspective of the application). With a linear space, this means that
- * the theoretical pthread_spinlock_t range is [0,2147483647].
- */
-BUILD_ASSERT(CONFIG_MAX_PTHREAD_SPINLOCK_COUNT < PTHREAD_OBJ_MASK_INIT,
-	"CONFIG_MAX_PTHREAD_SPINLOCK_COUNT is too high");
-
-static inline size_t posix_spinlock_to_offset(struct k_spinlock *l)
-{
-	return (union _spinlock_storage *)l - posix_spinlock_pool;
-}
-
-static inline size_t to_posix_spinlock_idx(pthread_spinlock_t lock)
-{
-	return mark_pthread_obj_uninitialized(lock);
-}
-
-static struct k_spinlock *get_posix_spinlock(pthread_spinlock_t *lock)
-{
-	size_t bit;
-	int actually_initialized;
-
-	if (lock == NULL) {
-		return NULL;
-	}
-
-	/* if the provided spinlock does not claim to be initialized, its invalid */
-	bit = to_posix_spinlock_idx(*lock);
-	if (!is_pthread_obj_initialized(*lock)) {
-		return NULL;
-	}
-
-	/* Mask off the MSB to get the actual bit index */
-	if (sys_bitarray_test_bit(&posix_spinlock_bitarray, bit, &actually_initialized) < 0) {
-		return NULL;
-	}
-
-	if (actually_initialized == 0) {
-		/* The spinlock claims to be initialized but is actually not */
-		return NULL;
-	}
-
-	return (struct k_spinlock *)&posix_spinlock_pool[bit];
-}
-
-int pthread_spin_init(pthread_spinlock_t *lock, int pshared)
-{
-	int ret;
-	size_t bit;
-
-	if (lock == NULL ||
-	    !(pshared == PTHREAD_PROCESS_PRIVATE || pshared == PTHREAD_PROCESS_SHARED)) {
-		/* not specified as part of POSIX but this is the Linux behavior */
-		return EINVAL;
-	}
-
-	ret = sys_bitarray_alloc(&posix_spinlock_bitarray, 1, &bit);
-	if (ret < 0) {
-		return ENOMEM;
-	}
-
-	*lock = mark_pthread_obj_initialized(bit);
-
-	return 0;
-}
-
-int pthread_spin_destroy(pthread_spinlock_t *lock)
-{
-	int err;
-	size_t bit;
-	struct k_spinlock *l;
-
-	l = get_posix_spinlock(lock);
-	if (l == NULL) {
-		/* not specified as part of POSIX but this is the Linux behavior */
-		return EINVAL;
-	}
-
-	bit = posix_spinlock_to_offset(l);
-	err = sys_bitarray_free(&posix_spinlock_bitarray, 1, bit);
-	__ASSERT_NO_MSG(err == 0);
-
-	return 0;
-}
-
-int pthread_spin_lock(pthread_spinlock_t *lock)
-{
-	size_t bit;
-	struct k_spinlock *l;
-
-	l = get_posix_spinlock(lock);
-	if (l == NULL) {
-		/* not specified as part of POSIX but this is the Linux behavior */
-		return EINVAL;
-	}
-
-	bit = posix_spinlock_to_offset(l);
-	posix_spinlock_key[bit] = k_spin_lock(l);
-
-	return 0;
-}
-
-int pthread_spin_trylock(pthread_spinlock_t *lock)
-{
-	size_t bit;
-	struct k_spinlock *l;
-
-	l = get_posix_spinlock(lock);
-	if (l == NULL) {
-		/* not specified as part of POSIX but this is the Linux behavior */
-		return EINVAL;
-	}
-
-	bit = posix_spinlock_to_offset(l);
-	return k_spin_trylock(l, &posix_spinlock_key[bit]);
-}
-
-int pthread_spin_unlock(pthread_spinlock_t *lock)
-{
-	size_t bit;
-	struct k_spinlock *l;
-
-	l = get_posix_spinlock(lock);
-	if (l == NULL) {
-		/* not specified as part of POSIX but this is the Linux behavior */
-		return EINVAL;
-	}
-
-	bit = posix_spinlock_to_offset(l);
-	k_spin_unlock(l, posix_spinlock_key[bit]);
-
-	return 0;
-}
diff --git a/lib/posix/options/stropts.c b/lib/posix/options/stropts.c
deleted file mode 100644
index 08fa5bc67e1..00000000000
--- a/lib/posix/options/stropts.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2024 Abhinav Srivastava
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stdarg.h>
-
-#include <zephyr/kernel.h>
-#include <stropts.h>
-
-int putmsg(int fildes, const struct strbuf *ctlptr, const struct strbuf *dataptr, int flags)
-{
-	ARG_UNUSED(fildes);
-	ARG_UNUSED(ctlptr);
-	ARG_UNUSED(dataptr);
-	ARG_UNUSED(flags);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int putpmsg(int fildes, const struct strbuf *ctlptr, const struct strbuf *dataptr, int band,
-	    int flags)
-{
-	ARG_UNUSED(fildes);
-	ARG_UNUSED(ctlptr);
-	ARG_UNUSED(dataptr);
-	ARG_UNUSED(band);
-	ARG_UNUSED(flags);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int fdetach(const char *path)
-{
-	ARG_UNUSED(path);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int fattach(int fildes, const char *path)
-{
-	ARG_UNUSED(fildes);
-	ARG_UNUSED(path);
-	errno = ENOSYS;
-
-	return -1;
-}
-
-int getmsg(int fildes, struct strbuf *ctlptr, struct strbuf *dataptr, int *flagsp)
-{
-	ARG_UNUSED(fildes);
-	ARG_UNUSED(ctlptr);
-	ARG_UNUSED(dataptr);
-	ARG_UNUSED(flagsp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int getpmsg(int fildes, struct strbuf *ctlptr, struct strbuf *dataptr, int *bandp, int *flagsp)
-{
-	ARG_UNUSED(fildes);
-	ARG_UNUSED(ctlptr);
-	ARG_UNUSED(dataptr);
-	ARG_UNUSED(bandp);
-	ARG_UNUSED(flagsp);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-int isastream(int fildes)
-{
-	ARG_UNUSED(fildes);
-
-	errno = ENOSYS;
-	return -1;
-}
-
-extern int zvfs_ioctl(int fd, unsigned long request, va_list args);
-
-int ioctl(int fd, unsigned long request, ...)
-{
-	int ret;
-	va_list args;
-
-	va_start(args, request);
-	ret = zvfs_ioctl(fd, request, args);
-	va_end(args);
-
-	return ret;
-}
diff --git a/lib/posix/options/sysconf.c b/lib/posix/options/sysconf.c
deleted file mode 100644
index b9c2d2a974d..00000000000
--- a/lib/posix/options/sysconf.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifdef CONFIG_POSIX_SYSCONF_IMPL_FULL
-
-#include <errno.h>
-#include <limits.h>
-#include <unistd.h>
-
-#include <zephyr/sys/util.h>
-
-long sysconf(int name)
-{
-	switch (name) {
-	case _SC_ADVISORY_INFO:
-		return -1L;
-	case _SC_ASYNCHRONOUS_IO:
-		return COND_CODE_1(CONFIG_POSIX_ASYNCHRONOUS_IO, (_POSIX_VERSION), (-1L));
-	case _SC_BARRIERS:
-		return COND_CODE_1(CONFIG_POSIX_BARRIERS, (_POSIX_VERSION), (-1L));
-	case _SC_CLOCK_SELECTION:
-		return COND_CODE_1(CONFIG_POSIX_CLOCK_SELECTION, (_POSIX_VERSION), (-1L));
-	case _SC_CPUTIME:
-		return COND_CODE_1(CONFIG_POSIX_CPUTIME, (_POSIX_VERSION), (-1L));
-	case _SC_FSYNC:
-		return COND_CODE_1(CONFIG_POSIX_FSYNC, (_POSIX_VERSION), (-1L));
-	case _SC_IPV6:
-		return COND_CODE_1(CONFIG_NET_IPV6, (_POSIX_VERSION), (-1L));
-	case _SC_JOB_CONTROL:
-		return -1L;
-	case _SC_MAPPED_FILES:
-		return COND_CODE_1(CONFIG_POSIX_MAPPED_FILES, (_POSIX_VERSION), (-1L));
-	case _SC_MEMLOCK:
-		return COND_CODE_1(CONFIG_POSIX_MEMLOCK, (_POSIX_VERSION), (-1L));
-	case _SC_MEMLOCK_RANGE:
-		return COND_CODE_1(CONFIG_POSIX_MEMLOCK_RANGE, (_POSIX_VERSION), (-1L));
-	case _SC_MEMORY_PROTECTION:
-		return COND_CODE_1(CONFIG_POSIX_MEMORY_PROTECTION, (_POSIX_VERSION), (-1L));
-	case _SC_MESSAGE_PASSING:
-		return COND_CODE_1(CONFIG_POSIX_MESSAGE_PASSING, (_POSIX_VERSION), (-1L));
-	case _SC_MONOTONIC_CLOCK:
-		return COND_CODE_1(CONFIG_POSIX_MONOTONIC_CLOCK, (_POSIX_VERSION), (-1L));
-	case _SC_PRIORITIZED_IO:
-		return -1L;
-	case _SC_PRIORITY_SCHEDULING:
-		return COND_CODE_1(CONFIG_POSIX_PRIORITY_SCHEDULING, (_POSIX_VERSION), (-1L));
-	case _SC_RAW_SOCKETS:
-		return COND_CODE_1(CONFIG_NET_SOCKETS_PACKET, (_POSIX_VERSION), (-1L));
-	case _SC_RE_DUP_MAX:
-		return _POSIX_RE_DUP_MAX;
-	case _SC_READER_WRITER_LOCKS:
-		return COND_CODE_1(CONFIG_POSIX_RW_LOCKS, (_POSIX_VERSION), (-1L));
-	case _SC_REALTIME_SIGNALS:
-		return -1L;
-	case _SC_REGEXP:
-		return -1L;
-	case _SC_SAVED_IDS:
-		return -1L;
-	case _SC_SEMAPHORES:
-		return COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (_POSIX_VERSION), (-1L));
-	case _SC_SHARED_MEMORY_OBJECTS:
-		return COND_CODE_1(CONFIG_POSIX_SHARED_MEMORY_OBJECTS, (_POSIX_VERSION), (-1L));
-	case _SC_SHELL:
-		return -1L;
-	case _SC_SPAWN:
-		return -1L;
-	case _SC_SPIN_LOCKS:
-		return COND_CODE_1(CONFIG_POSIX_SPIN_LOCKS, (_POSIX_VERSION), (-1L));
-	case _SC_SPORADIC_SERVER:
-		return -1L;
-	case _SC_SS_REPL_MAX:
-		return _POSIX_SS_REPL_MAX;
-	case _SC_SYNCHRONIZED_IO:
-		return -1L;
-	case _SC_THREAD_ATTR_STACKADDR:
-		return COND_CODE_1(CONFIG_POSIX_THREAD_ATTR_STACKADDR, (_POSIX_VERSION), (-1L));
-	case _SC_THREAD_ATTR_STACKSIZE:
-		return COND_CODE_1(CONFIG_POSIX_THREAD_ATTR_STACKSIZE, (_POSIX_VERSION), (-1L));
-	case _SC_THREAD_CPUTIME:
-		return -1L;
-	case _SC_THREAD_PRIO_INHERIT:
-		return COND_CODE_1(CONFIG_POSIX_THREAD_PRIO_INHERIT, (_POSIX_VERSION), (-1L));
-	case _SC_THREAD_PRIO_PROTECT:
-		return -1L;
-	case _SC_THREAD_PRIORITY_SCHEDULING:
-		return COND_CODE_1(CONFIG_POSIX_THREAD_PRIORITY_SCHEDULING, (_POSIX_VERSION),
-			(-1L));
-	case _SC_THREAD_PROCESS_SHARED:
-		return -1L;
-	case _SC_THREAD_ROBUST_PRIO_INHERIT:
-		return -1L;
-	case _SC_THREAD_ROBUST_PRIO_PROTECT:
-		return -1L;
-	case _SC_THREAD_SAFE_FUNCTIONS:
-		return COND_CODE_1(CONFIG_POSIX_THREAD_SAFE_FUNCTIONS, (_POSIX_VERSION), (-1L));
-	case _SC_THREAD_SPORADIC_SERVER:
-		return -1L;
-	case _SC_THREADS:
-		return COND_CODE_1(CONFIG_POSIX_THREADS, (_POSIX_VERSION), (-1L));
-	case _SC_TIMEOUTS:
-		return COND_CODE_1(CONFIG_POSIX_TIMEOUTS, (_POSIX_VERSION), (-1L));
-	case _SC_TIMERS:
-		return COND_CODE_1(CONFIG_POSIX_TIMERS, (_POSIX_VERSION), (-1L));
-	case _SC_TRACE:
-		return -1L;
-	case _SC_TRACE_EVENT_FILTER:
-		return -1L;
-	case _SC_TRACE_EVENT_NAME_MAX:
-		return _POSIX_TRACE_NAME_MAX;
-	case _SC_TRACE_INHERIT:
-		return -1L;
-	case _SC_TRACE_LOG:
-		return -1L;
-	case _SC_TRACE_NAME_MAX:
-		return _POSIX_TRACE_NAME_MAX;
-	case _SC_TRACE_SYS_MAX:
-		return _POSIX_TRACE_SYS_MAX;
-	case _SC_TRACE_USER_EVENT_MAX:
-		return _POSIX_TRACE_USER_EVENT_MAX;
-	case _SC_TYPED_MEMORY_OBJECTS:
-		return -1L;
-	case _SC_VERSION:
-		return _POSIX_VERSION;
-	case _SC_V7_ILP32_OFF32:
-		return -1L;
-	case _SC_V7_ILP32_OFFBIG:
-		return -1L;
-	case _SC_V7_LP64_OFF64:
-		return -1L;
-	case _SC_V7_LPBIG_OFFBIG:
-		return -1L;
-	case _SC_BC_BASE_MAX:
-		return -1L;
-	case _SC_BC_DIM_MAX:
-		return -1L;
-	case _SC_BC_SCALE_MAX:
-		return -1L;
-	case _SC_BC_STRING_MAX:
-		return -1L;
-	case _SC_2_C_BIND:
-		return -1L;
-	case _SC_2_C_DEV:
-		return COND_CODE_1(_POSIX2_C_DEV > 0, (_POSIX2_C_DEV), (-1));
-	case _SC_2_CHAR_TERM:
-		return -1L;
-	case _SC_COLL_WEIGHTS_MAX:
-		return -1L;
-	case _SC_DELAYTIMER_MAX:
-		return COND_CODE_1(CONFIG_POSIX_TIMERS, (CONFIG_POSIX_DELAYTIMER_MAX), (0));
-	case _SC_EXPR_NEST_MAX:
-		return -1L;
-	case _SC_2_FORT_DEV:
-		return -1L;
-	case _SC_2_FORT_RUN:
-		return -1L;
-	case _SC_LINE_MAX:
-		return -1L;
-	case _SC_2_LOCALEDEF:
-		return -1L;
-	case _SC_2_PBS:
-		return -1L;
-	case _SC_2_PBS_ACCOUNTING:
-		return -1L;
-	case _SC_2_PBS_CHECKPOINT:
-		return -1L;
-	case _SC_2_PBS_LOCATE:
-		return -1L;
-	case _SC_2_PBS_MESSAGE:
-		return -1L;
-	case _SC_2_PBS_TRACK:
-		return -1L;
-	case _SC_2_SW_DEV:
-		return -1L;
-	case _SC_2_UPE:
-		return -1L;
-	case _SC_2_VERSION:
-		return COND_CODE_1(_POSIX2_VERSION > 0, (_POSIX2_VERSION), (-1));
-	case _SC_XOPEN_CRYPT:
-		return -1L;
-	case _SC_XOPEN_ENH_I18N:
-		return -1L;
-	case _SC_XOPEN_REALTIME:
-		return COND_CODE_1(CONFIG_XSI_REALTIME, (_XOPEN_VERSION), (-1));
-	case _SC_XOPEN_REALTIME_THREADS:
-		return -1L;
-	case _SC_XOPEN_SHM:
-		return -1L;
-	case _SC_XOPEN_STREAMS:
-		return COND_CODE_1(CONFIG_XSI_STREAMS, (_XOPEN_STREAMS), (-1));
-	case _SC_XOPEN_UNIX:
-		return COND_CODE_1(CONFIG_XSI, (_XOPEN_UNIX), (-1));
-	case _SC_XOPEN_UUCP:
-		return -1L;
-	case _SC_XOPEN_VERSION:
-		return COND_CODE_1(CONFIG_XSI, (_XOPEN_VERSION), (0));
-	case _SC_CLK_TCK:
-		return 100L;
-	case _SC_GETGR_R_SIZE_MAX:
-		return 0L;
-	case _SC_GETPW_R_SIZE_MAX:
-		return 0L;
-	case _SC_AIO_LISTIO_MAX:
-		return _POSIX_AIO_LISTIO_MAX;
-	case _SC_AIO_MAX:
-		return _POSIX_AIO_MAX;
-	case _SC_AIO_PRIO_DELTA_MAX:
-		return 0;
-	case _SC_ARG_MAX:
-		return _POSIX_ARG_MAX;
-	case _SC_ATEXIT_MAX:
-		return 32;
-	case _SC_CHILD_MAX:
-		return _POSIX_CHILD_MAX;
-	case _SC_HOST_NAME_MAX:
-		return COND_CODE_1(CONFIG_POSIX_NETWORKING, (CONFIG_POSIX_HOST_NAME_MAX), (0));
-	case _SC_IOV_MAX:
-		return 16;
-	case _SC_LOGIN_NAME_MAX:
-		return _POSIX_LOGIN_NAME_MAX;
-	case _SC_NGROUPS_MAX:
-		return _POSIX_NGROUPS_MAX;
-	case _SC_MQ_OPEN_MAX:
-		return COND_CODE_1(CONFIG_POSIX_MESSAGE_PASSING, (CONFIG_POSIX_MQ_OPEN_MAX), (0));
-	case _SC_MQ_PRIO_MAX:
-		return _POSIX_MQ_PRIO_MAX;
-	case _SC_OPEN_MAX:
-		return CONFIG_POSIX_OPEN_MAX;
-	case _SC_PAGE_SIZE:
-		return CONFIG_POSIX_PAGE_SIZE;
-	case _SC_THREAD_DESTRUCTOR_ITERATIONS:
-		return _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
-	case _SC_THREAD_KEYS_MAX:
-		return COND_CODE_1(CONFIG_POSIX_THREADS, (CONFIG_POSIX_THREAD_KEYS_MAX), (0));
-	case _SC_THREAD_STACK_MIN:
-		return 0;
-	case _SC_THREAD_THREADS_MAX:
-		return COND_CODE_1(CONFIG_POSIX_THREADS, (CONFIG_POSIX_THREAD_THREADS_MAX), (0));
-	case _SC_RTSIG_MAX:
-		return COND_CODE_1(CONFIG_POSIX_REALTIME_SIGNALS, (CONFIG_POSIX_RTSIG_MAX), (0));
-	case _SC_SEM_NSEMS_MAX:
-		return COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (CONFIG_POSIX_SEM_NSEMS_MAX), (0));
-	case _SC_SEM_VALUE_MAX:
-		return COND_CODE_1(CONFIG_POSIX_SEMAPHORES, (CONFIG_POSIX_SEM_VALUE_MAX), (0));
-	case _SC_SIGQUEUE_MAX:
-		return _POSIX_SIGQUEUE_MAX;
-	case _SC_STREAM_MAX:
-		return _POSIX_STREAM_MAX;
-	case _SC_SYMLOOP_MAX:
-		return _POSIX_SYMLOOP_MAX;
-	case _SC_TIMER_MAX:
-		return COND_CODE_1(CONFIG_POSIX_TIMERS, (CONFIG_POSIX_TIMER_MAX), (0));
-	case _SC_TTY_NAME_MAX:
-		return _POSIX_TTY_NAME_MAX;
-	case _SC_TZNAME_MAX:
-		return _POSIX_TZNAME_MAX;
-	default:
-		errno = EINVAL;
-		return -1;
-	}
-}
-
-#endif
diff --git a/lib/posix/options/syslog.c b/lib/posix/options/syslog.c
deleted file mode 100644
index 791b7258d2b..00000000000
--- a/lib/posix/options/syslog.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include <errno.h>
-
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <zephyr/sys/printk.h>
-
-#undef LOG_ERR
-#include <syslog.h>
-
-static struct k_spinlock syslog_lock;
-static uint8_t syslog_mask;
-
-static int syslog_priority_to_zephyr_log_level(int priority)
-{
-	switch (priority) {
-	case LOG_EMERG:
-	case LOG_ALERT:
-	case LOG_CRIT:
-	case LOG_ERR:
-		return LOG_LEVEL_ERR;
-	case LOG_WARNING:
-		return LOG_LEVEL_WRN;
-	case LOG_NOTICE:
-	case LOG_INFO:
-		return LOG_LEVEL_INF;
-	case LOG_DEBUG:
-		return LOG_LEVEL_DBG;
-	default:
-		return -EINVAL;
-	}
-}
-
-void closelog(void)
-{
-}
-
-void openlog(const char *ident, int option, int facility)
-{
-	ARG_UNUSED(ident);
-	ARG_UNUSED(option);
-	ARG_UNUSED(facility);
-}
-
-void syslog(int priority, const char *format, ...)
-{
-	va_list ap;
-
-	va_start(ap, format);
-	vsyslog(priority, format, ap);
-	va_end(ap);
-}
-
-int setlogmask(int maskpri)
-{
-	int oldpri = -1;
-
-	K_SPINLOCK(&syslog_lock) {
-		oldpri = syslog_mask;
-		syslog_mask = maskpri;
-	}
-
-	return oldpri;
-}
-
-void vsyslog(int priority, const char *format, va_list ap)
-{
-	uint8_t mask = 0;
-	int level = syslog_priority_to_zephyr_log_level(priority);
-
-	if (level < 0) {
-		/* invalid priority */
-		return;
-	}
-
-	K_SPINLOCK(&syslog_lock) {
-		mask = syslog_mask;
-	}
-
-	if ((BIT(level) & mask) == 0) {
-		/* masked */
-		return;
-	}
-
-#if !defined(CONFIG_LOG) || defined(CONFIG_LOG_MODE_MINIMAL)
-	vprintk(format, ap);
-#else
-	log_generic(level, format, ap);
-#endif
-}
diff --git a/lib/posix/options/timer.c b/lib/posix/options/timer.c
deleted file mode 100644
index 7cc491d730c..00000000000
--- a/lib/posix/options/timer.c
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#undef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 200809L
-
-#include "posix_clock.h"
-
-#include <errno.h>
-#include <signal.h>
-#include <time.h>
-
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <zephyr/sys/clock.h>
-#include <pthread.h>
-
-#define ACTIVE 1
-#define NOT_ACTIVE 0
-
-LOG_MODULE_REGISTER(posix_timer);
-
-static void zephyr_timer_wrapper(struct k_timer *ztimer);
-
-struct timer_obj {
-	struct k_timer ztimer;
-	struct sigevent evp;
-	struct k_sem sem_cond;
-	pthread_t thread;
-	struct timespec interval;	/* Reload value */
-	uint32_t reload;			/* Reload value in ms */
-	uint32_t status;
-};
-
-K_MEM_SLAB_DEFINE(posix_timer_slab, sizeof(struct timer_obj), CONFIG_POSIX_TIMER_MAX,
-		  __alignof__(struct timer_obj));
-
-static void zephyr_timer_wrapper(struct k_timer *ztimer)
-{
-	struct timer_obj *timer;
-
-	timer = (struct timer_obj *)ztimer;
-
-	if (timer->reload == 0U) {
-		timer->status = NOT_ACTIVE;
-		LOG_DBG("timer %p not active", timer);
-	}
-
-	if (timer->evp.sigev_notify == SIGEV_NONE) {
-		LOG_DBG("SIGEV_NONE");
-		return;
-	}
-
-	if (timer->evp.sigev_notify_function == NULL) {
-		LOG_DBG("NULL sigev_notify_function");
-		return;
-	}
-
-	LOG_DBG("calling sigev_notify_function %p", timer->evp.sigev_notify_function);
-	(timer->evp.sigev_notify_function)(timer->evp.sigev_value);
-}
-
-static void *zephyr_thread_wrapper(void *arg)
-{
-	int ret;
-	struct timer_obj *timer = (struct timer_obj *)arg;
-
-	ret = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
-	__ASSERT(ret == 0, "pthread_setcanceltype() failed: %d", ret);
-
-	if (timer->evp.sigev_notify_attributes == NULL) {
-		ret = pthread_detach(pthread_self());
-		__ASSERT(ret == 0, "pthread_detach() failed: %d", ret);
-	}
-
-	while (1) {
-		if (timer->reload == 0U) {
-			timer->status = NOT_ACTIVE;
-			LOG_DBG("timer %p not active", timer);
-		}
-
-		ret = k_sem_take(&timer->sem_cond, K_FOREVER);
-		__ASSERT(ret == 0, "k_sem_take() failed: %d", ret);
-
-		if (timer->evp.sigev_notify_function == NULL) {
-			LOG_DBG("NULL sigev_notify_function");
-			continue;
-		}
-
-		LOG_DBG("calling sigev_notify_function %p", timer->evp.sigev_notify_function);
-		(timer->evp.sigev_notify_function)(timer->evp.sigev_value);
-	}
-
-	return NULL;
-}
-
-static void zephyr_timer_interrupt(struct k_timer *ztimer)
-{
-	struct timer_obj *timer;
-
-	timer = (struct timer_obj *)ztimer;
-	k_sem_give(&timer->sem_cond);
-}
-
-/**
- * @brief Create a per-process timer.
- *
- * This API does not accept SIGEV_THREAD as valid signal event notification
- * type.
- *
- * See IEEE 1003.1
- */
-int timer_create(clockid_t clockid, struct sigevent *evp, timer_t *timerid)
-{
-	int ret = 0;
-	int detachstate;
-	struct timer_obj *timer;
-	const k_timeout_t alloc_timeout = K_MSEC(CONFIG_TIMER_CREATE_WAIT);
-
-	if (evp == NULL || timerid == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	switch (clockid) {
-	case CLOCK_REALTIME:
-		break;
-#ifdef _POSIX_MONOTONIC_CLOCK
-	case CLOCK_MONOTONIC:
-		break;
-#endif
-	default:
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (k_mem_slab_alloc(&posix_timer_slab, (void **)&timer, alloc_timeout) != 0) {
-		LOG_DBG("k_mem_slab_alloc() failed: %d", ret);
-		errno = ENOMEM;
-		return -1;
-	}
-
-	*timer = (struct timer_obj){0};
-	timer->evp = *evp;
-	evp = &timer->evp;
-
-	switch (evp->sigev_notify) {
-	case SIGEV_NONE:
-		k_timer_init(&timer->ztimer, NULL, NULL);
-		break;
-	case SIGEV_SIGNAL:
-		k_timer_init(&timer->ztimer, zephyr_timer_wrapper, NULL);
-		break;
-	case SIGEV_THREAD:
-		if (evp->sigev_notify_attributes != NULL) {
-			ret = pthread_attr_getdetachstate(evp->sigev_notify_attributes,
-							  &detachstate);
-			if (ret != 0) {
-				LOG_DBG("pthread_attr_getdetachstate() failed: %d", ret);
-				errno = ret;
-				ret = -1;
-				goto free_timer;
-			}
-
-			if (detachstate != PTHREAD_CREATE_DETACHED) {
-				ret = pthread_attr_setdetachstate(evp->sigev_notify_attributes,
-								  PTHREAD_CREATE_DETACHED);
-				if (ret != 0) {
-					LOG_DBG("pthread_attr_setdetachstate() failed: %d", ret);
-					errno = ret;
-					ret = -1;
-					goto free_timer;
-				}
-			}
-		}
-
-		ret = k_sem_init(&timer->sem_cond, 0, 1);
-		if (ret != 0) {
-			LOG_DBG("k_sem_init() failed: %d", ret);
-			errno = -ret;
-			ret = -1;
-			goto free_timer;
-		}
-
-		ret = pthread_create(&timer->thread, evp->sigev_notify_attributes,
-							zephyr_thread_wrapper, timer);
-		if (ret != 0) {
-			LOG_DBG("pthread_create() failed: %d", ret);
-			errno = ret;
-			ret = -1;
-			goto free_timer;
-		}
-
-		k_timer_init(&timer->ztimer, zephyr_timer_interrupt, NULL);
-		break;
-	default:
-		ret = -1;
-		errno = EINVAL;
-		goto free_timer;
-	}
-
-	*timerid = (timer_t)timer;
-	goto out;
-
-free_timer:
-	k_mem_slab_free(&posix_timer_slab, (void *)timer);
-
-out:
-	return ret;
-}
-
-/**
- * @brief Get amount of time left for expiration on a per-process timer.
- *
- * See IEEE 1003.1
- */
-int timer_gettime(timer_t timerid, struct itimerspec *its)
-{
-	struct timer_obj *timer = (struct timer_obj *)timerid;
-	int32_t remaining, leftover;
-	int64_t   nsecs, secs;
-
-	if (timer == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (timer->status == ACTIVE) {
-		remaining = k_timer_remaining_get(&timer->ztimer);
-		secs =  remaining / MSEC_PER_SEC;
-		leftover = remaining - (secs * MSEC_PER_SEC);
-		nsecs = (int64_t)leftover * NSEC_PER_MSEC;
-		its->it_value.tv_sec = (int32_t) secs;
-		its->it_value.tv_nsec = (int32_t) nsecs;
-	} else {
-		/* Timer is disarmed */
-		its->it_value.tv_sec = 0;
-		its->it_value.tv_nsec = 0;
-	}
-
-	/* The interval last set by timer_settime() */
-	its->it_interval = timer->interval;
-	return 0;
-}
-
-/**
- * @brief Sets expiration time of per-process timer.
- *
- * See IEEE 1003.1
- */
-int timer_settime(timer_t timerid, int flags, const struct itimerspec *value,
-		  struct itimerspec *ovalue)
-{
-	struct timer_obj *timer = (struct timer_obj *) timerid;
-	uint32_t duration, current;
-
-	if ((timer == NULL) || !timespec_is_valid(&value->it_interval) ||
-	    !timespec_is_valid(&value->it_value)) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	/*  Save time to expire and old reload value. */
-	if (ovalue != NULL) {
-		timer_gettime(timerid, ovalue);
-	}
-
-	/* Stop the timer if the value is 0 */
-	if ((value->it_value.tv_sec == 0) && (value->it_value.tv_nsec == 0)) {
-		if (timer->status == ACTIVE) {
-			k_timer_stop(&timer->ztimer);
-		}
-
-		timer->status = NOT_ACTIVE;
-		return 0;
-	}
-
-	/* Calculate timer period */
-	timer->reload = ts_to_ms(&value->it_interval);
-	timer->interval.tv_sec = value->it_interval.tv_sec;
-	timer->interval.tv_nsec = value->it_interval.tv_nsec;
-
-	/* Calculate timer duration */
-	duration = ts_to_ms(&(value->it_value));
-	if ((flags & TIMER_ABSTIME) != 0) {
-		current = k_timer_remaining_get(&timer->ztimer);
-
-		if (current >= duration) {
-			duration = 0U;
-		} else {
-			duration -= current;
-		}
-	}
-
-	if (timer->status == ACTIVE) {
-		k_timer_stop(&timer->ztimer);
-	}
-
-	timer->status = ACTIVE;
-	k_timer_start(&timer->ztimer, K_MSEC(duration), K_MSEC(timer->reload));
-	return 0;
-}
-
-/**
- * @brief Returns the timer expiration overrun count.
- *
- * See IEEE 1003.1
- */
-int timer_getoverrun(timer_t timerid)
-{
-	struct timer_obj *timer = (struct timer_obj *) timerid;
-
-	if (timer == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	int overruns = k_timer_status_get(&timer->ztimer) - 1;
-
-	if (overruns > CONFIG_POSIX_DELAYTIMER_MAX) {
-		overruns = CONFIG_POSIX_DELAYTIMER_MAX;
-	}
-
-	return overruns;
-}
-
-/**
- * @brief Delete a per-process timer.
- *
- * See IEEE 1003.1
- */
-int timer_delete(timer_t timerid)
-{
-	struct timer_obj *timer = (struct timer_obj *) timerid;
-
-	if (timer == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (timer->status == ACTIVE) {
-		timer->status = NOT_ACTIVE;
-		k_timer_stop(&timer->ztimer);
-	}
-
-	if (timer->evp.sigev_notify == SIGEV_THREAD) {
-		(void)pthread_cancel(timer->thread);
-	}
-
-	k_mem_slab_free(&posix_timer_slab, (void *)timer);
-
-	return 0;
-}
diff --git a/lib/posix/options/timespec_to_timeout.c b/lib/posix/options/timespec_to_timeout.c
deleted file mode 100644
index 4c6cceddb00..00000000000
--- a/lib/posix/options/timespec_to_timeout.c
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2017 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-
-#include <limits.h>
-#include <stdint.h>
-#include <time.h>
-
-#include <zephyr/sys/clock.h>
-#include <zephyr/sys/util.h>
-
-uint32_t timespec_to_timeoutms(int clock_id, const struct timespec *abstime)
-{
-	struct timespec curtime;
-
-	if (sys_clock_gettime(sys_clock_from_clockid(clock_id), &curtime) < 0) {
-		return 0;
-	}
-
-	return clamp(tp_diff(abstime, &curtime) / NSEC_PER_MSEC, 0, UINT32_MAX);
-}
diff --git a/lib/posix/options/uname.c b/lib/posix/options/uname.c
deleted file mode 100644
index b57d9281c15..00000000000
--- a/lib/posix/options/uname.c
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <string.h>
-#include <zephyr/kernel.h>
-#include <zephyr/net/hostname.h>
-#include <sys/utsname.h>
-#include <zephyr/version.h>
-
-#ifdef CONFIG_NET_HOSTNAME_ENABLE
-#define UTSNAME_NODENAME CONFIG_NET_HOSTNAME
-#else
-#define UTSNAME_NODENAME "zephyr"
-#endif
-
-#if defined(__DATE__) && defined(__TIME__)
-#define UTSNAME_VERSION(_ver) _ver " " __DATE__ " " __TIME__
-#else
-#define UTSNAME_VERSION(_ver) _ver
-#endif
-
-#if defined(BUILD_VERSION) && !IS_EMPTY(BUILD_VERSION)
-#define VERSION_BUILD STRINGIFY(BUILD_VERSION)
-#else
-#define VERSION_BUILD KERNEL_VERSION_STRING
-#endif
-
-#define UTSNAME_INITIALIZER(_sys, _node, _rel, _ver, _mach)                                        \
-	{                                                                                          \
-		.sysname = _sys, .nodename = _node, .release = _rel,                               \
-		.version = UTSNAME_VERSION(_ver), .machine = _mach,                                \
-	}
-
-static const struct utsname z_name = UTSNAME_INITIALIZER(
-	"Zephyr", UTSNAME_NODENAME, KERNEL_VERSION_STRING, VERSION_BUILD, CONFIG_ARCH);
-
-BUILD_ASSERT(sizeof(z_name.sysname) >= sizeof("Zephyr"));
-BUILD_ASSERT(sizeof(z_name.release) >= sizeof(KERNEL_VERSION_STRING));
-BUILD_ASSERT(sizeof(z_name.version) >= sizeof(UTSNAME_VERSION(VERSION_BUILD)));
-BUILD_ASSERT(sizeof(z_name.machine) >= sizeof(CONFIG_ARCH));
-
-int uname(struct utsname *name)
-{
-	memcpy(name, &z_name, sizeof(*name));
-	if (IS_ENABLED(CONFIG_NET_HOSTNAME_ENABLE)) {
-		strncpy(name->nodename, net_hostname_get(), sizeof(name->nodename));
-		name->nodename[sizeof(name->nodename) - 1] = '\0';
-	}
-	return 0;
-}
diff --git a/lib/posix/options/xsi_single_process.c b/lib/posix/options/xsi_single_process.c
deleted file mode 100644
index 006577fedbe..00000000000
--- a/lib/posix/options/xsi_single_process.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023 Meta
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <string.h>
-#include <sys/time.h>
-#include <time.h>
-
-#include <zephyr/drivers/hwinfo.h>
-#include <zephyr/kernel.h>
-#include <zephyr/logging/log.h>
-#include <zephyr/sys_clock.h>
-#include <zephyr/sys/clock.h>
-#include <zephyr/toolchain.h>
-
-LOG_MODULE_REGISTER(xsi_single_process, CONFIG_XSI_SINGLE_PROCESS_LOG_LEVEL);
-
-extern int z_setenv(const char *name, const char *val, int overwrite);
-
-long gethostid(void)
-{
-	int rc;
-	uint32_t buf = 0;
-
-	rc = hwinfo_get_device_id((uint8_t *)&buf, sizeof(buf));
-	if ((rc < 0) || (rc != sizeof(buf)) || (buf == 0)) {
-		LOG_DBG("%s() failed: %d", "hwinfo_get_device_id", rc);
-		return (long)rc;
-	}
-
-	return (long)buf;
-}
-
-int gettimeofday(struct timeval *tv, void *tz)
-{
-	struct timespec ts;
-	int res;
-
-	/*
-	 * As per POSIX, "if tzp is not a null pointer, the behavior is unspecified."  "tzp" is the
-	 * "tz" parameter above.
-	 */
-	ARG_UNUSED(tz);
-
-	res = sys_clock_gettime(SYS_CLOCK_REALTIME, &ts);
-	if (res < 0) {
-		LOG_DBG("%s() failed: %d", "sys_clock_gettime", res);
-		errno = -res;
-		return -1;
-	}
-
-	tv->tv_sec = ts.tv_sec;
-	tv->tv_usec = ts.tv_nsec / NSEC_PER_USEC;
-
-	return 0;
-}
-
-int putenv(char *string)
-{
-	if (string == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	char *const name = string;
-
-	for (char *val = name; *val != '\0'; ++val) {
-		if (*val == '=') {
-			int rc;
-
-			*val = '\0';
-			++val;
-			rc = z_setenv(name, val, 1);
-			--val;
-			*val = '=';
-
-			if (rc < 0) {
-				LOG_DBG("%s() failed: %d", "setenv", rc);
-				return rc;
-			}
-
-			return 0;
-		}
-	}
-
-	/* was unable to find '=' in string */
-	errno = EINVAL;
-	return -1;
-}
diff --git a/lib/posix/shell/CMakeLists.txt b/lib/posix/shell/CMakeLists.txt
deleted file mode 100644
index 2d809f5b74f..00000000000
--- a/lib/posix/shell/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-# Copyright (c) 2024 Meta
-# SPDX-License-Identifier: Apache-2.0
-
-zephyr_library()
-# For setenv() and unsetenv()
-zephyr_library_compile_options(-U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-# For getenv_r() visibility
-zephyr_library_compile_definitions(_BSD_SOURCE)
-
-zephyr_library_sources_ifdef(CONFIG_POSIX_SHELL posix_shell.c)
-zephyr_library_sources_ifdef(CONFIG_POSIX_UNAME_SHELL uname.c)
-zephyr_library_sources_ifdef(CONFIG_POSIX_ENV_SHELL env.c)
diff --git a/lib/posix/shell/Kconfig b/lib/posix/shell/Kconfig
deleted file mode 100644
index 294d97a8b79..00000000000
--- a/lib/posix/shell/Kconfig
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (c) 2024 Meta
-# SPDX-License-Identifier: Apache-2.0
-
-menu "POSIX Shell Utilities"
-
-if SHELL
-
-config POSIX_SHELL
-	bool
-	help
-	  Compile the parent `posix` shell command.
-
-rsource "Kconfig.env"
-rsource "Kconfig.uname"
-
-endif # SHELL
-
-endmenu # "POSIX Shell Utilities"
diff --git a/lib/posix/shell/Kconfig.env b/lib/posix/shell/Kconfig.env
deleted file mode 100644
index bbe36bc9cbb..00000000000
--- a/lib/posix/shell/Kconfig.env
+++ /dev/null
@@ -1,9 +0,0 @@
-# Copyright (c) 2024 Meta
-# SPDX-License-Identifier: Apache-2.0
-
-config POSIX_ENV_SHELL
-	bool "Support for shell"
-	select POSIX_SINGLE_PROCESS
-	select POSIX_SHELL
-	help
-	  This shell provides access to system environment variables.
diff --git a/lib/posix/shell/Kconfig.uname b/lib/posix/shell/Kconfig.uname
deleted file mode 100644
index 73547e3ac84..00000000000
--- a/lib/posix/shell/Kconfig.uname
+++ /dev/null
@@ -1,13 +0,0 @@
-# Copyright (c) 2024 Meta
-# SPDX-License-Identifier: Apache-2.0
-
-if POSIX_SINGLE_PROCESS
-
-config POSIX_UNAME_SHELL
-	bool "Support for `uname` command"
-	select SHELL_GETOPT
-	select POSIX_SHELL
-	help
-	  Support for `uname` command in the terminal.
-
-endif # POSIX_SINGLE_PROCESS
diff --git a/lib/posix/shell/env.c b/lib/posix/shell/env.c
deleted file mode 100644
index 48b3b2a94e3..00000000000
--- a/lib/posix/shell/env.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_shell.h"
-
-#include <ctype.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <zephyr/shell/shell.h>
-
-#define HELP_ENV_GET   "[NAME]"
-#define HELP_ENV_SET   "NAME VALUE | NAME=VALUE"
-#define HELP_ENV_UNSET "NAME.."
-
-static int cmd_env_get(const struct shell *sh, size_t argc, char **argv)
-{
-	const char *name;
-	const char *value;
-
-	switch (argc) {
-	case 1: {
-		extern char **environ;
-		/* list all environment variables */
-		if (environ != NULL) {
-			for (char **envp = environ; *envp != NULL; ++envp) {
-				shell_print(sh, "%s", *envp);
-			}
-		}
-	} break;
-	case 2:
-		/* list a specific environment variable */
-		name = argv[1];
-		value = getenv(name);
-		if (value != NULL) {
-			shell_print(sh, "%s", value);
-		}
-		break;
-	default:
-		return EXIT_FAILURE;
-	}
-
-	return EXIT_SUCCESS;
-}
-
-static bool is_shell_env_name(const char *name)
-{
-	char c;
-
-	if (name == NULL || name[0] == '\0') {
-		return false;
-	}
-
-	for (size_t i = 0, N = strlen(name); i < N; ++i) {
-		c = name[i];
-
-		if (c == '_') {
-			continue;
-		}
-
-		if (isalpha(c)) {
-			continue;
-		}
-
-		if (i > 0 && isdigit(c)) {
-			continue;
-		}
-
-		return false;
-	}
-
-	return true;
-}
-
-static int cmd_env_set(const struct shell *sh, size_t argc, char **argv)
-{
-	int ret;
-	char *value;
-	const char *name;
-
-	switch (argc) {
-	case 2:
-		name = argv[1];
-		value = strchr(argv[1], '=');
-		if (value != NULL) {
-			*value = '\0';
-			++value;
-		}
-		break;
-	case 3:
-		name = argv[1];
-		value = argv[2];
-		break;
-	default:
-		return EXIT_FAILURE;
-	}
-
-	/* silently drop "poorly conditioned" environment variables */
-	if (!is_shell_env_name(name)) {
-		shell_print(sh, "bad name");
-		return EXIT_SUCCESS;
-	}
-
-	ret = setenv(name, value, 1);
-	if (ret == -1) {
-		return EXIT_FAILURE;
-	}
-
-	return EXIT_SUCCESS;
-}
-
-static int cmd_env_unset(const struct shell *sh, size_t argc, char **argv)
-{
-	for (--argc, ++argv; argc > 0; --argc, ++argv) {
-		(void)unsetenv(argv[0]);
-	}
-
-	return EXIT_SUCCESS;
-}
-
-SHELL_STATIC_SUBCMD_SET_CREATE(sub_env, SHELL_CMD(set, NULL, HELP_ENV_SET, cmd_env_set),
-			       SHELL_CMD(get, NULL, HELP_ENV_GET, cmd_env_get),
-			       SHELL_CMD(unset, NULL, HELP_ENV_UNSET, cmd_env_unset),
-			       SHELL_SUBCMD_SET_END /* Array terminated. */
-);
-
-POSIX_CMD_ADD(env, &sub_env, "Print system information", NULL, 1, 255);
diff --git a/lib/posix/shell/posix_shell.c b/lib/posix/shell/posix_shell.c
deleted file mode 100644
index 95fdd4ef5a0..00000000000
--- a/lib/posix/shell/posix_shell.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/*
- * Copyright (c) 2024 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/shell/shell.h>
-
-SHELL_SUBCMD_SET_CREATE(posix_cmds, (posix));
-SHELL_CMD_ARG_REGISTER(posix, &posix_cmds, "POSIX shell commands", NULL, 2, 0);
diff --git a/lib/posix/shell/posix_shell.h b/lib/posix/shell/posix_shell.h
deleted file mode 100644
index cb17d613b18..00000000000
--- a/lib/posix/shell/posix_shell.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- * Copyright (c) 2024 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef ZEPHYR_LIB_POSIX_SHELL_POSIX_SHELL_H_
-#define ZEPHYR_LIB_POSIX_SHELL_POSIX_SHELL_H_
-
-#include <zephyr/shell/shell.h>
-
-/* Add command to the set of POSIX subcommands, see `SHELL_SUBCMD_ADD` */
-#define POSIX_CMD_ADD(_syntax, _subcmd, _help, _handler, _mand, _opt)                              \
-	SHELL_SUBCMD_ADD((posix), _syntax, _subcmd, _help, _handler, _mand, _opt);
-
-#endif /* ZEPHYR_LIB_POSIX_SHELL_POSIX_SHELL_H_ */
diff --git a/lib/posix/shell/uname.c b/lib/posix/shell/uname.c
deleted file mode 100644
index 305e32bc5ef..00000000000
--- a/lib/posix/shell/uname.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (c) 2024 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <unistd.h>
-
-#include "posix_shell.h"
-
-#include <sys/utsname.h>
-#include <zephyr/shell/shell.h>
-
-#define UNAME_KERNEL   BIT(0)
-#define UNAME_NODE     BIT(1)
-#define UNAME_RELEASE  BIT(2)
-#define UNAME_VERSION  BIT(3)
-#define UNAME_MACHINE  BIT(4)
-#define UNAME_PLATFORM BIT(5)
-#define UNAME_UNKNOWN  BIT(6)
-#define UNAME_ALL                                                                                  \
-	(UNAME_KERNEL | UNAME_NODE | UNAME_RELEASE | UNAME_VERSION | UNAME_MACHINE | UNAME_PLATFORM)
-
-#define HELP_USAGE                                                                                 \
-	"Usage: uname [OPTION]\n"                                                                  \
-	"Print system information\n"                                                               \
-	"\n"                                                                                       \
-	"    -a,  all informationn\n"                                                              \
-	"    -s,  kernel name\n"                                                                   \
-	"    -o,  operating system\n"                                                              \
-	"    -n,  network node hostname\n"                                                         \
-	"    -r,  kernel release\n"                                                                \
-	"    -v,  kernel version\n"                                                                \
-	"    -m,  machine hardware name\n"                                                         \
-	"    -p,  processor type\n"                                                                \
-	"    -i,  hardware platform\n"
-
-static void uname_print_usage(const struct shell *sh)
-{
-	shell_print(sh, HELP_USAGE);
-}
-
-static int uname_cmd_handler(const struct shell *sh, size_t argc, char **argv)
-{
-	struct getopt_state *state = getopt_state_get();
-	struct utsname info;
-	unsigned int set;
-	int option;
-	char badarg = 0;
-	int ret;
-
-	set = 0;
-
-	/* Get the uname options */
-
-	optind = 1;
-	while ((option = getopt(argc, argv, "asonrvmpi")) != -1) {
-		switch (option) {
-		case 'a':
-			set = UNAME_ALL;
-			break;
-
-		case 'o':
-		case 's':
-			set |= UNAME_KERNEL;
-			break;
-
-		case 'n':
-			set |= UNAME_NODE;
-			break;
-
-		case 'r':
-			set |= UNAME_RELEASE;
-			break;
-
-		case 'v':
-			set |= UNAME_VERSION;
-			break;
-
-		case 'm':
-			set |= UNAME_MACHINE;
-			break;
-
-		case 'p':
-			if (set != UNAME_ALL) {
-				set |= UNAME_UNKNOWN;
-			}
-			break;
-
-		case 'i':
-			set |= UNAME_PLATFORM;
-			break;
-
-		case '?':
-		default:
-			badarg = (char)state->optopt;
-			break;
-		}
-	}
-
-	if (argc != optind) {
-		shell_error(sh, "uname: extra operand %s", argv[optind]);
-		uname_print_usage(sh);
-		return -1;
-	}
-
-	/* If a bad argument was encountered, then return without processing the
-	 * command
-	 */
-
-	if (badarg != 0) {
-		shell_error(sh, "uname: illegal option -- %c", badarg);
-		uname_print_usage(sh);
-		return -1;
-	}
-
-	/* If nothing is provided on the command line, the default is -s */
-
-	if (set == 0) {
-		set = UNAME_KERNEL;
-	}
-
-	/* Get uname data */
-
-	ret = uname(&info);
-	if (ret < 0) {
-		shell_error(sh, "cannot get system name");
-		return -1;
-	}
-
-	/* Process each option */
-
-	/* print the kernel/operating system name */
-	if (set & UNAME_KERNEL) {
-		shell_fprintf(sh, SHELL_NORMAL, "%s ", info.sysname);
-	}
-
-	/* Print nodename */
-	if (set & UNAME_NODE) {
-		shell_fprintf(sh, SHELL_NORMAL, "%s ", info.nodename);
-	}
-
-	/* Print the kernel release */
-	if (set & UNAME_RELEASE) {
-		shell_fprintf(sh, SHELL_NORMAL, "%s ", info.release);
-	}
-
-	/* Print the kernel version */
-	if (set & UNAME_VERSION) {
-		shell_fprintf(sh, SHELL_NORMAL, "%s ", info.version);
-	}
-
-	/* Print the machine hardware name */
-	if (set & UNAME_MACHINE) {
-		shell_fprintf(sh, SHELL_NORMAL, "%s ", info.machine);
-	}
-
-	/* Print the machine platform name */
-	if (set & UNAME_PLATFORM) {
-		shell_fprintf(sh, SHELL_NORMAL, "%s ", CONFIG_BOARD);
-	}
-
-	/* Print "unknown" */
-	if (set & UNAME_UNKNOWN) {
-		shell_fprintf(sh, SHELL_NORMAL, "%s ", "unknown");
-	}
-
-	shell_fprintf(sh, SHELL_NORMAL, "\n");
-
-	return 0;
-}
-
-POSIX_CMD_ADD(uname, NULL, "Print system information", uname_cmd_handler, 1, 1);
diff --git a/tests/posix/barriers/CMakeLists.txt b/tests/posix/barriers/CMakeLists.txt
deleted file mode 100644
index 31a050bb62f..00000000000
--- a/tests/posix/barriers/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_barriers)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/barriers/prj.conf b/tests/posix/barriers/prj.conf
deleted file mode 100644
index bef0f3193bc..00000000000
--- a/tests/posix/barriers/prj.conf
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_BARRIERS=y
diff --git a/tests/posix/barriers/src/main.c b/tests/posix/barriers/src/main.c
deleted file mode 100644
index 3c0fa492477..00000000000
--- a/tests/posix/barriers/src/main.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2023, Harshil Bhatt
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-#include <semaphore.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-ZTEST(posix_barriers, test_barrier)
-{
-	int ret, pshared;
-	pthread_barrierattr_t attr;
-
-	ret = pthread_barrierattr_init(&attr);
-	zassert_equal(ret, 0, "pthread_barrierattr_init failed");
-
-	ret = pthread_barrierattr_getpshared(&attr, &pshared);
-	zassert_equal(ret, 0, "pthread_barrierattr_getpshared failed");
-	zassert_equal(pshared, PTHREAD_PROCESS_PRIVATE, "pshared attribute not set correctly");
-
-	ret = pthread_barrierattr_setpshared(&attr, PTHREAD_PROCESS_PRIVATE);
-	zassert_equal(ret, 0, "pthread_barrierattr_setpshared failed");
-
-	ret = pthread_barrierattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
-	zassert_equal(ret, 0, "pthread_barrierattr_setpshared failed");
-
-	ret = pthread_barrierattr_getpshared(&attr, &pshared);
-	zassert_equal(ret, 0, "pthread_barrierattr_getpshared failed");
-	zassert_equal(pshared, PTHREAD_PROCESS_SHARED, "pshared attribute not retrieved correctly");
-
-	ret = pthread_barrierattr_setpshared(&attr, 42);
-	zassert_equal(ret, -EINVAL, "pthread_barrierattr_setpshared did not return EINVAL");
-
-	ret = pthread_barrierattr_destroy(&attr);
-	zassert_equal(ret, 0, "pthread_barrierattr_destroy failed");
-}
-
-ZTEST_SUITE(posix_barriers, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/barriers/testcase.yaml b/tests/posix/barriers/testcase.yaml
deleted file mode 100644
index 1636c2b640c..00000000000
--- a/tests/posix/barriers/testcase.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - barriers
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_cortex_a53
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.barriers: {}
-  portability.posix.barriers.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.barriers.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.barriers.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/c_lib_ext/CMakeLists.txt b/tests/posix/c_lib_ext/CMakeLists.txt
deleted file mode 100644
index 24c7cfd2194..00000000000
--- a/tests/posix/c_lib_ext/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_c_lib_ext)
-
-FILE(GLOB app_sources src/*.c)
-
-target_sources(app PRIVATE ${app_sources})
-
-target_include_directories(app PRIVATE ${ZEPHYR_BASE}/lib/posix/options/getopt)
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/c_lib_ext/prj.conf b/tests/posix/c_lib_ext/prj.conf
deleted file mode 100644
index 7e8b0675c52..00000000000
--- a/tests/posix/c_lib_ext/prj.conf
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_C_LIB_EXT=y
-CONFIG_GETOPT_LONG=y
-CONFIG_ENTROPY_GENERATOR=y
diff --git a/tests/posix/c_lib_ext/src/fnmatch.c b/tests/posix/c_lib_ext/src/fnmatch.c
deleted file mode 100644
index e3dd298ca8e..00000000000
--- a/tests/posix/c_lib_ext/src/fnmatch.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <fnmatch.h>
-#include <zephyr/ztest.h>
-
-/*
- * Adapted from
- * https://git.musl-libc.org/cgit/libc-testsuite/tree/fnmatch.c
- */
-ZTEST(posix_c_lib_ext, test_fnmatch)
-{
-	/* Note: commented out lines indicate known problems to be addressed in #55186 */
-
-	zassert_ok(fnmatch("*.c", "foo.c", 0));
-	zassert_ok(fnmatch("*.c", ".c", 0));
-	zassert_equal(fnmatch("*.a", "foo.c", 0), FNM_NOMATCH);
-	zassert_ok(fnmatch("*.c", ".foo.c", 0));
-	zassert_equal(fnmatch("*.c", ".foo.c", FNM_PERIOD), FNM_NOMATCH);
-	zassert_ok(fnmatch("*.c", "foo.c", FNM_PERIOD));
-	zassert_equal(fnmatch("a\\*.c", "a*.c", FNM_NOESCAPE), FNM_NOMATCH);
-	zassert_equal(fnmatch("a\\*.c", "ax.c", 0), FNM_NOMATCH);
-	zassert_ok(fnmatch("a[xy].c", "ax.c", 0));
-	zassert_ok(fnmatch("a[!y].c", "ax.c", 0));
-	zassert_equal(fnmatch("a[a/z]*.c", "a/x.c", FNM_PATHNAME), FNM_NOMATCH);
-	zassert_ok(fnmatch("a/*.c", "a/x.c", FNM_PATHNAME));
-	zassert_equal(fnmatch("a*.c", "a/x.c", FNM_PATHNAME), FNM_NOMATCH);
-	zassert_ok(fnmatch("*/foo", "/foo", FNM_PATHNAME));
-	zassert_ok(fnmatch("-O[01]", "-O1", 0));
-	zassert_ok(fnmatch("[[?*\\]", "\\", 0));
-	zassert_ok(fnmatch("[]?*\\]", "]", 0));
-	zassert_ok(fnmatch("[!]a-]", "b", 0));
-	zassert_ok(fnmatch("[]-_]", "^", 0));
-	zassert_ok(fnmatch("[!]-_]", "X", 0));
-	zassert_equal(fnmatch("??", "-", 0), FNM_NOMATCH);
-	zassert_equal(fnmatch("*LIB*", "lib", FNM_PERIOD), FNM_NOMATCH);
-	zassert_ok(fnmatch("a[/]b", "a/b", 0));
-	zassert_equal(fnmatch("a[/]b", "a/b", FNM_PATHNAME), FNM_NOMATCH);
-	zassert_ok(fnmatch("[a-z]/[a-z]", "a/b", 0));
-	zassert_equal(fnmatch("*", "a/b", FNM_PATHNAME), FNM_NOMATCH);
-	zassert_equal(fnmatch("*[/]b", "a/b", FNM_PATHNAME), FNM_NOMATCH);
-	zassert_equal(fnmatch("*[b]", "a/b", FNM_PATHNAME), FNM_NOMATCH);
-	zassert_equal(fnmatch("[*]/b", "a/b", 0), FNM_NOMATCH);
-	zassert_ok(fnmatch("[*]/b", "*/b", 0));
-	zassert_equal(fnmatch("[?]/b", "a/b", 0), FNM_NOMATCH);
-	zassert_ok(fnmatch("[?]/b", "?/b", 0));
-	zassert_ok(fnmatch("[[a]/b", "a/b", 0));
-	zassert_ok(fnmatch("[[a]/b", "[/b", 0));
-	zassert_equal(fnmatch("\\*/b", "a/b", 0), FNM_NOMATCH);
-	zassert_ok(fnmatch("\\*/b", "*/b", 0));
-	zassert_equal(fnmatch("\\?/b", "a/b", 0), FNM_NOMATCH);
-	zassert_ok(fnmatch("\\?/b", "?/b", 0));
-	zassert_ok(fnmatch("[/b", "[/b", 0));
-	zassert_ok(fnmatch("\\[/b", "[/b", 0));
-	zassert_ok(fnmatch("??"
-			   "/b",
-			   "aa/b", 0));
-	zassert_ok(fnmatch("???b", "aa/b", 0));
-	zassert_equal(fnmatch("???b", "aa/b", FNM_PATHNAME), FNM_NOMATCH);
-	zassert_equal(fnmatch("?a/b", ".a/b", FNM_PATHNAME | FNM_PERIOD), FNM_NOMATCH);
-	zassert_equal(fnmatch("a/?b", "a/.b", FNM_PATHNAME | FNM_PERIOD), FNM_NOMATCH);
-	zassert_equal(fnmatch("*a/b", ".a/b", FNM_PATHNAME | FNM_PERIOD), FNM_NOMATCH);
-	zassert_equal(fnmatch("a/*b", "a/.b", FNM_PATHNAME | FNM_PERIOD), FNM_NOMATCH);
-	zassert_equal(fnmatch("[.]a/b", ".a/b", FNM_PATHNAME | FNM_PERIOD), FNM_NOMATCH);
-	zassert_equal(fnmatch("a/[.]b", "a/.b", FNM_PATHNAME | FNM_PERIOD), FNM_NOMATCH);
-	zassert_ok(fnmatch("*/?", "a/b", FNM_PATHNAME | FNM_PERIOD));
-	zassert_ok(fnmatch("?/*", "a/b", FNM_PATHNAME | FNM_PERIOD));
-	zassert_ok(fnmatch(".*/?", ".a/b", FNM_PATHNAME | FNM_PERIOD));
-	zassert_ok(fnmatch("*/.?", "a/.b", FNM_PATHNAME | FNM_PERIOD));
-	zassert_equal(fnmatch("*/*", "a/.b", FNM_PATHNAME | FNM_PERIOD), FNM_NOMATCH);
-	zassert_ok(fnmatch("*?*/*", "a/.b", FNM_PERIOD));
-	zassert_ok(fnmatch("*[.]/b", "a./b", FNM_PATHNAME | FNM_PERIOD));
-	/* zassert_ok(fnmatch("*[[:alpha:]]/""*[[:alnum:]]", "a/b", FNM_PATHNAME)); */
-	zassert_not_equal(fnmatch("*[![:digit:]]*/[![:d-d]", "a/b", FNM_PATHNAME), 0);
-	zassert_not_equal(fnmatch("*[![:digit:]]*/[[:d-d]", "a/[", FNM_PATHNAME), 0);
-	zassert_not_equal(fnmatch("*[![:digit:]]*/[![:d-d]", "a/[", FNM_PATHNAME), 0);
-	zassert_ok(fnmatch("a?b", "a.b", FNM_PATHNAME | FNM_PERIOD));
-	zassert_ok(fnmatch("a*b", "a.b", FNM_PATHNAME | FNM_PERIOD));
-	zassert_ok(fnmatch("a[.]b", "a.b", FNM_PATHNAME | FNM_PERIOD));
-}
diff --git a/tests/posix/c_lib_ext/src/getentropy.c b/tests/posix/c_lib_ext/src/getentropy.c
deleted file mode 100644
index f04e54becb0..00000000000
--- a/tests/posix/c_lib_ext/src/getentropy.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2024 Google LLC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/posix/unistd.h>
-#include <zephyr/ztest.h>
-
-ZTEST(posix_c_lib_ext, test_getentropy_too_large)
-{
-	uint8_t buf[256 + 1] = {0};
-	int ret;
-
-	ret = getentropy(buf, sizeof(buf));
-	zassert_equal(ret, -1);
-	zassert_equal(errno, EIO);
-}
-
-ZTEST(posix_c_lib_ext, test_getentropy_null_buffer)
-{
-	int ret;
-
-	ret = getentropy(NULL, 0);
-	zassert_equal(ret, -1);
-	zassert_equal(errno, EFAULT);
-}
-
-ZTEST(posix_c_lib_ext, test_getentropy_max_size)
-{
-	uint8_t buf[256] = {0};
-	int ret;
-
-	ret = getentropy(buf, sizeof(buf));
-	zassert_equal(ret, 0);
-}
-
-ZTEST(posix_c_lib_ext, test_getentropy)
-{
-	uint8_t zero[16] = {0};
-	uint8_t buf1[16];
-	uint8_t buf2[16];
-	int ret;
-
-	ret = getentropy(buf1, sizeof(buf1));
-	zassert_equal(ret, 0);
-
-	ret = getentropy(buf2, sizeof(buf2));
-	zassert_equal(ret, 0);
-
-	zassert_true(memcmp(buf1, zero, sizeof(zero)) != 0);
-	zassert_true(memcmp(buf2, zero, sizeof(zero)) != 0);
-	zassert_true(memcmp(buf1, buf2, sizeof(buf1)) != 0);
-}
diff --git a/tests/posix/c_lib_ext/src/getopt.c b/tests/posix/c_lib_ext/src/getopt.c
deleted file mode 100644
index 2385db91708..00000000000
--- a/tests/posix/c_lib_ext/src/getopt.c
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * Copyright (c) 2021 Nordic Semiconductor
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-/** @file
- *  @brief Interactive getopt test suite
- *
- */
-
-#include <getopt.h>
-#include <string.h>
-
-#include <zephyr/kernel.h>
-#include <unistd.h>
-#include <zephyr/ztest.h>
-
-ZTEST(posix_c_lib_ext, test_getopt_basic)
-{
-	static const char *const nargv[] = {
-		"cmd_name", "-b", "-a", "-h", "-c", "-l", "-h", "-a", "-i", "-w",
-	};
-	static const char *accepted_opt = "abchw";
-	static const char *expected = "bahc?ha?w";
-	size_t argc = ARRAY_SIZE(nargv);
-	int cnt = 0;
-	int c;
-	char **argv;
-
-	argv = (char **)nargv;
-
-	/* Get state of the current thread */
-	getopt_init();
-
-	do {
-		c = getopt(argc, argv, accepted_opt);
-		if (cnt >= strlen(expected)) {
-			break;
-		}
-
-		zassert_equal(c, expected[cnt++], "unexpected opt character");
-	} while (c != -1);
-
-	c = getopt(argc, argv, accepted_opt);
-	zassert_equal(c, -1, "unexpected opt character");
-}
-
-enum getopt_idx {
-	GETOPT_IDX_CMD_NAME,
-	GETOPT_IDX_OPTION1,
-	GETOPT_IDX_OPTION2,
-	GETOPT_IDX_OPTARG
-};
-
-ZTEST(posix_c_lib_ext, test_getopt)
-{
-	struct getopt_state *state;
-	static const char *test_opts = "ac:";
-	static const char *const nargv[] = {
-		[GETOPT_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_IDX_OPTION1] = "-a",
-		[GETOPT_IDX_OPTION2] = "-c",
-		[GETOPT_IDX_OPTARG] = "foo",
-	};
-	int argc = ARRAY_SIZE(nargv);
-	char **argv;
-	int c;
-
-	/* Get state of the current thread */
-	getopt_init();
-
-	argv = (char **)nargv;
-
-	/* Test uknown option */
-
-	c = getopt(argc, argv, test_opts);
-	zassert_equal(c, 'a', "unexpected opt character");
-	c = getopt(argc, argv, test_opts);
-	zassert_equal(c, 'c', "unexpected opt character");
-
-	c = getopt(argc, argv, test_opts);
-	state = getopt_state_get();
-
-	/* Thread safe usge: */
-	zassert_equal(0, strcmp(argv[GETOPT_IDX_OPTARG], state->optarg),
-		      "unexpected optarg result");
-	/* Non thread safe usage: */
-	zassert_equal(0, strcmp(argv[GETOPT_IDX_OPTARG], optarg), "unexpected optarg result");
-}
-
-enum getopt_long_idx {
-	GETOPT_LONG_IDX_CMD_NAME,
-	GETOPT_LONG_IDX_VERBOSE,
-	GETOPT_LONG_IDX_OPT,
-	GETOPT_LONG_IDX_OPTARG
-};
-
-ZTEST(posix_c_lib_ext, test_getopt_long)
-{
-	/* Below test is based on example
-	 * https://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Option-Example.html
-	 */
-	struct getopt_state *state;
-	int verbose_flag = 0;
-	/* getopt_long stores the option index here. */
-	int option_index = 0;
-	char **argv;
-	int c;
-	struct option long_options[] = {
-		/* These options set a flag. */
-		{"verbose", no_argument, &verbose_flag, 1},
-		{"brief", no_argument, &verbose_flag, 0},
-		/* These options dont set a flag.
-		 * We distinguish them by their indices.
-		 */
-		{"add", no_argument, 0, 'a'},
-		{"create", required_argument, 0, 'c'},
-		{"delete", required_argument, 0, 'd'},
-		{"long", required_argument, 0, 'e'},
-		{0, 0, 0, 0},
-	};
-	static const char *accepted_opt = "ac:d:e:";
-
-	static const char *const argv1[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--verbose",
-		[GETOPT_LONG_IDX_OPT] = "--create",
-		[GETOPT_LONG_IDX_OPTARG] = "some_file",
-	};
-	int argc1 = ARRAY_SIZE(argv1);
-
-	static const char *const argv2[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--brief",
-		[GETOPT_LONG_IDX_OPT] = "-d",
-		[GETOPT_LONG_IDX_OPTARG] = "other_file",
-	};
-	int argc2 = ARRAY_SIZE(argv2);
-
-	static const char *const argv3[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--brief",
-		[GETOPT_LONG_IDX_OPT] = "-a",
-	};
-	int argc3 = ARRAY_SIZE(argv3);
-
-	/* this test distinguish getopt_long and getopt_long_only functions */
-	static const char *const argv4[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--brief",
-		/* below should not be interpreted as "--long/-e" option */
-		[GETOPT_LONG_IDX_OPT] = "-l",
-		[GETOPT_LONG_IDX_OPTARG] = "long_argument",
-	};
-	int argc4 = ARRAY_SIZE(argv4);
-
-	/* Test scenario 1 */
-	/* Get state of the current thread */
-	getopt_init();
-	argv = (char **)argv1;
-	c = getopt_long(argc1, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 1, "verbose flag expected");
-	c = getopt_long(argc1, argv, accepted_opt, long_options, &option_index);
-	state = getopt_state_get();
-	zassert_equal('c', c, "unexpected option");
-	zassert_equal(0, strcmp(state->optarg, argv[GETOPT_LONG_IDX_OPTARG]), "unexpected optarg");
-	c = getopt_long(argc1, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(-1, c, "getopt_long shall return -1");
-
-	/* Test scenario 2 */
-	argv = (char **)argv2;
-	getopt_init();
-	c = getopt_long(argc2, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 0, "verbose flag expected");
-	c = getopt_long(argc2, argv, accepted_opt, long_options, &option_index);
-	zassert_equal('d', c, "unexpected option");
-	state = getopt_state_get();
-	zassert_equal(0, strcmp(state->optarg, argv[GETOPT_LONG_IDX_OPTARG]), "unexpected optarg");
-	c = getopt_long(argc2, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(-1, c, "getopt_long shall return -1");
-
-	/* Test scenario 3 */
-	argv = (char **)argv3;
-	getopt_init();
-	c = getopt_long(argc3, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 0, "verbose flag expected");
-	c = getopt_long(argc3, argv, accepted_opt, long_options, &option_index);
-	zassert_equal('a', c, "unexpected option");
-	c = getopt_long(argc3, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(-1, c, "getopt_long shall return -1");
-
-	/* Test scenario 4 */
-	argv = (char **)argv4;
-	getopt_init();
-	c = getopt_long(argc4, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 0, "verbose flag expected");
-	c = getopt_long(argc4, argv, accepted_opt, long_options, &option_index);
-	/* Function was called with option '-l'. It is expected it will be
-	 * NOT evaluated to '--long' which has flag 'e'.
-	 */
-	zassert_not_equal('e', c, "unexpected option match");
-	c = getopt_long(argc4, argv, accepted_opt, long_options, &option_index);
-}
-
-ZTEST(posix_c_lib_ext, test_getopt_long_only)
-{
-	/* Below test is based on example
-	 * https://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Option-Example.html
-	 */
-	struct getopt_state *state;
-	int verbose_flag = 0;
-	/* getopt_long stores the option index here. */
-	int option_index = 0;
-	char **argv;
-	int c;
-	struct option long_options[] = {
-		/* These options set a flag. */
-		{"verbose", no_argument, &verbose_flag, 1},
-		{"brief", no_argument, &verbose_flag, 0},
-		/* These options dont set a flag.
-		 * We distinguish them by their indices.
-		 */
-		{"add", no_argument, 0, 'a'},
-		{"create", required_argument, 0, 'c'},
-		{"delete", required_argument, 0, 'd'},
-		{"long", required_argument, 0, 'e'},
-		{0, 0, 0, 0},
-	};
-	static const char *accepted_opt = "ac:d:e:";
-
-	static const char *const argv1[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--verbose",
-		[GETOPT_LONG_IDX_OPT] = "--create",
-		[GETOPT_LONG_IDX_OPTARG] = "some_file",
-	};
-	int argc1 = ARRAY_SIZE(argv1);
-
-	static const char *const argv2[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--brief",
-		[GETOPT_LONG_IDX_OPT] = "-d",
-		[GETOPT_LONG_IDX_OPTARG] = "other_file",
-	};
-	int argc2 = ARRAY_SIZE(argv2);
-
-	static const char *const argv3[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--brief",
-		[GETOPT_LONG_IDX_OPT] = "-a",
-	};
-	int argc3 = ARRAY_SIZE(argv3);
-
-	/* this test distinguish getopt_long and getopt_long_only functions */
-	static const char *const argv4[] = {
-		[GETOPT_LONG_IDX_CMD_NAME] = "cmd_name",
-		[GETOPT_LONG_IDX_VERBOSE] = "--brief",
-		/* below should be interpreted as "--long/-e" option */
-		[GETOPT_LONG_IDX_OPT] = "-l",
-		[GETOPT_LONG_IDX_OPTARG] = "long_argument",
-	};
-	int argc4 = ARRAY_SIZE(argv4);
-
-	/* Test scenario 1 */
-	argv = (char **)argv1;
-	getopt_init();
-	c = getopt_long_only(argc1, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 1, "verbose flag expected");
-	c = getopt_long_only(argc1, argv, accepted_opt, long_options, &option_index);
-	state = getopt_state_get();
-	zassert_equal('c', c, "unexpected option");
-	zassert_equal(0, strcmp(state->optarg, argv[GETOPT_LONG_IDX_OPTARG]), "unexpected optarg");
-	c = getopt_long_only(argc1, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(-1, c, "getopt_long_only shall return -1");
-
-	/* Test scenario 2 */
-	argv = (char **)argv2;
-	getopt_init();
-	state = getopt_state_get();
-	c = getopt_long_only(argc2, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 0, "verbose flag expected");
-	c = getopt_long_only(argc2, argv, accepted_opt, long_options, &option_index);
-	state = getopt_state_get();
-	zassert_equal('d', c, "unexpected option");
-	zassert_equal(0, strcmp(state->optarg, argv[GETOPT_LONG_IDX_OPTARG]), "unexpected optarg");
-	c = getopt_long_only(argc2, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(-1, c, "getopt_long_only shall return -1");
-
-	/* Test scenario 3 */
-	argv = (char **)argv3;
-	getopt_init();
-	c = getopt_long_only(argc3, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 0, "verbose flag expected");
-	c = getopt_long_only(argc3, argv, accepted_opt, long_options, &option_index);
-	zassert_equal('a', c, "unexpected option");
-	c = getopt_long_only(argc3, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(-1, c, "getopt_long_only shall return -1");
-
-	/* Test scenario 4 */
-	argv = (char **)argv4;
-	getopt_init();
-	c = getopt_long_only(argc4, argv, accepted_opt, long_options, &option_index);
-	zassert_equal(verbose_flag, 0, "verbose flag expected");
-	c = getopt_long_only(argc4, argv, accepted_opt, long_options, &option_index);
-
-	/* Function was called with option '-l'. It is expected it will be
-	 * evaluated to '--long' which has flag 'e'.
-	 */
-	zassert_equal('e', c, "unexpected option");
-	c = getopt_long_only(argc4, argv, accepted_opt, long_options, &option_index);
-}
diff --git a/tests/posix/c_lib_ext/src/main.c b/tests/posix/c_lib_ext/src/main.c
deleted file mode 100644
index e5ea2e2d026..00000000000
--- a/tests/posix/c_lib_ext/src/main.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * Copyright (c) 2024 Marvin Ouma <pancakesdeath@protonmail.com>
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-ZTEST_SUITE(posix_c_lib_ext, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/c_lib_ext/testcase.yaml b/tests/posix/c_lib_ext/testcase.yaml
deleted file mode 100644
index 639caf5520d..00000000000
--- a/tests/posix/c_lib_ext/testcase.yaml
+++ /dev/null
@@ -1,37 +0,0 @@
-common:
-  filter: dt_chosen_enabled("zephyr,entropy") and CONFIG_ENTROPY_HAS_DRIVER and
-    not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - c_lib_ext
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_cortex_m0
-tests:
-  portability.posix.c_lib_ext:
-    extra_configs:
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.posix.c_lib_ext.armclang_std_libc:
-    toolchain_allow: armclang
-    extra_configs:
-      - CONFIG_ARMCLANG_STD_LIBC=y
-  portability.posix.c_lib_ext.arcmwdtlib:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_ARCMWDT_LIBC=y
-  portability.posix.c_lib_ext.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.posix.c_lib_ext.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.c_lib_ext.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/clock_selection/CMakeLists.txt b/tests/posix/clock_selection/CMakeLists.txt
deleted file mode 100644
index e66e7e7ebdf..00000000000
--- a/tests/posix/clock_selection/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_clock_selection)
-
-target_sources(app PRIVATE src/main.c ../timers/src/nanosleep_common.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/clock_selection/prj.conf b/tests/posix/clock_selection/prj.conf
deleted file mode 100644
index c8377ef76c0..00000000000
--- a/tests/posix/clock_selection/prj.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_CLOCK_SELECTION=y
-
-CONFIG_DYNAMIC_THREAD=y
-CONFIG_DYNAMIC_THREAD_POOL_SIZE=3
-CONFIG_THREAD_STACK_INFO=y
diff --git a/tests/posix/clock_selection/src/main.c b/tests/posix/clock_selection/src/main.c
deleted file mode 100644
index 91c6aa9ea35..00000000000
--- a/tests/posix/clock_selection/src/main.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-#include <time.h>
-
-#include <zephyr/logging/log.h>
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define SELECT_NANOSLEEP       1
-#define SELECT_CLOCK_NANOSLEEP 0
-
-void common_lower_bound_check(int selection, clockid_t clock_id, int flags, const uint32_t s,
-			      uint32_t ns);
-int select_nanosleep(int selection, clockid_t clock_id, int flags, const struct timespec *rqtp,
-		     struct timespec *rmtp);
-
-ZTEST(posix_clock_selection, test_clock_nanosleep_execution)
-{
-	struct timespec ts;
-
-	clock_gettime(CLOCK_MONOTONIC, &ts);
-
-	/* absolute sleeps with the monotonic clock and reference time ts */
-
-	/* until 1s + 1ns past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, TIMER_ABSTIME,
-				 ts.tv_sec + 1, 1);
-
-	/* until 1s + 1us past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, TIMER_ABSTIME,
-				 ts.tv_sec + 1, 1000);
-
-	/* until 1s + 500000000ns past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, TIMER_ABSTIME,
-				 ts.tv_sec + 1, 500000000);
-
-	/* until 2s past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, TIMER_ABSTIME,
-				 ts.tv_sec + 2, 0);
-
-	/* until 2s + 1ns past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, TIMER_ABSTIME,
-				 ts.tv_sec + 2, 1);
-
-	/* until 2s + 1us + 1ns past reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, TIMER_ABSTIME,
-				 ts.tv_sec + 2, 1001);
-
-	clock_gettime(CLOCK_REALTIME, &ts);
-
-	/* absolute sleeps with the real time clock and adjusted reference time ts */
-
-	/* until 1s + 1ns past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_REALTIME, TIMER_ABSTIME,
-				 ts.tv_sec + 1, 1);
-
-	/* until 1s + 1us past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_REALTIME, TIMER_ABSTIME,
-				 ts.tv_sec + 1, 1000);
-
-	/* until 1s + 500000000ns past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_REALTIME, TIMER_ABSTIME,
-				 ts.tv_sec + 1, 500000000);
-
-	/* until 2s past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_REALTIME, TIMER_ABSTIME,
-				 ts.tv_sec + 2, 0);
-
-	/* until 2s + 1ns past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_REALTIME, TIMER_ABSTIME,
-				 ts.tv_sec + 2, 1);
-
-	/* until 2s + 1us + 1ns past the reference time */
-	common_lower_bound_check(SELECT_CLOCK_NANOSLEEP, CLOCK_REALTIME, TIMER_ABSTIME,
-				 ts.tv_sec + 2, 1001);
-}
-
-ZTEST(posix_clock_selection, test_pthread_condattr_getclock)
-{
-	clockid_t clock_id;
-	pthread_condattr_t att = {0};
-
-	zassert_ok(pthread_condattr_init(&att));
-
-	zassert_ok(pthread_condattr_getclock(&att, &clock_id), "pthread_condattr_getclock failed");
-	zassert_equal(clock_id, CLOCK_REALTIME, "clock attribute not set correctly");
-
-	zassert_ok(pthread_condattr_destroy(&att));
-}
-
-ZTEST(posix_clock_selection, test_pthread_condattr_setclock)
-{
-	clockid_t clock_id;
-	pthread_condattr_t att = {0};
-
-	zassert_ok(pthread_condattr_init(&att));
-
-	zassert_ok(pthread_condattr_setclock(&att, CLOCK_MONOTONIC),
-		   "pthread_condattr_setclock failed");
-
-	zassert_ok(pthread_condattr_getclock(&att, &clock_id), "pthread_condattr_setclock failed");
-	zassert_equal(clock_id, CLOCK_MONOTONIC, "clock attribute not set correctly");
-
-	zassert_equal(pthread_condattr_setclock(&att, 42), -EINVAL,
-		      "pthread_condattr_setclock did not return EINVAL");
-
-	zassert_ok(pthread_condattr_destroy(&att));
-}
-
-ZTEST_SUITE(posix_clock_selection, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/clock_selection/testcase.yaml b/tests/posix/clock_selection/testcase.yaml
deleted file mode 100644
index e58bdfdf426..00000000000
--- a/tests/posix/clock_selection/testcase.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - clock_selection
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_riscv64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.clock_selection: {}
-  portability.posix.clock_selection.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.clock_selection.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-      - CONFIG_NEWLIB_LIBC_MIN_REQUIRED_HEAP_SIZE=8192
-  portability.posix.clock_selection.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/common/CMakeLists.txt b/tests/posix/common/CMakeLists.txt
deleted file mode 100644
index 7770e44d681..00000000000
--- a/tests/posix/common/CMakeLists.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_common)
-
-FILE(GLOB app_sources src/*.c)
-zephyr_include_directories(${ZEPHYR_BASE}/lib/posix)
-
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_include_directories(app PRIVATE ${ZEPHYR_BASE}/lib/posix/options)
diff --git a/tests/posix/common/Kconfig b/tests/posix/common/Kconfig
deleted file mode 100644
index 4ee1793253e..00000000000
--- a/tests/posix/common/Kconfig
+++ /dev/null
@@ -1,34 +0,0 @@
-# Copyright (c) 2023, Meta
-# SPDX-License-Identifier: Apache-2.0
-
-# Options specific to clock.c / test_realtime
-
-config TEST_CLOCK_RT_ITERATIONS
-	int "Number of iterations to check clock_gettime() reliability"
-	range 10 100
-	default 20
-	help
-	  This option is specific to posix_apis.test_realtime in clock.c
-
-config TEST_CLOCK_RT_SLEEP_MS
-	int "Time to sleep between iterations in milliseconds"
-	range 50 1000
-	default 100
-	help
-	  This option is specific to posix_apis.test_realtime in clock.c
-
-config TEST_CLOCK_RT_ERROR_MS
-	int "Maximum overshoot (error) in milliseconds"
-	range 10 500
-	default 10
-	help
-	  This option is specific to posix_apis.test_realtime in clock.c
-
-config TEST_SEM_N_LOOPS
-	int "Number of loops in semaphore test"
-	range 16 1024
-	default 32
-	help
-	  This option is specific to semaphore.test_named_semaphore in semaphore.c
-
-source "Kconfig.zephyr"
diff --git a/tests/posix/common/boards/intel_adsp_ace30_ptl.conf b/tests/posix/common/boards/intel_adsp_ace30_ptl.conf
deleted file mode 100644
index 922c1e4b05f..00000000000
--- a/tests/posix/common/boards/intel_adsp_ace30_ptl.conf
+++ /dev/null
@@ -1 +0,0 @@
-CONFIG_MAX_THREAD_BYTES=3
diff --git a/tests/posix/common/boards/intel_adsp_ace30_ptl_sim.conf b/tests/posix/common/boards/intel_adsp_ace30_ptl_sim.conf
deleted file mode 100644
index 922c1e4b05f..00000000000
--- a/tests/posix/common/boards/intel_adsp_ace30_ptl_sim.conf
+++ /dev/null
@@ -1 +0,0 @@
-CONFIG_MAX_THREAD_BYTES=3
diff --git a/tests/posix/common/boards/qemu_x86_tiny.conf b/tests/posix/common/boards/qemu_x86_tiny.conf
deleted file mode 100644
index 01506ce9f55..00000000000
--- a/tests/posix/common/boards/qemu_x86_tiny.conf
+++ /dev/null
@@ -1,16 +0,0 @@
-# Copyright (c) 2021 Intel Corporation
-# SPDX-License-Identifier: Apache-2.0
-
-# The test is highly sensitive to size of kernel image.
-# However, specifying how many pages used by
-# the backing store must be done in build time.
-# So here we are, tuning this manually.
-CONFIG_BACKING_STORE_RAM_PAGES=12
-
-# The following is needed so that .text and following
-# sections are present in physical memory to test
-# using backing store for anonymous memory.
-CONFIG_KERNEL_VM_BASE=0x0
-CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT=y
-CONFIG_BACKING_STORE_RAM=y
-CONFIG_BACKING_STORE_QEMU_X86_TINY_FLASH=n
diff --git a/tests/posix/common/boards/qemu_x86_tiny.overlay b/tests/posix/common/boards/qemu_x86_tiny.overlay
deleted file mode 100644
index 4e23cf84e32..00000000000
--- a/tests/posix/common/boards/qemu_x86_tiny.overlay
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-&dram0 {
-	reg = <0x100000 0x80000>;
-};
diff --git a/tests/posix/common/prj.conf b/tests/posix/common/prj.conf
deleted file mode 100644
index 7efcb301a32..00000000000
--- a/tests/posix/common/prj.conf
+++ /dev/null
@@ -1,31 +0,0 @@
-CONFIG_POSIX_AEP_CHOICE_PSE52=y
-CONFIG_XSI=y
-CONFIG_XSI_SINGLE_PROCESS=y
-CONFIG_POSIX_SEMAPHORES=y
-CONFIG_POSIX_THREAD_THREADS_MAX=6
-CONFIG_ZTEST=y
-CONFIG_POSIX_SEM_VALUE_MAX=32767
-CONFIG_POSIX_MESSAGE_PASSING=y
-CONFIG_POSIX_PRIORITY_SCHEDULING=y
-CONFIG_HEAP_MEM_POOL_SIZE=4096
-CONFIG_THREAD_NAME=y
-CONFIG_DYNAMIC_THREAD=y
-CONFIG_THREAD_STACK_INFO=y
-CONFIG_DYNAMIC_THREAD_POOL_SIZE=6
-CONFIG_POSIX_THREAD_KEYS_MAX=512
-CONFIG_TEST_EXTRA_STACK_SIZE=4096
-
-# for fnmatch()
-CONFIG_POSIX_C_LIB_EXT=y
-
-# for putmsg()
-CONFIG_XSI_STREAMS=y
-
-# for sleep(), getpid()
-CONFIG_POSIX_MULTI_PROCESS=y
-
-# for syslog()
-CONFIG_XSI_SYSTEM_LOGGING=y
-
-# for sched_get_priority_min(), sched_get_priority_max()
-CONFIG_POSIX_PRIORITY_SCHEDULING=y
diff --git a/tests/posix/common/src/_main.c b/tests/posix/common/src/_main.c
deleted file mode 100644
index 92672abce64..00000000000
--- a/tests/posix/common/src/_main.c
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-extern bool fdtable_fd_is_initialized(int fd);
-
-ZTEST(posix_apis, test_fdtable_init)
-{
-	/* ensure that the stdin, stdout, and stderr fdtable entries are initialized */
-	zassert_true(fdtable_fd_is_initialized(0));
-	zassert_true(fdtable_fd_is_initialized(1));
-	zassert_true(fdtable_fd_is_initialized(2));
-}
-
-ZTEST_SUITE(posix_apis, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/common/src/clock.c b/tests/posix/common/src/clock.c
deleted file mode 100644
index 2467ac4df4b..00000000000
--- a/tests/posix/common/src/clock.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-
-#include <limits.h>
-#include <sys/time.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-#include <zephyr/logging/log.h>
-
-ZTEST(clock, test_gettimeofday)
-{
-	struct timeval tv;
-	struct timespec ts;
-	struct timespec rts;
-
-	if (false) {
-		/* undefined behaviour */
-		errno = 0;
-		zassert_equal(gettimeofday(NULL, NULL), -1);
-		zassert_equal(errno, EINVAL);
-	}
-
-	/* Validate gettimeofday API */
-	zassert_ok(gettimeofday(&tv, NULL));
-	zassert_ok(clock_gettime(CLOCK_REALTIME, &rts));
-
-	/* TESTPOINT: Check if time obtained from
-	 * gettimeofday is same or more than obtained
-	 * from clock_gettime
-	 */
-	tv_to_ts(&tv, &ts);
-	zassert_true(tp_ge(&rts, &ts));
-}
-
-ZTEST_SUITE(clock, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/common/src/cond.c b/tests/posix/common/src/cond.c
deleted file mode 100644
index e269b1f9d11..00000000000
--- a/tests/posix/common/src/cond.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-
-#include <zephyr/ztest.h>
-
-/**
- * @brief Test to demonstrate limited condition variable resources
- *
- * @details Exactly CONFIG_MAX_PTHREAD_COND_COUNT can be in use at once.
- */
-ZTEST(cond, test_cond_resource_exhausted)
-{
-	size_t i;
-	pthread_cond_t m[CONFIG_MAX_PTHREAD_COND_COUNT + 1];
-
-	for (i = 0; i < CONFIG_MAX_PTHREAD_COND_COUNT; ++i) {
-		zassert_ok(pthread_cond_init(&m[i], NULL), "failed to init cond %zu", i);
-	}
-
-	/* try to initialize one more than CONFIG_MAX_PTHREAD_COND_COUNT */
-	zassert_equal(i, CONFIG_MAX_PTHREAD_COND_COUNT);
-	zassert_not_equal(0, pthread_cond_init(&m[i], NULL), "should not have initialized cond %zu",
-			  i);
-
-	for (; i > 0; --i) {
-		zassert_ok(pthread_cond_destroy(&m[i - 1]), "failed to destroy cond %zu", i - 1);
-	}
-}
-
-/**
- * @brief Test to that there are no condition variable resource leaks
- *
- * @details Demonstrate that condition variables may be used over and over again.
- */
-ZTEST(cond, test_cond_resource_leak)
-{
-	pthread_cond_t cond;
-
-	for (size_t i = 0; i < 2 * CONFIG_MAX_PTHREAD_COND_COUNT; ++i) {
-		zassert_ok(pthread_cond_init(&cond, NULL), "failed to init cond %zu", i);
-		zassert_ok(pthread_cond_destroy(&cond), "failed to destroy cond %zu", i);
-	}
-}
-
-ZTEST(cond, test_pthread_condattr)
-{
-	pthread_condattr_t att = {0};
-
-	zassert_ok(pthread_condattr_init(&att));
-
-	zassert_ok(pthread_condattr_destroy(&att));
-}
-
-/**
- * @brief Test pthread_cond_init() with a pre-existing initialized attribute.
- */
-ZTEST(cond, test_cond_init_existing_initialized_condattr)
-{
-	pthread_cond_t cond;
-	pthread_condattr_t att = {0};
-
-	zassert_ok(pthread_condattr_init(&att));
-	zassert_ok(pthread_cond_init(&cond, &att), "pthread_cond_init failed with valid attr");
-
-	/* Clean up */
-	zassert_ok(pthread_cond_destroy(&cond));
-	zassert_ok(pthread_condattr_destroy(&att));
-}
-
-ZTEST_SUITE(cond, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/common/src/grp.c b/tests/posix/common/src/grp.c
deleted file mode 100644
index 1fce1433bff..00000000000
--- a/tests/posix/common/src/grp.c
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (c) 2024 Meta Platforms
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <grp.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(grp, test_grp_stubs)
-{
-	zassert_equal(getgrnam_r(NULL, NULL, NULL, 42, NULL), ENOSYS);
-	zassert_equal(getgrgid_r(42, NULL, NULL, 42, NULL), ENOSYS);
-}
-
-ZTEST_SUITE(grp, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/common/src/key.c b/tests/posix/common/src/key.c
deleted file mode 100644
index 693f4dccaa9..00000000000
--- a/tests/posix/common/src/key.c
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define N_THR 2
-#define N_KEY  2
-#define BUFFSZ 48
-
-static pthread_key_t key;
-static pthread_key_t keys[N_KEY];
-static pthread_once_t key_once = PTHREAD_ONCE_INIT;
-static pthread_once_t keys_once = PTHREAD_ONCE_INIT;
-
-static void *thread_top(void *p1)
-{
-	void *value;
-	char *buffer[BUFFSZ];
-
-	value = k_malloc(sizeof(buffer));
-	zassert_not_null(value, "thread could not allocate storage");
-	zassert_ok(pthread_setspecific(key, value), "pthread_setspecific failed");
-	zassert_equal(pthread_getspecific(key), value, "set and retrieved values are different");
-	k_free(value);
-
-	return NULL;
-}
-
-static void *thread_func(void *p1)
-{
-	void *value;
-	char *buffer[BUFFSZ];
-
-	value = k_malloc(sizeof(buffer));
-	zassert_not_null(value, "thread could not allocate storage");
-	for (int i = 0; i < N_KEY; i++) {
-		zassert_ok(pthread_setspecific(keys[i], value), "pthread_setspecific failed");
-		zassert_equal(pthread_getspecific(keys[i]), value,
-			      "set and retrieved values are different");
-	}
-	k_free(value);
-	return NULL;
-}
-
-static void make_key(void)
-{
-	zassert_ok(pthread_key_create(&key, NULL), "insufficient memory to create key");
-}
-
-static void make_keys(void)
-{
-	for (int i = 0; i < N_KEY; i++) {
-		zassert_ok(pthread_key_create(&keys[i], NULL),
-			   "insufficient memory to create keys");
-	}
-}
-
-/**
- * @brief Test to demonstrate pthread_key APIs usage
- *
- * @details The tests spawn a thread which uses pthread_once() to
- * create a key via pthread_key_create() API. It then sets the
- * thread-specific value to the key using pthread_setspecific() and
- * gets it back using pthread_getspecific and asserts that they
- * are equal. It then deletes the key using pthread_key_delete().
- * Both the sub-tests do the above, but one with multiple threads
- * using the same key and the other with a single thread using
- * multiple keys.
- */
-
-ZTEST(key, test_key_1toN_thread)
-{
-	void *retval;
-	pthread_t newthread[N_THR];
-
-	zassert_ok(pthread_once(&key_once, make_key), "attempt to create key failed");
-
-	/* Different threads set different values to same key */
-
-	for (int i = 0; i < N_THR; i++) {
-		zassert_ok(pthread_create(&newthread[i], NULL, thread_top, NULL),
-			   "attempt to create thread %d failed", i);
-	}
-
-	for (int i = 0; i < N_THR; i++) {
-		zassert_ok(pthread_join(newthread[i], &retval), "failed to join thread %d", i);
-	}
-
-	zassert_ok(pthread_key_delete(key), "attempt to delete key failed");
-}
-
-ZTEST(key, test_key_Nto1_thread)
-{
-	pthread_t newthread;
-
-	zassert_ok(pthread_once(&keys_once, make_keys), "attempt to create keys failed");
-
-	/* Single thread associates its value with different keys */
-
-	zassert_ok(pthread_create(&newthread, NULL, thread_func, NULL),
-		   "attempt to create thread failed");
-
-	zassert_ok(pthread_join(newthread, NULL), "failed to join thread");
-
-	for (int i = 0; i < N_KEY; i++) {
-		zassert_ok(pthread_key_delete(keys[i]), "attempt to delete keys[%d] failed", i);
-	}
-}
-
-ZTEST(key, test_key_resource_leak)
-{
-	pthread_key_t key;
-
-	for (size_t i = 0; i < CONFIG_POSIX_THREAD_KEYS_MAX; ++i) {
-		zassert_ok(pthread_key_create(&key, NULL), "failed to create key %zu", i);
-		zassert_ok(pthread_key_delete(key), "failed to delete key %zu", i);
-	}
-}
-
-ZTEST(key, test_correct_key_is_deleted)
-{
-	pthread_key_t key;
-	size_t j = CONFIG_POSIX_THREAD_KEYS_MAX - 1;
-	pthread_key_t keys[CONFIG_POSIX_THREAD_KEYS_MAX];
-
-	for (size_t i = 0; i < ARRAY_SIZE(keys); ++i) {
-		zassert_ok(pthread_key_create(&keys[i], NULL), "failed to create key %zu", i);
-	}
-
-	key = keys[j];
-	zassert_ok(pthread_key_delete(keys[j]));
-	zassert_ok(pthread_key_create(&keys[j], NULL), "failed to create key %zu", j);
-
-	zassert_equal(key, keys[j], "deleted key %x instead of key %x", keys[j], key);
-
-	for (size_t i = 0; i < ARRAY_SIZE(keys); ++i) {
-		zassert_ok(pthread_key_delete(keys[i]), "failed to delete key %zu", i);
-	}
-}
-
-static void *setspecific_thread(void *count)
-{
-	int value = 42;
-	int *alloc_count = count;
-
-	while (1) {
-		pthread_key_t key;
-
-		zassert_ok(pthread_key_create(&key, NULL), "failed to create key");
-		if (pthread_setspecific(key, &value) == ENOMEM) {
-			break;
-		};
-		*alloc_count += 1;
-	}
-
-	return NULL;
-}
-
-ZTEST(key, test_thread_specific_data_deallocation)
-{
-	pthread_t thread;
-	static int alloc_count_t0;
-	static int alloc_count_t1;
-
-	zassert_ok(pthread_create(&thread, NULL, setspecific_thread, &alloc_count_t0),
-		"attempt to create thread failed");
-	zassert_ok(pthread_join(thread, NULL), "failed to join thread");
-	printk("first thread allocated %d keys", alloc_count_t0);
-
-	zassert_ok(pthread_create(&thread, NULL, setspecific_thread, &alloc_count_t1),
-		"attempt to create thread failed");
-	zassert_ok(pthread_join(thread, NULL), "failed to join thread");
-	printk("second thread allocated %d keys", alloc_count_t1);
-
-	zassert_equal(alloc_count_t0, alloc_count_t1,
-		"failed to deallocate thread specific data");
-}
-
-static void before(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	if (!IS_ENABLED(CONFIG_DYNAMIC_THREAD)) {
-		/* skip redundant testing if there is no thread pool / heap allocation */
-		ztest_test_skip();
-	}
-}
-
-ZTEST_SUITE(key, NULL, NULL, before, NULL, NULL);
diff --git a/tests/posix/common/src/mutex.c b/tests/posix/common/src/mutex.c
deleted file mode 100644
index f2ea38ef64a..00000000000
--- a/tests/posix/common/src/mutex.c
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <pthread.h>
-#include <time.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define SLEEP_MS 100
-
-static pthread_mutex_t mutex;
-
-static void *normal_mutex_entry(void *p1)
-{
-	int i, rc;
-
-	/* Sleep for maximum 300 ms as main thread is sleeping for 100 ms */
-
-	for (i = 0; i < 3; i++) {
-		rc = pthread_mutex_trylock(&mutex);
-		if (rc == 0) {
-			break;
-		}
-		k_msleep(SLEEP_MS);
-	}
-
-	zassert_false(rc, "try lock failed");
-	TC_PRINT("mutex lock is taken\n");
-	zassert_false(pthread_mutex_unlock(&mutex), "mutex unlock is failed");
-	return NULL;
-}
-
-static void *recursive_mutex_entry(void *p1)
-{
-	zassert_false(pthread_mutex_lock(&mutex), "mutex is not taken");
-	zassert_false(pthread_mutex_lock(&mutex), "mutex is not taken 2nd time");
-	TC_PRINT("recursive mutex lock is taken\n");
-	zassert_false(pthread_mutex_unlock(&mutex), "mutex is not unlocked");
-	zassert_false(pthread_mutex_unlock(&mutex), "mutex is not unlocked");
-	return NULL;
-}
-
-static void test_mutex_common(int type, void *(*entry)(void *arg))
-{
-	pthread_t th;
-	__maybe_unused int protocol;
-	int actual_type;
-	pthread_mutexattr_t mut_attr;
-	struct sched_param schedparam;
-
-	schedparam.sched_priority = 2;
-
-	zassert_ok(pthread_mutexattr_init(&mut_attr));
-	zassert_ok(pthread_mutexattr_settype(&mut_attr, type), "setting mutex type is failed");
-	zassert_ok(pthread_mutex_init(&mutex, &mut_attr), "mutex initialization is failed");
-
-	zassert_ok(pthread_mutexattr_gettype(&mut_attr, &actual_type),
-		   "reading mutex type is failed");
-#if defined(_POSIX_THREAD_PRIO_INHERIT) || defined(_POSIX_THREAD_PRIO_PROTECT)
-	zassert_not_ok(pthread_mutexattr_getprotocol(NULL, &protocol));
-	zassert_not_ok(pthread_mutexattr_getprotocol(&mut_attr, NULL));
-	zassert_not_ok(pthread_mutexattr_getprotocol(NULL, NULL));
-
-	zassert_not_ok(pthread_mutexattr_setprotocol(&mut_attr, PTHREAD_PRIO_INHERIT));
-	zassert_not_ok(pthread_mutexattr_setprotocol(&mut_attr, PTHREAD_PRIO_PROTECT));
-	zassert_ok(pthread_mutexattr_setprotocol(&mut_attr, PTHREAD_PRIO_NONE));
-	zassert_ok(pthread_mutexattr_getprotocol(&mut_attr, &protocol),
-		   "reading mutex protocol is failed");
-#endif /* defined(_POSIX_THREAD_PRIO_INHERIT) || defined(_POSIX_THREAD_PRIO_PROTECT) */
-
-	zassert_ok(pthread_mutexattr_destroy(&mut_attr));
-
-	zassert_ok(pthread_mutex_lock(&mutex));
-
-	zassert_equal(actual_type, type, "mutex type is not normal");
-#if defined(_POSIX_THREAD_PRIO_INHERIT) || defined(_POSIX_THREAD_PRIO_PROTECT)
-	zassert_equal(protocol, PTHREAD_PRIO_NONE, "mutex protocol is not prio_none");
-#endif /* defined(_POSIX_THREAD_PRIO_INHERIT) || defined(_POSIX_THREAD_PRIO_PROTECT) */
-
-	zassert_ok(pthread_create(&th, NULL, entry, NULL));
-
-	k_msleep(SLEEP_MS);
-	zassert_ok(pthread_mutex_unlock(&mutex));
-
-	zassert_ok(pthread_join(th, NULL));
-	zassert_ok(pthread_mutex_destroy(&mutex), "Destroying mutex is failed");
-}
-
-ZTEST(mutex, test_mutex_prioceiling_stubs)
-{
-#if defined(_POSIX_THREAD_PRIO_PROTECT)
-	zassert_equal(pthread_mutex_getprioceiling(NULL, NULL), ENOSYS);
-	zassert_equal(pthread_mutex_setprioceiling(NULL, 0, NULL), ENOSYS);
-#endif
-
-#if defined(_POSIX_THREAD_PRIO_INHERIT) || defined(_POSIX_THREAD_PRIO_PROTECT)
-	zassert_equal(pthread_mutexattr_getprioceiling(NULL, NULL), ENOSYS);
-	zassert_equal(pthread_mutexattr_setprioceiling(NULL, 0), ENOSYS);
-#endif /* CONFIG_POSIX_THREAD_PRIO_PROTECT */
-}
-
-/**
- * @brief Test to demonstrate PTHREAD_MUTEX_NORMAL
- *
- * @details Mutex type is setup as normal. pthread_mutex_trylock
- *	    and pthread_mutex_lock are tested with mutex type being
- *	    normal.
- */
-ZTEST(mutex, test_mutex_normal)
-{
-	test_mutex_common(PTHREAD_MUTEX_NORMAL, normal_mutex_entry);
-}
-
-/**
- * @brief Test to demonstrate PTHREAD_MUTEX_RECURSIVE
- *
- * @details Mutex type is setup as recursive. mutex will be locked
- *	    twice and unlocked for the same number of time.
- *
- */
-ZTEST(mutex, test_mutex_recursive)
-{
-	test_mutex_common(PTHREAD_MUTEX_RECURSIVE, recursive_mutex_entry);
-}
-
-/**
- * @brief Test to demonstrate limited mutex resources
- *
- * @details Exactly CONFIG_MAX_PTHREAD_MUTEX_COUNT can be in use at once.
- */
-ZTEST(mutex, test_mutex_resource_exhausted)
-{
-	size_t i;
-	pthread_mutex_t m[CONFIG_MAX_PTHREAD_MUTEX_COUNT + 1];
-
-	for (i = 0; i < CONFIG_MAX_PTHREAD_MUTEX_COUNT; ++i) {
-		zassert_ok(pthread_mutex_init(&m[i], NULL), "failed to init mutex %zu", i);
-	}
-
-	/* try to initialize one more than CONFIG_MAX_PTHREAD_MUTEX_COUNT */
-	zassert_equal(i, CONFIG_MAX_PTHREAD_MUTEX_COUNT);
-	zassert_not_equal(0, pthread_mutex_init(&m[i], NULL),
-			  "should not have initialized mutex %zu", i);
-
-	for (; i > 0; --i) {
-		zassert_ok(pthread_mutex_destroy(&m[i - 1]), "failed to destroy mutex %zu", i - 1);
-	}
-}
-
-/**
- * @brief Test to that there are no mutex resource leaks
- *
- * @details Demonstrate that mutexes may be used over and over again.
- */
-ZTEST(mutex, test_mutex_resource_leak)
-{
-	pthread_mutex_t m;
-
-	for (size_t i = 0; i < 2 * CONFIG_MAX_PTHREAD_MUTEX_COUNT; ++i) {
-		zassert_ok(pthread_mutex_init(&m, NULL), "failed to init mutex %zu", i);
-		zassert_ok(pthread_mutex_destroy(&m), "failed to destroy mutex %zu", i);
-	}
-}
-
-#define TIMEDLOCK_TIMEOUT_MS       200
-#define TIMEDLOCK_TIMEOUT_DELAY_MS 100
-
-BUILD_ASSERT(TIMEDLOCK_TIMEOUT_DELAY_MS >= 100, "TIMEDLOCK_TIMEOUT_DELAY_MS too small");
-BUILD_ASSERT(TIMEDLOCK_TIMEOUT_MS >= 2 * TIMEDLOCK_TIMEOUT_DELAY_MS,
-	     "TIMEDLOCK_TIMEOUT_MS too small");
-
-static void timespec_add_ms(struct timespec *ts, uint32_t ms)
-{
-	bool oflow;
-
-	ts->tv_nsec += ms * NSEC_PER_MSEC;
-	oflow = ts->tv_nsec >= NSEC_PER_SEC;
-	ts->tv_sec += oflow;
-	ts->tv_nsec -= oflow * NSEC_PER_SEC;
-}
-
-static void *test_mutex_timedlock_fn(void *arg)
-{
-	struct timespec time_point;
-	pthread_mutex_t *mtx = (pthread_mutex_t *)arg;
-
-	zassume_ok(clock_gettime(CLOCK_REALTIME, &time_point));
-	timespec_add_ms(&time_point, TIMEDLOCK_TIMEOUT_MS);
-
-	return INT_TO_POINTER(pthread_mutex_timedlock(mtx, &time_point));
-}
-
-/** @brief Test to verify @ref pthread_mutex_timedlock returns ETIMEDOUT */
-ZTEST(mutex, test_mutex_timedlock)
-{
-	void *ret;
-	pthread_t th;
-
-	zassert_ok(pthread_mutex_init(&mutex, NULL));
-
-	printk("Expecting timedlock with timeout of %d ms to fail\n", TIMEDLOCK_TIMEOUT_MS);
-	zassert_ok(pthread_mutex_lock(&mutex));
-	zassert_ok(pthread_create(&th, NULL, test_mutex_timedlock_fn, &mutex));
-	zassert_ok(pthread_join(th, &ret));
-	/* ensure timeout occurs */
-	zassert_equal(ETIMEDOUT, POINTER_TO_INT(ret));
-
-	printk("Expecting timedlock with timeout of %d ms to succeed after 100ms\n",
-	       TIMEDLOCK_TIMEOUT_MS);
-	zassert_ok(pthread_create(&th, NULL, test_mutex_timedlock_fn, &mutex));
-	/* unlock before timeout expires */
-	k_msleep(TIMEDLOCK_TIMEOUT_DELAY_MS);
-	zassert_ok(pthread_mutex_unlock(&mutex));
-	zassert_ok(pthread_join(th, &ret));
-	/* ensure lock is successful, in spite of delay  */
-	zassert_ok(POINTER_TO_INT(ret));
-
-	zassert_ok(pthread_mutex_destroy(&mutex));
-}
-
-static void before(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	if (!IS_ENABLED(CONFIG_DYNAMIC_THREAD)) {
-		/* skip redundant testing if there is no thread pool / heap allocation */
-		ztest_test_skip();
-	}
-}
-
-ZTEST_SUITE(mutex, NULL, NULL, before, NULL, NULL);
diff --git a/tests/posix/common/src/mutex_attr.c b/tests/posix/common/src/mutex_attr.c
deleted file mode 100644
index d5f70083d41..00000000000
--- a/tests/posix/common/src/mutex_attr.c
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <pthread.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(mutex_attr, test_pthread_mutexattr_init)
-{
-	pthread_mutexattr_t attr;
-
-	/* degenerate cases */
-	{
-		zassert_equal(EINVAL, pthread_mutexattr_init(NULL));
-	}
-
-	zassert_ok(pthread_mutexattr_init(&attr));
-	zassert_ok(pthread_mutexattr_destroy(&attr));
-}
-
-ZTEST(mutex_attr, test_pthread_mutexattr_destroy)
-{
-	pthread_mutexattr_t attr;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(EINVAL, pthread_mutexattr_destroy(&attr));
-		}
-		zassert_equal(EINVAL, pthread_mutexattr_destroy(NULL));
-	}
-
-	zassert_ok(pthread_mutexattr_init(&attr));
-	zassert_ok(pthread_mutexattr_destroy(&attr));
-	if (false) {
-		/* undefined behaviour */
-		zassert_equal(EINVAL, pthread_mutexattr_destroy(&attr));
-	}
-}
-
-ZTEST_SUITE(mutex_attr, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/common/src/pthread.c b/tests/posix/common/src/pthread.c
deleted file mode 100644
index 582ab75c27f..00000000000
--- a/tests/posix/common/src/pthread.c
+++ /dev/null
@@ -1,595 +0,0 @@
-/*
- * Copyright (c) 2018-2023 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-#include <semaphore.h>
-#include <time.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define DETACH_THR_ID 2
-
-#define N_THR_E    3
-#define N_THR_T    4
-#define BOUNCES    64
-#define ONE_SECOND 1
-
-/* Macros to test invalid states */
-#define PTHREAD_CANCEL_INVALID -1
-#define SCHED_INVALID          -1
-#define PRIO_INVALID           -1
-#define PTHREAD_INVALID        ((pthread_t)(-1))
-
-/* TODO: move tests that use non-portable calls to an "np" testsuite */
-int pthread_setname_np(pthread_t thread, const char *name);
-int pthread_getname_np(pthread_t thread, char *name, size_t len);
-int pthread_tryjoin_np(pthread_t thread, void **retval);
-int pthread_timedjoin_np(pthread_t thread, void **retval, const struct timespec *abstime);
-
-static void *thread_top_exec(void *p1);
-static void *thread_top_term(void *p1);
-
-struct pthread_attr {
-	void *stack;
-	uint32_t details[2];
-};
-BUILD_ASSERT(sizeof(pthread_attr_t) >= sizeof(struct pthread_attr));
-
-static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t cvar0 = PTHREAD_COND_INITIALIZER;
-static pthread_cond_t cvar1 = PTHREAD_COND_INITIALIZER;
-static pthread_barrier_t barrier;
-
-static sem_t main_sem;
-
-static int bounce_failed;
-static int bounce_done[N_THR_E];
-
-static int curr_bounce_thread;
-
-static int barrier_failed;
-static int barrier_done[N_THR_E];
-static int barrier_return[N_THR_E];
-
-/* First phase bounces execution between two threads using a condition
- * variable, continuously testing that no other thread is mucking with
- * the protected state.  This ends with all threads going back to
- * sleep on the condition variable and being woken by main() for the
- * second phase.
- *
- * Second phase simply lines up all the threads on a barrier, verifies
- * that none run until the last one enters, and that all run after the
- * exit.
- *
- * Test success is signaled to main() using a traditional semaphore.
- */
-
-static void *thread_top_exec(void *p1)
-{
-	int i, j, id = (int)POINTER_TO_INT(p1);
-
-#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)
-	int policy;
-	struct sched_param schedparam;
-
-	pthread_getschedparam(pthread_self(), &policy, &schedparam);
-	printk("Thread %d starting with scheduling policy %d & priority %d\n", id, policy,
-	       schedparam.sched_priority);
-#endif
-
-	/* Try a double-lock here to exercise the failing case of
-	 * trylock.  We don't support RECURSIVE locks, so this is
-	 * guaranteed to fail.
-	 */
-	pthread_mutex_lock(&lock);
-
-	if (!pthread_mutex_trylock(&lock)) {
-		printk("pthread_mutex_trylock inexplicably succeeded\n");
-		bounce_failed = 1;
-	}
-
-	pthread_mutex_unlock(&lock);
-
-	for (i = 0; i < BOUNCES; i++) {
-
-		pthread_mutex_lock(&lock);
-
-		/* Wait for the current owner to signal us, unless we
-		 * are the very first thread, in which case we need to
-		 * wait a bit to be sure the other threads get
-		 * scheduled and wait on cvar0.
-		 */
-		if (!(id == 0 && i == 0)) {
-			zassert_equal(0, pthread_cond_wait(&cvar0, &lock), "");
-		} else {
-			pthread_mutex_unlock(&lock);
-			usleep(USEC_PER_MSEC * 500U);
-			pthread_mutex_lock(&lock);
-		}
-
-		/* Claim ownership, then try really hard to give someone
-		 * else a shot at hitting this if they are racing.
-		 */
-		curr_bounce_thread = id;
-		for (j = 0; j < 1000; j++) {
-			if (curr_bounce_thread != id) {
-				printk("Racing bounce threads\n");
-				bounce_failed = 1;
-				sem_post(&main_sem);
-				pthread_mutex_unlock(&lock);
-				return NULL;
-			}
-			sched_yield();
-		}
-
-		/* Next one's turn, go back to the top and wait.  */
-		pthread_cond_signal(&cvar0);
-		pthread_mutex_unlock(&lock);
-	}
-
-	/* Signal we are complete to main(), then let it wake us up.  Note
-	 * that we are using the same mutex with both cvar0 and cvar1,
-	 * which is non-standard but kosher per POSIX (and it works fine
-	 * in our implementation
-	 */
-	pthread_mutex_lock(&lock);
-	bounce_done[id] = 1;
-	sem_post(&main_sem);
-	pthread_cond_wait(&cvar1, &lock);
-	pthread_mutex_unlock(&lock);
-
-	/* Now just wait on the barrier.  Make sure no one else finished
-	 * before we wait on it, then signal that we're done
-	 */
-	for (i = 0; i < N_THR_E; i++) {
-		if (barrier_done[i]) {
-			printk("Barrier exited early\n");
-			barrier_failed = 1;
-			sem_post(&main_sem);
-		}
-	}
-	barrier_return[id] = pthread_barrier_wait(&barrier);
-	barrier_done[id] = 1;
-	sem_post(&main_sem);
-	pthread_exit(p1);
-
-	return NULL;
-}
-
-static void *timedjoin_thread(void *p1)
-{
-	int sleep_duration_ms = POINTER_TO_INT(p1);
-
-	usleep(USEC_PER_MSEC * sleep_duration_ms);
-	return NULL;
-}
-
-static int bounce_test_done(void)
-{
-	int i;
-
-	if (bounce_failed) {
-		return 1;
-	}
-
-	for (i = 0; i < N_THR_E; i++) {
-		if (!bounce_done[i]) {
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
-static int barrier_test_done(void)
-{
-	int i;
-
-	if (barrier_failed) {
-		return 1;
-	}
-
-	for (i = 0; i < N_THR_E; i++) {
-		if (!barrier_done[i]) {
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
-static void *thread_top_term(void *p1)
-{
-	pthread_t self;
-	int ret;
-	int id = POINTER_TO_INT(p1);
-
-	self = pthread_self();
-
-#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)
-	int policy;
-	struct sched_param param = {
-		.sched_priority = N_THR_T - id,
-	};
-	struct sched_param getschedparam;
-
-	/* Change priority of thread */
-	zassert_false(pthread_setschedparam(self, SCHED_RR, &param),
-		      "Unable to set thread priority!");
-
-	zassert_false(pthread_getschedparam(self, &policy, &getschedparam),
-		      "Unable to get thread priority!");
-
-	printk("Thread %d starting with a priority of %d\n", id, getschedparam.sched_priority);
-#endif
-
-	if (id % 2) {
-		ret = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
-		zassert_false(ret, "Unable to set cancel state!");
-	}
-
-	if (id >= DETACH_THR_ID) {
-		zassert_ok(pthread_detach(self), "failed to set detach state");
-		zassert_equal(pthread_detach(self), EINVAL, "re-detached thread!");
-	}
-
-	printk("Cancelling thread %d\n", id);
-	pthread_cancel(self);
-	printk("Thread %d could not be cancelled\n", id);
-	sleep(ONE_SECOND);
-	pthread_exit(p1);
-	return NULL;
-}
-
-/* Test the internal priority conversion functions */
-int zephyr_to_posix_priority(int z_prio, int *policy);
-int posix_to_zephyr_priority(int priority, int policy);
-ZTEST(pthread, test_pthread_priority_conversion)
-{
-	/*
-	 *    ZEPHYR [-CONFIG_NUM_COOP_PRIORITIES, -1]
-	 *                       TO
-	 * POSIX(FIFO) [0, CONFIG_NUM_COOP_PRIORITIES - 1]
-	 */
-	for (int z_prio = -CONFIG_NUM_COOP_PRIORITIES, prio = CONFIG_NUM_COOP_PRIORITIES - 1,
-		 p_prio, policy;
-	     z_prio <= -1; z_prio++, prio--) {
-		p_prio = zephyr_to_posix_priority(z_prio, &policy);
-		zassert_equal(policy, SCHED_FIFO);
-		zassert_equal(p_prio, prio, "%d %d\n", p_prio, prio);
-		zassert_equal(z_prio, posix_to_zephyr_priority(p_prio, SCHED_FIFO));
-	}
-
-	/*
-	 *  ZEPHYR [0, CONFIG_NUM_PREEMPT_PRIORITIES - 1]
-	 *                      TO
-	 * POSIX(RR) [0, CONFIG_NUM_PREEMPT_PRIORITIES - 1]
-	 */
-	for (int z_prio = 0, prio = CONFIG_NUM_PREEMPT_PRIORITIES - 1, p_prio, policy;
-	     z_prio < CONFIG_NUM_PREEMPT_PRIORITIES; z_prio++, prio--) {
-		p_prio = zephyr_to_posix_priority(z_prio, &policy);
-		zassert_equal(policy, SCHED_RR);
-		zassert_equal(p_prio, prio, "%d %d\n", p_prio, prio);
-		zassert_equal(z_prio, posix_to_zephyr_priority(p_prio, SCHED_RR));
-	}
-}
-
-ZTEST(pthread, test_pthread_execution)
-{
-	int i, ret;
-	pthread_t newthread[N_THR_E];
-	void *retval;
-	int serial_threads = 0;
-	static const char thr_name[] = "thread name";
-	char thr_name_buf[CONFIG_THREAD_MAX_NAME_LEN];
-
-	/*
-	 * initialize barriers the standard way after deprecating
-	 * PTHREAD_BARRIER_DEFINE().
-	 */
-	zassert_ok(pthread_barrier_init(&barrier, NULL, N_THR_E));
-
-	sem_init(&main_sem, 0, 1);
-
-	/* TESTPOINT: Try getting name of NULL thread (aka uninitialized
-	 * thread var).
-	 */
-	ret = pthread_getname_np(PTHREAD_INVALID, thr_name_buf, sizeof(thr_name_buf));
-	zassert_equal(ret, ESRCH, "uninitialized getname!");
-
-	for (i = 0; i < N_THR_E; i++) {
-		ret = pthread_create(&newthread[i], NULL, thread_top_exec, INT_TO_POINTER(i));
-	}
-
-	/* TESTPOINT: Try setting name of NULL thread (aka uninitialized
-	 * thread var).
-	 */
-	ret = pthread_setname_np(PTHREAD_INVALID, thr_name);
-	zassert_equal(ret, ESRCH, "uninitialized setname!");
-
-	/* TESTPOINT: Try getting thread name with no buffer */
-	ret = pthread_getname_np(newthread[0], NULL, sizeof(thr_name_buf));
-	zassert_equal(ret, EINVAL, "uninitialized getname!");
-
-	/* TESTPOINT: Try setting thread name with no buffer */
-	ret = pthread_setname_np(newthread[0], NULL);
-	zassert_equal(ret, EINVAL, "uninitialized setname!");
-
-	/* TESTPOINT: Try setting thread name */
-	ret = pthread_setname_np(newthread[0], thr_name);
-	zassert_false(ret, "Set thread name failed!");
-
-	/* TESTPOINT: Try getting thread name */
-	ret = pthread_getname_np(newthread[0], thr_name_buf, sizeof(thr_name_buf));
-	zassert_false(ret, "Get thread name failed!");
-
-	/* TESTPOINT: Thread names match */
-	ret = strncmp(thr_name, thr_name_buf, MIN(strlen(thr_name), strlen(thr_name_buf)));
-	zassert_false(ret, "Thread names don't match!");
-
-	while (!bounce_test_done()) {
-		sem_wait(&main_sem);
-	}
-
-	/* TESTPOINT: Check if bounce test passes */
-	zassert_false(bounce_failed, "Bounce test failed");
-
-	printk("Bounce test OK\n");
-
-	/* Wake up the worker threads */
-	pthread_mutex_lock(&lock);
-	pthread_cond_broadcast(&cvar1);
-	pthread_mutex_unlock(&lock);
-
-	while (!barrier_test_done()) {
-		sem_wait(&main_sem);
-	}
-
-	/* TESTPOINT: Check if barrier test passes */
-	zassert_false(barrier_failed, "Barrier test failed");
-
-	for (i = 0; i < N_THR_E; i++) {
-		pthread_join(newthread[i], &retval);
-	}
-
-	for (i = 0; i < N_THR_E; i++) {
-		if (barrier_return[i] == PTHREAD_BARRIER_SERIAL_THREAD) {
-			++serial_threads;
-		}
-	}
-
-	/* TESTPOINT: Check only one PTHREAD_BARRIER_SERIAL_THREAD returned. */
-	zassert_true(serial_threads == 1, "Bungled barrier return value(s)");
-
-	printk("Barrier test OK\n");
-}
-
-ZTEST(pthread, test_pthread_termination)
-{
-	int32_t i, ret;
-	pthread_t newthread[N_THR_T] = {0};
-	void *retval;
-
-	/* Creating 4 threads */
-	for (i = 0; i < N_THR_T; i++) {
-		zassert_ok(pthread_create(&newthread[i], NULL, thread_top_term, INT_TO_POINTER(i)));
-	}
-
-	/* TESTPOINT: Try setting invalid cancel state to current thread */
-	ret = pthread_setcancelstate(PTHREAD_CANCEL_INVALID, NULL);
-	zassert_equal(ret, EINVAL, "invalid cancel state set!");
-
-	for (i = 0; i < N_THR_T; i++) {
-		if (i < DETACH_THR_ID) {
-			zassert_ok(pthread_join(newthread[i], &retval));
-		}
-	}
-
-	/* TESTPOINT: Test for deadlock */
-	ret = pthread_join(pthread_self(), &retval);
-	zassert_equal(ret, EDEADLK, "thread joined with self inexplicably!");
-
-	/* TESTPOINT: Try canceling a terminated thread */
-	ret = pthread_cancel(newthread[0]);
-	zassert_equal(ret, ESRCH, "cancelled a terminated thread!");
-}
-
-ZTEST(pthread, test_pthread_tryjoin)
-{
-	pthread_t th = {0};
-	int sleep_duration_ms = 200;
-	void *retval;
-
-	/* Creating a thread that exits after 200ms*/
-	zassert_ok(pthread_create(&th, NULL, timedjoin_thread, INT_TO_POINTER(sleep_duration_ms)));
-
-	/* Attempting to join, when thread is still running, should fail */
-	usleep(USEC_PER_MSEC * sleep_duration_ms / 2);
-	zassert_equal(pthread_tryjoin_np(th, &retval), EBUSY);
-
-	/* Sleep so thread will exit */
-	usleep(USEC_PER_MSEC * sleep_duration_ms);
-
-	/* Attempting to join without blocking should succeed now */
-	zassert_ok(pthread_tryjoin_np(th, &retval));
-}
-
-ZTEST(pthread, test_pthread_timedjoin)
-{
-	pthread_t th = {0};
-	int sleep_duration_ms = 200;
-	void *ret;
-	struct timespec not_done;
-	struct timespec done;
-	struct timespec invalid[] = {
-		{.tv_nsec = -1},
-		{.tv_nsec = NSEC_PER_SEC},
-	};
-
-	/* setup timespecs when the thread is still running and when it is done */
-	clock_gettime(CLOCK_REALTIME, &not_done);
-	clock_gettime(CLOCK_REALTIME, &done);
-	not_done.tv_nsec += sleep_duration_ms / 2 * NSEC_PER_MSEC;
-	done.tv_nsec += sleep_duration_ms * 1.5 * NSEC_PER_MSEC;
-	while (not_done.tv_nsec >= NSEC_PER_SEC) {
-		not_done.tv_sec++;
-		not_done.tv_nsec -= NSEC_PER_SEC;
-	}
-	while (done.tv_nsec >= NSEC_PER_SEC) {
-		done.tv_sec++;
-		done.tv_nsec -= NSEC_PER_SEC;
-	}
-
-	/* Creating a thread that exits after 200ms*/
-	zassert_ok(pthread_create(&th, NULL, timedjoin_thread, INT_TO_POINTER(sleep_duration_ms)));
-
-	/* pthread_timedjoin-np must return EINVAL for invalid struct timespecs */
-	zassert_equal(pthread_timedjoin_np(th, &ret, NULL), EINVAL);
-	for (size_t i = 0; i < ARRAY_SIZE(invalid); ++i) {
-		zassert_equal(pthread_timedjoin_np(th, &ret, &invalid[i]), EINVAL);
-	}
-
-	/* Attempting to join with a timeout, when the thread is still running should fail */
-	zassert_equal(pthread_timedjoin_np(th, &ret, &not_done), ETIMEDOUT);
-
-	/* Attempting to join with a timeout, when the thread is done, should succeed */
-	zassert_ok(pthread_timedjoin_np(th, &ret, &done));
-}
-
-static void *create_thread1(void *p1)
-{
-	/* do nothing */
-	return NULL;
-}
-
-ZTEST(pthread, test_pthread_descriptor_leak)
-{
-	pthread_t pthread1;
-
-	/* If we are leaking descriptors, then this loop will never complete */
-	for (size_t i = 0; i < CONFIG_POSIX_THREAD_THREADS_MAX * 2; ++i) {
-		zassert_ok(pthread_create(&pthread1, NULL, create_thread1, NULL),
-			   "unable to create thread %zu", i);
-		zassert_ok(pthread_join(pthread1, NULL), "unable to join thread %zu", i);
-	}
-}
-
-ZTEST(pthread, test_pthread_equal)
-{
-	zassert_true(pthread_equal(pthread_self(), pthread_self()));
-	zassert_false(pthread_equal(pthread_self(), (pthread_t)4242));
-}
-
-static void cleanup_handler(void *arg)
-{
-	bool *boolp = (bool *)arg;
-
-	*boolp = true;
-}
-
-static void *test_pthread_cleanup_entry(void *arg)
-{
-	bool executed[2] = {0};
-
-	pthread_cleanup_push(cleanup_handler, &executed[0]);
-	pthread_cleanup_push(cleanup_handler, &executed[1]);
-	pthread_cleanup_pop(false);
-	pthread_cleanup_pop(true);
-
-	zassert_true(executed[0]);
-	zassert_false(executed[1]);
-
-	return NULL;
-}
-
-ZTEST(pthread, test_pthread_cleanup)
-{
-	pthread_t th;
-
-	zassert_ok(pthread_create(&th, NULL, test_pthread_cleanup_entry, NULL));
-	zassert_ok(pthread_join(th, NULL));
-}
-
-static bool testcancel_ignored;
-static bool testcancel_failed;
-
-static void *test_pthread_cancel_fn(void *arg)
-{
-	zassert_ok(pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL));
-
-	testcancel_ignored = false;
-
-	/* this should be ignored */
-	pthread_testcancel();
-
-	testcancel_ignored = true;
-
-	/* this will mark it pending */
-	zassert_ok(pthread_cancel(pthread_self()));
-
-	/* enable the thread to be cancelled */
-	zassert_ok(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL));
-
-	testcancel_failed = false;
-
-	/* this should terminate the thread */
-	pthread_testcancel();
-
-	testcancel_failed = true;
-
-	return NULL;
-}
-
-ZTEST(pthread, test_pthread_testcancel)
-{
-	pthread_t th;
-
-	zassert_ok(pthread_create(&th, NULL, test_pthread_cancel_fn, NULL));
-	zassert_ok(pthread_join(th, NULL));
-	zassert_true(testcancel_ignored);
-	zassert_false(testcancel_failed);
-}
-
-#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)
-static void *test_pthread_setschedprio_fn(void *arg)
-{
-	int policy;
-	int prio = 0;
-	struct sched_param param;
-	pthread_t self = pthread_self();
-
-	zassert_equal(pthread_setschedprio(self, PRIO_INVALID), EINVAL, "EINVAL was expected");
-	zassert_equal(pthread_setschedprio(PTHREAD_INVALID, prio), ESRCH, "ESRCH was expected");
-
-	zassert_ok(pthread_setschedprio(self, prio));
-	param.sched_priority = ~prio;
-	zassert_ok(pthread_getschedparam(self, &policy, &param));
-	zassert_equal(param.sched_priority, prio, "Priority unchanged");
-
-	return NULL;
-}
-
-ZTEST(pthread, test_pthread_setschedprio)
-{
-	pthread_t th;
-
-	zassert_ok(pthread_create(&th, NULL, test_pthread_setschedprio_fn, NULL));
-	zassert_ok(pthread_join(th, NULL));
-}
-#endif
-
-static void before(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	if (!IS_ENABLED(CONFIG_DYNAMIC_THREAD)) {
-		/* skip redundant testing if there is no thread pool / heap allocation */
-		ztest_test_skip();
-	}
-}
-
-ZTEST_SUITE(pthread, NULL, NULL, before, NULL, NULL);
diff --git a/tests/posix/common/src/pthread_attr.c b/tests/posix/common/src/pthread_attr.c
deleted file mode 100644
index 96de97d31c6..00000000000
--- a/tests/posix/common/src/pthread_attr.c
+++ /dev/null
@@ -1,599 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-#include <sched.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define BIOS_FOOD           0xB105F00D
-#define SCHED_INVALID       4242
-#define INVALID_DETACHSTATE 7373
-
-static bool attr_valid;
-static pthread_attr_t attr;
-static const pthread_attr_t uninit_attr;
-static bool detached_thread_has_finished;
-
-/* TODO: this should be optional */
-#define STATIC_THREAD_STACK_SIZE (MAX(1024, K_KERNEL_STACK_LEN(0) + CONFIG_TEST_EXTRA_STACK_SIZE))
-static K_THREAD_STACK_DEFINE(static_thread_stack, STATIC_THREAD_STACK_SIZE);
-
-static void *thread_entry(void *arg)
-{
-	bool joinable = (bool)POINTER_TO_UINT(arg);
-
-	if (!joinable) {
-		detached_thread_has_finished = true;
-	}
-
-	return NULL;
-}
-
-static void create_thread_common_entry(const pthread_attr_t *attrp, bool expect_success,
-				       bool joinable, void *(*entry)(void *arg), void *arg)
-{
-	pthread_t th;
-
-	if (!joinable) {
-		detached_thread_has_finished = false;
-	}
-
-	if (expect_success) {
-		zassert_ok(pthread_create(&th, attrp, entry, arg));
-	} else {
-		zassert_not_ok(pthread_create(&th, attrp, entry, arg));
-		return;
-	}
-
-	if (joinable) {
-		zassert_ok(pthread_join(th, NULL), "failed to join joinable thread");
-		return;
-	}
-
-	/* should not be able to join detached thread */
-	zassert_not_ok(pthread_join(th, NULL));
-
-	for (size_t i = 0; i < 10; ++i) {
-		k_msleep(2 * CONFIG_PTHREAD_RECYCLER_DELAY_MS);
-		if (detached_thread_has_finished) {
-			break;
-		}
-	}
-
-	zassert_true(detached_thread_has_finished, "detached thread did not seem to finish");
-}
-
-static void create_thread_common(const pthread_attr_t *attrp, bool expect_success, bool joinable)
-{
-	create_thread_common_entry(attrp, expect_success, joinable, thread_entry,
-				   UINT_TO_POINTER(joinable));
-}
-
-static inline void can_create_thread(const pthread_attr_t *attrp)
-{
-	create_thread_common(attrp, true, true);
-}
-
-static inline void cannot_create_thread(const pthread_attr_t *attrp)
-{
-	create_thread_common(attrp, false, true);
-}
-
-ZTEST(pthread_attr, test_null_attr)
-{
-	/*
-	 * This test can only succeed when it is possible to call pthread_create() with a NULL
-	 * pthread_attr_t* (I.e. when we have the ability to allocate thread stacks dynamically).
-	 */
-	create_thread_common(NULL, IS_ENABLED(CONFIG_DYNAMIC_THREAD) ? true : false, true);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_static_corner_cases)
-{
-	pthread_attr_t attr1;
-
-	Z_TEST_SKIP_IFDEF(CONFIG_DYNAMIC_THREAD);
-
-	/*
-	 * These tests are specifically for when dynamic thread stacks are disabled, so passing
-	 * a NULL pthread_attr_t* should fail.
-	 */
-	cannot_create_thread(NULL);
-
-	/*
-	 * Additionally, without calling pthread_attr_setstack(), thread creation should fail.
-	 */
-	zassert_ok(pthread_attr_init(&attr1));
-	cannot_create_thread(&attr1);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_init_destroy)
-{
-	/* attr has already been initialized in before() */
-
-	if (false) {
-		/* undefined behaviour */
-		zassert_ok(pthread_attr_init(&attr));
-	}
-
-	/* cannot destroy an uninitialized attr */
-	zassert_equal(pthread_attr_destroy((pthread_attr_t *)&uninit_attr), EINVAL);
-
-	can_create_thread(&attr);
-
-	/* can destroy an initialized attr */
-	zassert_ok(pthread_attr_destroy(&attr), "failed to destroy an initialized attr");
-	attr_valid = false;
-
-	cannot_create_thread(&attr);
-
-	if (false) {
-		/* undefined behaviour */
-		zassert_ok(pthread_attr_destroy(&attr));
-	}
-
-	/* can re-initialize a destroyed attr */
-	zassert_ok(pthread_attr_init(&attr));
-	/* TODO: pthread_attr_init() should be sufficient to initialize a thread by itself */
-	zassert_ok(pthread_attr_setstack(&attr, &static_thread_stack, STATIC_THREAD_STACK_SIZE));
-	attr_valid = true;
-
-	can_create_thread(&attr);
-
-	/* note: attr is still valid and is destroyed in after() */
-}
-
-#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)
-ZTEST(pthread_attr, test_pthread_attr_getschedparam)
-{
-	struct sched_param param = {
-		.sched_priority = BIOS_FOOD,
-	};
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getschedparam(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getschedparam(NULL, &param), EINVAL);
-			zassert_equal(pthread_attr_getschedparam(&uninit_attr, &param), EINVAL);
-		}
-		zassert_equal(pthread_attr_getschedparam(&attr, NULL), EINVAL);
-	}
-
-	/* only check to see that the function succeeds and sets param */
-	zassert_ok(pthread_attr_getschedparam(&attr, &param));
-	zassert_not_equal(BIOS_FOOD, param.sched_priority);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_setschedparam)
-{
-	struct sched_param param = {0};
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setschedparam(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_setschedparam(NULL, &param), EINVAL);
-			zassert_equal(
-				pthread_attr_setschedparam((pthread_attr_t *)&uninit_attr, &param),
-				EINVAL);
-		}
-		zassert_equal(pthread_attr_setschedparam(&attr, NULL), EINVAL);
-	}
-
-	zassert_ok(pthread_attr_setschedparam(&attr, &param));
-
-	can_create_thread(&attr);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_getschedpolicy)
-{
-	int policy = BIOS_FOOD;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getschedpolicy(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getschedpolicy(NULL, &policy), EINVAL);
-			zassert_equal(pthread_attr_getschedpolicy(&uninit_attr, &policy), EINVAL);
-		}
-		zassert_equal(pthread_attr_getschedpolicy(&attr, NULL), EINVAL);
-	}
-
-	/* only check to see that the function succeeds and sets policy */
-	zassert_ok(pthread_attr_getschedpolicy(&attr, &policy));
-	zassert_not_equal(BIOS_FOOD, policy);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_setschedpolicy)
-{
-	int policy = SCHED_OTHER;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setschedpolicy(NULL, SCHED_INVALID), EINVAL);
-			zassert_equal(pthread_attr_setschedpolicy(NULL, policy), EINVAL);
-			zassert_equal(
-				pthread_attr_setschedpolicy((pthread_attr_t *)&uninit_attr, policy),
-				EINVAL);
-		}
-		zassert_equal(pthread_attr_setschedpolicy(&attr, SCHED_INVALID), EINVAL);
-	}
-
-	zassert_ok(pthread_attr_setschedpolicy(&attr, SCHED_OTHER));
-	/* read back the same policy we just wrote */
-	policy = SCHED_INVALID;
-	zassert_ok(pthread_attr_getschedpolicy(&attr, &policy));
-	zassert_equal(policy, SCHED_OTHER);
-
-	can_create_thread(&attr);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_getscope)
-{
-	int contentionscope = BIOS_FOOD;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getscope(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getscope(NULL, &contentionscope), EINVAL);
-			zassert_equal(pthread_attr_getscope(&uninit_attr, &contentionscope),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_getscope(&attr, NULL), EINVAL);
-	}
-
-	zassert_ok(pthread_attr_getscope(&attr, &contentionscope));
-	zassert_equal(contentionscope, PTHREAD_SCOPE_SYSTEM);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_setscope)
-{
-	int contentionscope = BIOS_FOOD;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setscope(NULL, PTHREAD_SCOPE_SYSTEM), EINVAL);
-			zassert_equal(pthread_attr_setscope(NULL, contentionscope), EINVAL);
-			zassert_equal(pthread_attr_setscope((pthread_attr_t *)&uninit_attr,
-							    contentionscope),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_setscope(&attr, 3), EINVAL);
-	}
-
-	zassert_equal(pthread_attr_setscope(&attr, PTHREAD_SCOPE_PROCESS), ENOTSUP);
-	zassert_ok(pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM));
-	zassert_ok(pthread_attr_getscope(&attr, &contentionscope));
-	zassert_equal(contentionscope, PTHREAD_SCOPE_SYSTEM);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_getinheritsched)
-{
-	int inheritsched = BIOS_FOOD;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getinheritsched(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getinheritsched(NULL, &inheritsched), EINVAL);
-			zassert_equal(pthread_attr_getinheritsched(&uninit_attr, &inheritsched),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_getinheritsched(&attr, NULL), EINVAL);
-	}
-
-	zassert_ok(pthread_attr_getinheritsched(&attr, &inheritsched));
-	zassert_equal(inheritsched, PTHREAD_INHERIT_SCHED);
-}
-
-static void *inheritsched_entry(void *arg)
-{
-	int prio;
-	int inheritsched;
-	int pprio = POINTER_TO_INT(arg);
-
-	zassert_ok(pthread_attr_getinheritsched(&attr, &inheritsched));
-
-	prio = k_thread_priority_get(k_current_get());
-
-	if (inheritsched == PTHREAD_INHERIT_SCHED) {
-		/*
-		 * There will be numerical overlap between posix priorities in different scheduler
-		 * policies so only check the Zephyr priority here. The posix policy and posix
-		 * priority are derived from the Zephyr priority in any case.
-		 */
-		zassert_equal(prio, pprio, "actual priority: %d, expected priority: %d", prio,
-			      pprio);
-		return NULL;
-	}
-
-	/* inheritsched == PTHREAD_EXPLICIT_SCHED */
-	int act_prio;
-	int exp_prio;
-	int act_policy;
-	int exp_policy;
-	struct sched_param param;
-
-	/* get the actual policy, param, etc */
-	zassert_ok(pthread_getschedparam(pthread_self(), &act_policy, &param));
-	act_prio = param.sched_priority;
-
-	/* get the expected policy, param, etc */
-	zassert_ok(pthread_attr_getschedpolicy(&attr, &exp_policy));
-	zassert_ok(pthread_attr_getschedparam(&attr, &param));
-	exp_prio = param.sched_priority;
-
-	/* compare actual vs expected */
-	zassert_equal(act_policy, exp_policy, "actual policy: %d, expected policy: %d", act_policy,
-		      exp_policy);
-	zassert_equal(act_prio, exp_prio, "actual priority: %d, expected priority: %d", act_prio,
-		      exp_prio);
-
-	return NULL;
-}
-
-static void test_pthread_attr_setinheritsched_common(bool inheritsched)
-{
-	int prio;
-	int policy;
-	struct sched_param param;
-
-	extern int zephyr_to_posix_priority(int priority, int *policy);
-
-	prio = k_thread_priority_get(k_current_get());
-	zassert_not_equal(prio, K_LOWEST_APPLICATION_THREAD_PRIO);
-
-	/*
-	 * values affected by inheritsched are policy / priority / contentionscope
-	 *
-	 * we only support PTHREAD_SCOPE_SYSTEM, so no need to set contentionscope
-	 */
-	prio = K_LOWEST_APPLICATION_THREAD_PRIO;
-	param.sched_priority = zephyr_to_posix_priority(prio, &policy);
-
-	zassert_ok(pthread_attr_setschedpolicy(&attr, policy));
-	zassert_ok(pthread_attr_setschedparam(&attr, &param));
-	zassert_ok(pthread_attr_setinheritsched(&attr, inheritsched));
-	create_thread_common_entry(&attr, true, true, inheritsched_entry,
-				   UINT_TO_POINTER(k_thread_priority_get(k_current_get())));
-}
-
-ZTEST(pthread_attr, test_pthread_attr_setinheritsched)
-{
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setinheritsched(NULL, PTHREAD_EXPLICIT_SCHED),
-				      EINVAL);
-			zassert_equal(pthread_attr_setinheritsched(NULL, PTHREAD_INHERIT_SCHED),
-				      EINVAL);
-			zassert_equal(pthread_attr_setinheritsched((pthread_attr_t *)&uninit_attr,
-								   PTHREAD_INHERIT_SCHED),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_setinheritsched(&attr, 3), EINVAL);
-	}
-
-	/* valid cases */
-	test_pthread_attr_setinheritsched_common(PTHREAD_INHERIT_SCHED);
-	test_pthread_attr_setinheritsched_common(PTHREAD_EXPLICIT_SCHED);
-}
-#endif
-
-ZTEST(pthread_attr, test_pthread_attr_large_stacksize)
-{
-	size_t actual_size;
-	const size_t expect_size = BIT(CONFIG_POSIX_PTHREAD_ATTR_STACKSIZE_BITS);
-
-	if (pthread_attr_setstacksize(&attr, expect_size) != 0) {
-		TC_PRINT("Unable to allocate large stack of size %zu (skipping)\n", expect_size);
-		ztest_test_skip();
-		return;
-	}
-
-	zassert_ok(pthread_attr_getstacksize(&attr, &actual_size));
-	zassert_equal(actual_size, expect_size);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_getdetachstate)
-{
-	int detachstate;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getdetachstate(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getdetachstate(NULL, &detachstate), EINVAL);
-			zassert_equal(pthread_attr_getdetachstate(&uninit_attr, &detachstate),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_getdetachstate(&attr, NULL), EINVAL);
-	}
-
-	/* default detachstate is joinable */
-	zassert_ok(pthread_attr_getdetachstate(&attr, &detachstate));
-	zassert_equal(detachstate, PTHREAD_CREATE_JOINABLE);
-	can_create_thread(&attr);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_setdetachstate)
-{
-	int detachstate = PTHREAD_CREATE_JOINABLE;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setdetachstate(NULL, INVALID_DETACHSTATE),
-				      EINVAL);
-			zassert_equal(pthread_attr_setdetachstate(NULL, detachstate), EINVAL);
-			zassert_equal(pthread_attr_setdetachstate((pthread_attr_t *)&uninit_attr,
-								  detachstate),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_setdetachstate(&attr, INVALID_DETACHSTATE), EINVAL);
-	}
-
-	/* read back detachstate just written */
-	zassert_ok(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED));
-	zassert_ok(pthread_attr_getdetachstate(&attr, &detachstate));
-	zassert_equal(detachstate, PTHREAD_CREATE_DETACHED);
-	create_thread_common(&attr, true, false);
-}
-
-ZTEST(pthread_attr, test_pthread_attr_policy_and_priority_limits)
-{
-	int pmin = -1;
-	int pmax = -1;
-	struct sched_param param;
-	static const int policies[] = {
-		SCHED_FIFO,
-		SCHED_RR,
-		SCHED_OTHER,
-		SCHED_INVALID,
-	};
-	static const char *const policy_names[] = {
-		"SCHED_FIFO",
-		"SCHED_RR",
-		"SCHED_OTHER",
-		"SCHED_INVALID",
-	};
-	static const bool policy_enabled[] = {
-		CONFIG_NUM_COOP_PRIORITIES > 0,
-		CONFIG_NUM_PREEMPT_PRIORITIES > 0,
-		CONFIG_NUM_PREEMPT_PRIORITIES > 0,
-		false,
-	};
-	static int nprio[] = {
-		CONFIG_NUM_COOP_PRIORITIES,
-		CONFIG_NUM_PREEMPT_PRIORITIES,
-		CONFIG_NUM_PREEMPT_PRIORITIES,
-		42,
-	};
-	const char *const prios[] = {"pmin", "pmax"};
-
-	BUILD_ASSERT(!(SCHED_INVALID == SCHED_FIFO || SCHED_INVALID == SCHED_RR ||
-		       SCHED_INVALID == SCHED_OTHER),
-		     "SCHED_INVALID is itself invalid");
-
-	ARRAY_FOR_EACH(policies, policy) {
-		/* get pmin and pmax for policies[policy] */
-		ARRAY_FOR_EACH(prios, i) {
-			errno = 0;
-			if (i == 0) {
-				pmin = sched_get_priority_min(policies[policy]);
-				param.sched_priority = pmin;
-			} else {
-				pmax = sched_get_priority_max(policies[policy]);
-				param.sched_priority = pmax;
-			}
-
-			if (policy == 3) {
-				/* invalid policy */
-				zassert_equal(-1, param.sched_priority);
-				zassert_equal(errno, EINVAL);
-				continue;
-			}
-
-			zassert_not_equal(-1, param.sched_priority,
-					  "sched_get_priority_%s(%s) failed: %d",
-					  i == 0 ? "min" : "max", policy_names[policy], errno);
-			zassert_ok(errno, "sched_get_priority_%s(%s) set errno to %d",
-				   i == 0 ? "min" : "max", policy_names[policy], errno);
-		}
-
-		if (policy != 3) {
-			/* this will not work for SCHED_INVALID */
-
-			/*
-			 * IEEE 1003.1-2008 Section 2.8.4
-			 * conforming implementations should provide a range of at least 32
-			 * priorities
-			 *
-			 * Note: we relax this requirement
-			 */
-			zassert_true(pmax > pmin,
-				     "%s min/max inconsistency, pmax (%d) <= pmin (%d)",
-				     policy_names[policy], pmax, pmin);
-
-			/*
-			 * Getting into the weeds a bit (i.e. whitebox testing), Zephyr
-			 * cooperative threads use [-CONFIG_NUM_COOP_PRIORITIES,-1] and
-			 * preemptive threads use [0, CONFIG_NUM_PREEMPT_PRIORITIES - 1],
-			 * where the more negative thread has the higher priority. Since we
-			 * cannot map those directly (a return value of -1 indicates error),
-			 * we simply map those to the positive space.
-			 */
-			zassert_equal(pmin, 0, "unexpected pmin for %s", policy_names[policy]);
-			zassert_equal(pmax, nprio[policy] - 1, "unexpected pmax for %s",
-				      policy_names[policy]); /* test happy paths */
-		}
-
-		/* create threads with min and max priority levels for each policy */
-		ARRAY_FOR_EACH(prios, i) {
-			param.sched_priority = (i == 0) ? pmin : pmax;
-
-			if (!policy_enabled[policy]) {
-				zassert_not_ok(
-					pthread_attr_setschedpolicy(&attr, policies[policy]));
-				zassert_not_ok(
-					pthread_attr_setschedparam(&attr, &param),
-					"pthread_attr_setschedparam() failed for %s (%d) of %s",
-					prios[i], param.sched_priority, policy_names[policy]);
-				continue;
-			}
-
-			/* set policy */
-			zassert_ok(pthread_attr_setschedpolicy(&attr, policies[policy]),
-				   "pthread_attr_setschedpolicy() failed for %s (%d) of %s",
-				   prios[i], param.sched_priority, policy_names[policy]);
-
-			/* set priority */
-			zassert_ok(pthread_attr_setschedparam(&attr, &param),
-				   "pthread_attr_setschedparam() failed for %s (%d) of %s",
-				   prios[i], param.sched_priority, policy_names[policy]);
-
-			can_create_thread(&attr);
-		}
-	}
-}
-
-static void before(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	zassert_ok(pthread_attr_init(&attr));
-	/* TODO: pthread_attr_init() should be sufficient to initialize a thread by itself */
-	zassert_ok(pthread_attr_setstack(&attr, &static_thread_stack, STATIC_THREAD_STACK_SIZE));
-	attr_valid = true;
-}
-
-static void after(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	if (attr_valid) {
-		(void)pthread_attr_destroy(&attr);
-		attr_valid = false;
-	}
-}
-
-ZTEST_SUITE(pthread_attr, NULL, NULL, before, after, NULL);
diff --git a/tests/posix/common/src/pwd.c b/tests/posix/common/src/pwd.c
deleted file mode 100644
index dd473569f0d..00000000000
--- a/tests/posix/common/src/pwd.c
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (c) 2024 Meta Platforms
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <pwd.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(pwd, test_pwd_stubs)
-{
-	zassert_equal(getpwnam_r(NULL, NULL, NULL, 42, NULL), ENOSYS);
-	zassert_equal(getpwuid_r(42, NULL, NULL, 42, NULL), ENOSYS);
-}
-
-ZTEST_SUITE(pwd, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/common/testcase.yaml b/tests/posix/common/testcase.yaml
deleted file mode 100644
index 4a778b1b30d..00000000000
--- a/tests/posix/common/testcase.yaml
+++ /dev/null
@@ -1,76 +0,0 @@
-common:
-  tags: posix
-  min_ram: 64
-  timeout: 240
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  filter: not CONFIG_NATIVE_LIBC
-tests:
-  portability.posix.common: {}
-  portability.posix.common.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.common.newlib:
-    platform_exclude:
-      - intel_ehl_crb
-      - lpcxpresso55s06
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.common.armclang_std_libc:
-    toolchain_allow: armclang
-    extra_configs:
-      - CONFIG_ARMCLANG_STD_LIBC=y
-  portability.posix.common.arcmwdtlib:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_ARCMWDT_LIBC=y
-  portability.posix.common.tls:
-    platform_exclude:
-      - intel_ehl_crb
-    filter: CONFIG_ARCH_HAS_THREAD_LOCAL_STORAGE and CONFIG_TOOLCHAIN_SUPPORTS_THREAD_LOCAL_STORAGE
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=n
-      - CONFIG_THREAD_LOCAL_STORAGE=y
-  portability.posix.common.tls.newlib:
-    platform_exclude:
-      - intel_ehl_crb
-      - lpcxpresso55s06
-    filter: TOOLCHAIN_HAS_NEWLIB == 1 and CONFIG_ARCH_HAS_THREAD_LOCAL_STORAGE and
-      CONFIG_TOOLCHAIN_SUPPORTS_THREAD_LOCAL_STORAGE
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-      - CONFIG_THREAD_LOCAL_STORAGE=y
-  portability.posix.common.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
-  portability.posix.common.no_spin_validate:
-    extra_configs:
-      - CONFIG_SPIN_VALIDATE=n
-  portability.posix.common.signal.strsignal_no_desc:
-    extra_configs:
-      - CONFIG_POSIX_SIGNAL_STRING_DESC=n
-  portability.posix.common.signal.big_nsig:
-    extra_configs:
-      - CONFIG_POSIX_RTSIG_MAX=1024
-  portability.posix.common.dynamic_stack:
-    extra_configs:
-      - CONFIG_DYNAMIC_THREAD=y
-      - CONFIG_THREAD_STACK_INFO=y
-      - CONFIG_HEAP_MEM_POOL_SIZE=16384
-      - CONFIG_POSIX_THREAD_KEYS_MAX=2048
-      - CONFIG_TEST_EXTRA_STACK_SIZE=16384
-  portability.posix.common.static_stack:
-    extra_configs:
-      - CONFIG_DYNAMIC_THREAD=n
-      - CONFIG_THREAD_STACK_INFO=n
-  portability.posix.common.userspace:
-    filter: CONFIG_ARCH_HAS_USERSPACE
-    tags:
-      - userspace
-    extra_configs:
-      - CONFIG_USERSPACE=y
diff --git a/tests/posix/eventfd/CMakeLists.txt b/tests/posix/eventfd/CMakeLists.txt
deleted file mode 100644
index 9e8850f96f8..00000000000
--- a/tests/posix/eventfd/CMakeLists.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(eventfd)
-
-FILE(GLOB app_sources src/*.c)
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/tests/posix/eventfd/Kconfig b/tests/posix/eventfd/Kconfig
deleted file mode 100644
index 07a38140bc4..00000000000
--- a/tests/posix/eventfd/Kconfig
+++ /dev/null
@@ -1,43 +0,0 @@
-# Copyright (c) 2023, Meta
-#
-# SPDX-License-Identifier: Apache-2.0
-
-source "Kconfig.zephyr"
-
-config TEST_DURATION_S
-	int "Number of seconds to run the test"
-	range 1 21600
-	default 5
-	help
-	   Duration for the test, in seconds. The range has a reblatively high
-	   upper bound because we should expect that eventfd_read() and
-	   eventfd_write() are stable enough to run for an arbitrarily long
-	   period of time without encountering any race conditions.
-
-config TEST_TIMEOUT_S
-	int "Number of seconds to run the test"
-	range 1 21600
-	default 10
-
-config TEST_STACK_SIZE
-	int "Size of each thread stack in this test"
-	default 2048
-	help
-	  The minimal stack size required to run a no-op thread.
-
-config TEST_EXTRA_ASSERTIONS
-	bool "Add extra assertions into the hot path"
-	help
-	  In order to get a true benchmark, there should be as few branches
-	  as possible on the hot path. Say 'y' here to add extra assertions
-	  on the hot path as well to verify functionality.
-
-config TEST_EXTRA_QUIET
-	bool "Do not print out regular reports"
-	help
-	  In order to get a true benchmark, there should be as few branches
-	  as possible on the hot path. Say 'y' here to skip reporting.
-
-module = EVENTFD_TEST
-module-str = eventfd
-source "subsys/logging/Kconfig.template.log_config"
diff --git a/tests/posix/eventfd/prj.conf b/tests/posix/eventfd/prj.conf
deleted file mode 100644
index 939ff69a077..00000000000
--- a/tests/posix/eventfd/prj.conf
+++ /dev/null
@@ -1,13 +0,0 @@
-# Networking config
-CONFIG_NETWORKING=y
-CONFIG_NET_TEST=y
-CONFIG_NET_SOCKETS=y
-
-# Network driver config
-CONFIG_TEST_RANDOM_GENERATOR=y
-
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_PSE53=y
-CONFIG_XSI_STREAMS=y
-CONFIG_EVENTFD=y
diff --git a/tests/posix/eventfd/src/_main.c b/tests/posix/eventfd/src/_main.c
deleted file mode 100644
index ac45db107d9..00000000000
--- a/tests/posix/eventfd/src/_main.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (c) 2020 Tobias Svehagen
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_main.h"
-
-void reopen(int *fd, int initval, int flags)
-{
-	zassert_not_null(fd);
-	zassert_ok(close(*fd));
-	*fd = eventfd(initval, flags);
-	zassert_true(*fd >= 0, "eventfd(%d, %d) failed: %d", initval, flags, errno);
-}
-
-int is_blocked(int fd, short *event)
-{
-	struct pollfd pfd;
-	int ret;
-
-	pfd.fd = fd;
-	pfd.events = *event;
-
-	ret = poll(&pfd, 1, 0);
-	zassert_true(ret >= 0, "poll failed %d", ret);
-
-	*event = pfd.revents;
-
-	return ret == 0;
-}
-
-void eventfd_poll_unset_common(int fd)
-{
-	eventfd_t val = 0;
-	short event;
-	int ret;
-
-	event = POLLIN;
-	ret = is_blocked(fd, &event);
-	zassert_equal(ret, 1, "eventfd not blocked with initval == 0");
-
-	ret = eventfd_write(fd, TESTVAL);
-	zassert_equal(ret, 0, "write ret %d", ret);
-
-	event = POLLIN;
-	ret = is_blocked(fd, &event);
-	zassert_equal(ret, 0, "eventfd blocked after write");
-	zassert_equal(event, POLLIN, "POLLIN not set");
-
-	ret = eventfd_write(fd, TESTVAL);
-	zassert_equal(ret, 0, "write ret %d", ret);
-
-	ret = eventfd_read(fd, &val);
-	zassert_equal(ret, 0, "read ret %d", ret);
-	zassert_equal(val, 2*TESTVAL, "val == %d, expected %d", (int)val, TESTVAL);
-
-	/* eventfd shall block on subsequent reads */
-
-	event = POLLIN;
-	ret = is_blocked(fd, &event);
-	zassert_equal(ret, 1, "eventfd not blocked after read");
-}
-
-void eventfd_poll_set_common(int fd)
-{
-	eventfd_t val = 0;
-	short event;
-	int ret;
-
-	event = POLLIN;
-	ret = is_blocked(fd, &event);
-	zassert_equal(ret, 0, "eventfd is blocked with initval != 0");
-
-	ret = eventfd_read(fd, &val);
-	zassert_equal(ret, 0, "read ret %d", ret);
-	zassert_equal(val, TESTVAL, "val == %d", (int)val);
-
-	event = POLLIN;
-	ret = is_blocked(fd, &event);
-	zassert_equal(ret, 1, "eventfd is not blocked after read");
-}
-
-static struct eventfd_fixture efd_fixture;
-
-static void *setup(void)
-{
-	efd_fixture.fd = -1;
-	return &efd_fixture;
-}
-
-static void before(void *arg)
-{
-	struct eventfd_fixture *fixture = arg;
-
-	fixture->fd = eventfd(0, 0);
-	zassert_true(fixture->fd >= 0, "eventfd(0, 0) failed: %d", errno);
-}
-
-static void after(void *arg)
-{
-	struct eventfd_fixture *fixture = arg;
-
-	close(fixture->fd);
-	fixture->fd = -1;
-}
-
-ZTEST_SUITE(eventfd, NULL, setup, before, after, NULL);
diff --git a/tests/posix/eventfd/src/_main.h b/tests/posix/eventfd/src/_main.h
deleted file mode 100644
index fd277935eef..00000000000
--- a/tests/posix/eventfd/src/_main.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2020 Tobias Svehagen
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#ifndef TESTS_POSIX_EVENTFD_SRC__MAIN_H_
-#define TESTS_POSIX_EVENTFD_SRC__MAIN_H_
-
-#include <errno.h>
-#include <stdio.h>
-
-#include <zephyr/net/socket.h>
-#include <poll.h>
-#include <sys/eventfd.h>
-#include <unistd.h>
-#include <zephyr/ztest.h>
-
-#define TESTVAL 10
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct eventfd_fixture {
-	int fd;
-};
-
-void reopen(int *fd, int initval, int flags);
-int is_blocked(int fd, short *event);
-void eventfd_poll_set_common(int fd);
-void eventfd_poll_unset_common(int fd);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/tests/posix/eventfd/src/blocking.c b/tests/posix/eventfd/src/blocking.c
deleted file mode 100644
index cc4b0f92df8..00000000000
--- a/tests/posix/eventfd/src/blocking.c
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (c) 2020 Tobias Svehagen
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_main.h"
-
-ZTEST_F(eventfd, test_write_then_read)
-{
-	eventfd_t val;
-	int ret;
-
-	ret = eventfd_write(fixture->fd, 3);
-	zassert_true(ret == 0, "write ret %d", ret);
-
-	ret = eventfd_write(fixture->fd, 2);
-	zassert_true(ret == 0, "write ret %d", ret);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_true(ret == 0, "read ret %d", ret);
-	zassert_true(val == 5, "val == %lld", val);
-
-	/* Test EFD_SEMAPHORE */
-	reopen(&fixture->fd, 0, EFD_SEMAPHORE);
-
-	ret = eventfd_write(fixture->fd, 3);
-	zassert_true(ret == 0, "write ret %d", ret);
-
-	ret = eventfd_write(fixture->fd, 2);
-	zassert_true(ret == 0, "write ret %d", ret);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_true(ret == 0, "read ret %d", ret);
-	zassert_true(val == 1, "val == %lld", val);
-}
-
-ZTEST_F(eventfd, test_zero_shall_not_unblock)
-{
-	short event;
-	int ret;
-
-	ret = eventfd_write(fixture->fd, 0);
-	zassert_equal(ret, 0, "fd == %d", fixture->fd);
-
-	event = POLLIN;
-	ret = is_blocked(fixture->fd, &event);
-	zassert_equal(ret, 1, "eventfd unblocked by zero");
-}
-
-ZTEST_F(eventfd, test_poll_timeout)
-{
-	struct pollfd pfd;
-	int ret;
-
-	pfd.fd = fixture->fd;
-	pfd.events = POLLIN;
-
-	ret = poll(&pfd, 1, 500);
-	zassert_true(ret == 0, "poll ret %d", ret);
-}
-
-ZTEST_F(eventfd, test_set_poll_event_block)
-{
-	reopen(&fixture->fd, TESTVAL, 0);
-	eventfd_poll_set_common(fixture->fd);
-}
-
-ZTEST_F(eventfd, test_unset_poll_event_block)
-{
-	eventfd_poll_unset_common(fixture->fd);
-}
-
-K_THREAD_STACK_DEFINE(thread_stack, CONFIG_TEST_STACK_SIZE);
-static struct k_thread thread;
-
-static void thread_eventfd_read_42(void *arg1, void *arg2, void *arg3)
-{
-	eventfd_t value;
-	struct eventfd_fixture *fixture = arg1;
-
-	zassert_ok(eventfd_read(fixture->fd, &value));
-	zassert_equal(value, 42);
-}
-
-ZTEST_F(eventfd, test_read_then_write_block)
-{
-	k_thread_create(&thread, thread_stack, K_THREAD_STACK_SIZEOF(thread_stack),
-			thread_eventfd_read_42, fixture, NULL, NULL, 0, 0, K_NO_WAIT);
-
-	k_msleep(100);
-
-	/* this write never occurs */
-	zassert_ok(eventfd_write(fixture->fd, 42));
-
-	/* unreachable code */
-	k_thread_join(&thread, K_FOREVER);
-}
-
-static void thread_eventfd_write(void *arg1, void *arg2, void *arg3)
-{
-	struct eventfd_fixture *fixture = arg1;
-
-	zassert_ok(eventfd_write(fixture->fd, 71));
-}
-
-ZTEST_F(eventfd, test_write_while_pollin)
-{
-	struct zsock_pollfd fds[] = {
-		{
-			.fd = fixture->fd,
-			.events = ZSOCK_POLLIN,
-		},
-	};
-	eventfd_t value;
-	int ret;
-
-	k_thread_create(&thread, thread_stack, K_THREAD_STACK_SIZEOF(thread_stack),
-			thread_eventfd_write, fixture, NULL, NULL, 0, 0, K_MSEC(100));
-
-	/* Expect 1 event */
-	ret = zsock_poll(fds, ARRAY_SIZE(fds), 200);
-	zassert_equal(ret, 1);
-
-	zassert_equal(fds[0].revents, ZSOCK_POLLIN);
-
-	/* Check value */
-	zassert_ok(eventfd_read(fixture->fd, &value));
-	zassert_equal(value, 71);
-
-	zassert_ok(k_thread_join(&thread, K_FOREVER));
-}
-
-static void thread_eventfd_read(void *arg1, void *arg2, void *arg3)
-{
-	eventfd_t value;
-	struct eventfd_fixture *fixture = arg1;
-
-	zassert_ok(eventfd_read(fixture->fd, &value));
-}
-
-ZTEST_F(eventfd, test_read_while_pollout)
-{
-	struct zsock_pollfd fds[] = {
-		{
-			.fd = fixture->fd,
-			.events = ZSOCK_POLLOUT,
-		},
-	};
-	int ret;
-
-	zassert_ok(eventfd_write(fixture->fd, UINT64_MAX - 1));
-
-	k_thread_create(&thread, thread_stack, K_THREAD_STACK_SIZEOF(thread_stack),
-			thread_eventfd_read, fixture, NULL, NULL, 0, 0, K_MSEC(100));
-
-	/* Expect 1 event */
-	ret = zsock_poll(fds, ARRAY_SIZE(fds), 200);
-	zassert_equal(ret, 1);
-
-	zassert_equal(fds[0].revents, ZSOCK_POLLOUT);
-
-	zassert_ok(k_thread_join(&thread, K_FOREVER));
-}
diff --git a/tests/posix/eventfd/src/ioctl.c b/tests/posix/eventfd/src/ioctl.c
deleted file mode 100644
index d035b5d6cec..00000000000
--- a/tests/posix/eventfd/src/ioctl.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2024 Celina Sophie Kalus
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_main.h"
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-
-#define EFD_IN_USE_INTERNAL 0x1
-
-ZTEST_F(eventfd, test_set_flags)
-{
-	eventfd_t val;
-	int ret;
-	int flags;
-	short event;
-
-	/* Get current flags; Expect blocking, non-semaphore. */
-	flags = ioctl(fixture->fd, F_GETFL, 0);
-	zassert_equal(flags, 0, "flags == %d", flags);
-
-	event = POLLIN;
-	ret = is_blocked(fixture->fd, &event);
-	zassert_equal(ret, 1, "eventfd read not blocked");
-
-	/* Try writing and reading. Should not fail. */
-	ret = eventfd_write(fixture->fd, 3);
-	zassert_ok(ret);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_ok(ret);
-	zassert_equal(val, 3, "val == %lld", val);
-
-
-	/* Set nonblocking without reopening. */
-	ret = ioctl(fixture->fd, F_SETFL, O_NONBLOCK);
-	zassert_ok(ret);
-
-	flags = ioctl(fixture->fd, F_GETFL, 0);
-	zassert_equal(flags, O_NONBLOCK, "flags == %d", flags);
-
-	event = POLLOUT;
-	ret = is_blocked(fixture->fd, &event);
-	zassert_equal(ret, 0, "eventfd write blocked");
-
-
-	/* Try writing and reading again. */
-	ret = eventfd_write(fixture->fd, 19);
-	zassert_ok(ret);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_ok(ret);
-	zassert_equal(val, 19, "val == %lld", val);
-
-
-	/* Set back to blocking. */
-	ret = ioctl(fixture->fd, F_SETFL, 0);
-	zassert_ok(ret);
-
-	flags = ioctl(fixture->fd, F_GETFL, 0);
-	zassert_equal(flags, 0, "flags == %d", flags);
-
-	event = POLLIN;
-	ret = is_blocked(fixture->fd, &event);
-	zassert_equal(ret, 1, "eventfd read not blocked");
-
-
-	/* Try writing and reading again. */
-	ret = eventfd_write(fixture->fd, 10);
-	zassert_ok(ret);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_ok(ret);
-	zassert_equal(val, 10, "val == %lld", val);
-
-
-	/* Test setting internal in-use-flag. Should fail. */
-	ret = ioctl(fixture->fd, F_SETFL, EFD_IN_USE_INTERNAL);
-	zassert_not_ok(ret);
-
-
-	/* File descriptor should still be valid and working. */
-	ret = eventfd_write(fixture->fd, 97);
-	zassert_ok(ret);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_ok(ret);
-	zassert_equal(val, 97, "val == %lld", val);
-}
diff --git a/tests/posix/eventfd/src/nonblocking.c b/tests/posix/eventfd/src/nonblocking.c
deleted file mode 100644
index a2ff83d52e7..00000000000
--- a/tests/posix/eventfd/src/nonblocking.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (c) 2020 Tobias Svehagen
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_main.h"
-
-ZTEST_F(eventfd, test_read_nonblock)
-{
-	eventfd_t val = 0;
-	int ret;
-
-	reopen(&fixture->fd, 0, EFD_NONBLOCK);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_true(ret == -1, "read unset ret %d", ret);
-	zassert_true(errno == EAGAIN, "errno %d", errno);
-
-	ret = eventfd_write(fixture->fd, TESTVAL);
-	zassert_true(ret == 0, "write ret %d", ret);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_true(ret == 0, "read set ret %d", ret);
-	zassert_true(val == TESTVAL, "red set val %lld", val);
-
-	ret = eventfd_read(fixture->fd, &val);
-	zassert_true(ret == -1, "read subsequent ret %d val %lld", ret, val);
-	zassert_true(errno == EAGAIN, "errno %d", errno);
-}
-
-ZTEST_F(eventfd, test_set_poll_event_nonblock)
-{
-	reopen(&fixture->fd, TESTVAL, EFD_NONBLOCK);
-	eventfd_poll_set_common(fixture->fd);
-}
-
-ZTEST_F(eventfd, test_unset_poll_event_nonblock)
-{
-	reopen(&fixture->fd, 0, EFD_NONBLOCK);
-	eventfd_poll_unset_common(fixture->fd);
-}
-
-ZTEST_F(eventfd, test_overflow)
-{
-	short event;
-	int ret;
-
-	reopen(&fixture->fd, 0, EFD_NONBLOCK);
-
-	event = POLLOUT;
-	ret = is_blocked(fixture->fd, &event);
-	zassert_equal(ret, 0, "eventfd write blocked with initval == 0");
-
-	ret = eventfd_write(fixture->fd, UINT64_MAX);
-	zassert_equal(ret, -1, "fd == %d", fixture->fd);
-	zassert_equal(errno, EINVAL, "did not get EINVAL");
-
-	ret = eventfd_write(fixture->fd, UINT64_MAX-1);
-	zassert_equal(ret, 0, "fd == %d", fixture->fd);
-
-	event = POLLOUT;
-	ret = is_blocked(fixture->fd, &event);
-	zassert_equal(ret, 1, "eventfd write not blocked with cnt == UINT64_MAX-1");
-
-	ret = eventfd_write(fixture->fd, 1);
-	zassert_equal(ret, -1, "fd == %d", fixture->fd);
-	zassert_equal(errno, EAGAIN, "did not get EINVAL");
-}
diff --git a/tests/posix/eventfd/src/stress.c b/tests/posix/eventfd/src/stress.c
deleted file mode 100644
index 40d55671521..00000000000
--- a/tests/posix/eventfd/src/stress.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_main.h"
-
-/* update interval for printing stats */
-#if CONFIG_TEST_DURATION_S >= 60
-#define UPDATE_INTERVAL_S 10
-#elif CONFIG_TEST_DURATION_S >= 30
-#define UPDATE_INTERVAL_S 5
-#else
-#define UPDATE_INTERVAL_S 1
-#endif
-
-enum th_id {
-	WRITER,
-	READER,
-};
-
-typedef int (*eventfd_op_t)(int fd);
-
-static size_t count[2];
-static struct k_thread th[2];
-static const char *msg[2] = {
-	[READER] = "reads",
-	[WRITER] = "writes",
-};
-
-static int read_op(int fd);
-static int write_op(int fd);
-
-static const eventfd_op_t op[2] = {
-	[READER] = read_op,
-	[WRITER] = write_op,
-};
-static K_THREAD_STACK_ARRAY_DEFINE(th_stack, 2, CONFIG_TEST_STACK_SIZE);
-
-static int read_op(int fd)
-{
-	eventfd_t value;
-
-	return eventfd_read(fd, &value);
-}
-
-static int write_op(int fd)
-{
-	return eventfd_write(fd, 1);
-}
-
-static void th_fun(void *arg1, void *arg2, void *arg3)
-{
-
-	int ret;
-	uint64_t now;
-	uint64_t end;
-	uint64_t report;
-	enum th_id id = POINTER_TO_UINT(arg1);
-	struct eventfd_fixture *fixture = arg2;
-	const uint64_t report_ms = UPDATE_INTERVAL_S * MSEC_PER_SEC;
-	const uint64_t end_ms = CONFIG_TEST_DURATION_S * MSEC_PER_SEC;
-
-	for (now = k_uptime_get(), end = now + end_ms, report = now + report_ms; now < end;
-	     now = k_uptime_get()) {
-
-		ret = op[id](fixture->fd);
-		if (IS_ENABLED(CONFIG_TEST_EXTRA_ASSERTIONS)) {
-			zassert_true(ret == 0 || (ret == -1 && errno == EAGAIN),
-				     "ret: %d errno: %d", ret, errno);
-		}
-		count[id] += (ret == 0);
-
-		if (!IS_ENABLED(CONFIG_TEST_EXTRA_QUIET)) {
-			if (now >= report) {
-				printk("%zu %s\n", count[id], msg[id]);
-				report += report_ms;
-			}
-		}
-		Z_SPIN_DELAY(10);
-	}
-
-	printk("avg: %zu %s/s\n", (size_t)((count[id] * MSEC_PER_SEC) / end_ms), msg[id]);
-}
-
-ZTEST_F(eventfd, test_stress)
-{
-	enum th_id i;
-	enum th_id begin = MIN(READER, WRITER);
-	enum th_id end = MAX(READER, WRITER) + 1;
-
-	printk("BOARD: %s\n", CONFIG_BOARD);
-	printk("TEST_DURATION_S: %u\n", CONFIG_TEST_DURATION_S);
-	printk("UPDATE_INTERVAL_S: %u\n", UPDATE_INTERVAL_S);
-
-	reopen(&fixture->fd, 0, EFD_NONBLOCK | EFD_SEMAPHORE);
-
-	for (i = begin; i < end; ++i) {
-		k_thread_create(&th[i], th_stack[i], K_THREAD_STACK_SIZEOF(th_stack[0]), th_fun,
-				UINT_TO_POINTER(i), fixture, NULL, K_LOWEST_APPLICATION_THREAD_PRIO,
-				0, K_NO_WAIT);
-	}
-
-	for (i = begin; i < end; ++i) {
-		zassert_ok(k_thread_join(&th[i], K_FOREVER));
-	}
-
-	zassert_true(count[READER] > 0, "read count is zero");
-	zassert_true(count[WRITER] > 0, "write count is zero");
-	zassert_true(count[WRITER] >= count[READER], "read count (%zu) > write count (%zu)",
-		     count[READER], count[WRITER]);
-}
diff --git a/tests/posix/eventfd/testcase.yaml b/tests/posix/eventfd/testcase.yaml
deleted file mode 100644
index 6646036067c..00000000000
--- a/tests/posix/eventfd/testcase.yaml
+++ /dev/null
@@ -1,36 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - eventfd
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_riscv64
-tests:
-  portability.posix.eventfd: {}
-  portability.posix.eventfd.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.eventfd.newlib:
-    platform_exclude:
-      - intel_ehl_crb
-      - lpcxpresso55s06
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.eventfd.armclang_std_libc:
-    toolchain_allow: armclang
-    extra_configs:
-      - CONFIG_ARMCLANG_STD_LIBC=y
-  portability.posix.eventfd.arcmwdtlib:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_ARCMWDT_LIBC=y
-  portability.posix.eventfd.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/fs/CMakeLists.txt b/tests/posix/fs/CMakeLists.txt
deleted file mode 100644
index 6126ee61582..00000000000
--- a/tests/posix/fs/CMakeLists.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(fs)
-
-FILE(GLOB app_sources src/*.c)
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/tests/posix/fs/app.overlay b/tests/posix/fs/app.overlay
deleted file mode 100644
index 87ae21b1e64..00000000000
--- a/tests/posix/fs/app.overlay
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * Copyright (c) 2023 Nordic Semiconductor ASA
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-/ {
-	ramdisk0 {
-		compatible = "zephyr,ram-disk";
-		disk-name = "RAM";
-		sector-size = <512>;
-		sector-count = <160>;
-	};
-};
diff --git a/tests/posix/fs/prj.conf b/tests/posix/fs/prj.conf
deleted file mode 100644
index 675d754cd3b..00000000000
--- a/tests/posix/fs/prj.conf
+++ /dev/null
@@ -1,15 +0,0 @@
-CONFIG_FILE_SYSTEM=y
-CONFIG_LOG=y
-CONFIG_FAT_FILESYSTEM_ELM=y
-CONFIG_POSIX_AEP_CHOICE_PSE52=y
-CONFIG_POSIX_FILE_SYSTEM=y
-CONFIG_POSIX_FILE_SYSTEM_R=y
-# CONFIG_XSI=y is needed for constants S_IFDIR and S_IFREG
-# For more information, please see
-# https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html
-CONFIG_XSI=y
-CONFIG_ZTEST=y
-CONFIG_MAIN_STACK_SIZE=4096
-CONFIG_ZTEST_STACK_SIZE=2048
-CONFIG_EVENTFD=n
-CONFIG_ZVFS_OPEN_ADD_SIZE_POSIX=15
diff --git a/tests/posix/fs/src/main.c b/tests/posix/fs/src/main.c
deleted file mode 100644
index 6a124d25373..00000000000
--- a/tests/posix/fs/src/main.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * Copyright (c) 2018 Codecoup
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "test_fs.h"
-
-ZTEST_SUITE(posix_fs_test, NULL, test_mount, NULL, NULL, test_unmount);
diff --git a/tests/posix/fs/src/test_fat_mount.c b/tests/posix/fs/src/test_fat_mount.c
deleted file mode 100644
index 2ce470bf98d..00000000000
--- a/tests/posix/fs/src/test_fat_mount.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation.
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/fs/fs.h>
-#include <ff.h>
-#include "test_fs.h"
-
-/* FatFs work area */
-static FATFS fat_fs;
-
-/* mounting info */
-static struct fs_mount_t fatfs_mnt = {
-	.type = FS_FATFS,
-	.mnt_point = FATFS_MNTP,
-	.fs_data = &fat_fs,
-};
-
-void *test_mount(void)
-{
-	int res;
-
-	res = fs_mount(&fatfs_mnt);
-	if (res < 0) {
-		TC_ERROR("Error mounting fs [%d]\n", res);
-		/* FIXME: restructure tests as per #46897 */
-		__ASSERT_NO_MSG(res == 0);
-	}
-
-	return NULL;
-}
-
-void test_unmount(void *unused)
-{
-	int res;
-
-	ARG_UNUSED(unused);
-	res = fs_unmount(&fatfs_mnt);
-	if (res < 0) {
-		TC_ERROR("Error unmounting fs [%d]\n", res);
-		/* FIXME: restructure tests as per #46897 */
-		__ASSERT_NO_MSG(res == 0);
-	}
-}
-
-/**
- * @brief Test for File System mount operation
- *
- * @details Test initializes the fs_mount_t data structure with FatFs
- * related info and calls the fs_mount API for mount the file system.
- */
-ZTEST(posix_fs_test, test_fs_mount)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_equal(fatfs_mnt.flags, FS_MOUNT_FLAG_USE_DISK_ACCESS);
-}
diff --git a/tests/posix/fs/src/test_fs.h b/tests/posix/fs/src/test_fs.h
deleted file mode 100644
index f67a310014a..00000000000
--- a/tests/posix/fs/src/test_fs.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation.
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-#define FATFS_MNTP	"/RAM:"
-#define TEST_ROOT	FATFS_MNTP"/"
-#define TEST_FILE	FATFS_MNTP"/testfile.txt"
-#define TEST_DIR	FATFS_MNTP"/testdir"
-#define TEST_DIR_FILE	FATFS_MNTP"/testdir/testfile.txt"
-
-extern const char test_str[];
-
-void *test_mount(void);
-void test_unmount(void *unused);
diff --git a/tests/posix/fs/src/test_fs_dir.c b/tests/posix/fs/src/test_fs_dir.c
deleted file mode 100644
index 1eeaea9b429..00000000000
--- a/tests/posix/fs/src/test_fs_dir.c
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation.
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <stdio.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <dirent.h>
-#include "test_fs.h"
-
-extern int test_file_write(void);
-extern int test_file_close(void);
-extern int file;
-
-static int test_mkdir(void)
-{
-	int res;
-
-	TC_PRINT("\nmkdir tests:\n");
-
-	/* Verify fs_mkdir() */
-	res = mkdir(TEST_DIR, S_IRWXG);
-	if (res) {
-		TC_PRINT("Error creating dir[%d]\n", res);
-		return res;
-	}
-
-	res = open(TEST_DIR_FILE, O_CREAT | O_RDWR, 0770);
-
-	if (res < 0) {
-		TC_PRINT("Failed opening file [%d]\n", res);
-		return res;
-	}
-	file = res;
-
-	res = test_file_write();
-	if (res) {
-		return res;
-	}
-
-	res = close(file);
-	if (res) {
-		TC_PRINT("Error closing file [%d]\n", res);
-		return res;
-	}
-
-	TC_PRINT("Created dir %s!\n", TEST_DIR);
-
-	return res;
-}
-
-static struct dirent *readdir_wrap(DIR *dirp, bool thread_safe)
-{
-	if (thread_safe) {
-		/* cannot declare on stack otherwise this test fails for qemu_x86/atom */
-		static struct dirent entry;
-		struct dirent *result = NULL;
-
-		zassert_ok(readdir_r(dirp, &entry, &result));
-
-		return result;
-	} else {
-		return readdir(dirp);
-	}
-}
-
-static int test_lsdir(const char *path, bool thread_safe)
-{
-	DIR *dirp;
-	int res = 0;
-	struct dirent *entry;
-
-	TC_PRINT("\nreaddir test:\n");
-
-	/* Verify fs_opendir() */
-	dirp = opendir(path);
-	if (dirp == NULL) {
-		TC_PRINT("Error opening dir %s\n", path);
-		return -EIO;
-	}
-
-	TC_PRINT("\nListing dir %s:\n", path);
-	/* Verify fs_readdir() */
-	errno = 0;
-	while ((entry = readdir_wrap(dirp, thread_safe)) != NULL) {
-		if (entry->d_name[0] == 0) {
-			res = -EIO;
-			break;
-		}
-
-		TC_PRINT("[FILE] %s\n", entry->d_name);
-	}
-
-	if (errno) {
-		res = -EIO;
-	}
-
-	/* Verify fs_closedir() */
-	closedir(dirp);
-
-	return res;
-}
-
-static void after_fn(void *unused)
-{
-	ARG_UNUSED(unused);
-
-	unlink(TEST_DIR_FILE);
-	unlink(TEST_DIR);
-}
-
-/* FIXME: restructure tests as per #46897 */
-ZTEST_SUITE(posix_fs_dir_test, NULL, test_mount, NULL, after_fn,
-	    test_unmount);
-
-/**
- * @brief Test for POSIX mkdir API
- *
- * @details Test creates a new directory through POSIX
- * mkdir API and open a new file under the directory and
- * writes some data into the file.
- */
-ZTEST(posix_fs_dir_test, test_fs_mkdir)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_mkdir() == TC_PASS);
-}
-
-/**
- * @brief Test for POSIX opendir, readdir and closedir API
- *
- * @details Test opens an existing directory through POSIX
- * opendir API, reads the contents of the directory through
- * readdir API and closes it through closedir API.
- */
-ZTEST(posix_fs_dir_test, test_fs_readdir)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_mkdir() == TC_PASS);
-	zassert_true(test_lsdir(TEST_DIR, false) == TC_PASS);
-}
-
-/**
- * Same test as `test_fs_readdir`, but use thread-safe `readdir_r()` function
- */
-ZTEST(posix_fs_dir_test, test_fs_readdir_threadsafe)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_mkdir() == TC_PASS);
-	zassert_true(test_lsdir(TEST_DIR, true) == TC_PASS);
-}
-
-/**
- * @brief Test for POSIX rmdir API
- *
- * @details Test creates a new directory through POSIX
- * mkdir API and remove directory using rmdir.
- */
-ZTEST(posix_fs_dir_test, test_fs_rmdir)
-{
-#define IRWXG	0070
-	/* Create and remove empty directory */
-	zassert_ok(mkdir(TEST_DIR, IRWXG), "Error creating dir: %d", errno);
-	zassert_ok(rmdir(TEST_DIR), "Error removing dir: %d\n", errno);
-
-	/* Create directory and open a file in the directory
-	 * now removing the directory will fail, test will
-	 * fail in removal of non empty directory
-	 */
-	zassert_ok(mkdir(TEST_DIR, IRWXG), "Error creating dir: %d", errno);
-	zassert_not_equal(open(TEST_DIR_FILE, O_CREAT | O_RDWR), -1,
-			  "Error creating file: %d", errno);
-	zassert_not_ok(rmdir(TEST_DIR), "Error Non empty dir removed");
-	zassert_not_ok(rmdir(""), "Error Invalid path removed");
-	zassert_not_ok(rmdir(NULL), "Error Invalid path removed");
-	zassert_not_ok(rmdir("TEST_DIR."), "Error Invalid path removed");
-	zassert_not_ok(rmdir(TEST_FILE), "Error file removed");
-}
diff --git a/tests/posix/fs/src/test_fs_file.c b/tests/posix/fs/src/test_fs_file.c
deleted file mode 100644
index e71eaf8b97c..00000000000
--- a/tests/posix/fs/src/test_fs_file.c
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation.
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <string.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include "test_fs.h"
-
-const char test_str[] = "hello world!";
-int file = -1;
-
-static int test_file_open(void)
-{
-	int res;
-
-	res = open(TEST_FILE, O_CREAT | O_RDWR, 0660);
-	if (res < 0) {
-		TC_ERROR("Failed opening file: %d, errno=%d\n", res, errno);
-		/* FIXME: restructure tests as per #46897 */
-		__ASSERT_NO_MSG(res >= 0);
-	}
-
-	file = res;
-
-	return TC_PASS;
-}
-
-int test_file_write(void)
-{
-	ssize_t brw;
-	off_t res;
-
-	res = lseek(file, 0, SEEK_SET);
-	if (res != 0) {
-		TC_PRINT("lseek failed [%d]\n", (int)res);
-		close(file);
-		file = -1;
-		return TC_FAIL;
-	}
-
-	brw = write(file, (char *)test_str, strlen(test_str));
-	if (brw < 0) {
-		TC_PRINT("Failed writing to file [%d]\n", (int)brw);
-		close(file);
-		file = -1;
-		return TC_FAIL;
-	}
-
-	if (brw < strlen(test_str)) {
-		TC_PRINT("Unable to complete write. Volume full.\n");
-		TC_PRINT("Number of bytes written: [%d]\n", (int)brw);
-		close(file);
-		file = -1;
-		return TC_FAIL;
-	}
-
-	return res;
-}
-
-static int test_file_read(void)
-{
-	ssize_t brw;
-	off_t res;
-	char read_buff[80];
-	size_t sz = strlen(test_str);
-
-	res = lseek(file, 0, SEEK_SET);
-	if (res != 0) {
-		TC_PRINT("lseek failed [%d]\n", (int)res);
-		close(file);
-		file = -1;
-		return TC_FAIL;
-	}
-
-	brw = read(file, read_buff, sz);
-	if (brw < 0) {
-		TC_PRINT("Failed reading file [%d]\n", (int)brw);
-		close(file);
-		file = -1;
-		return TC_FAIL;
-	}
-
-	read_buff[brw] = 0;
-
-	if (strcmp(test_str, read_buff)) {
-		TC_PRINT("Error - Data read does not match data written\n");
-		TC_PRINT("Data read:\"%s\"\n\n", read_buff);
-		return TC_FAIL;
-	}
-
-	/* Now test after non-zero lseek. */
-
-	res = lseek(file, 2, SEEK_SET);
-	if (res != 2) {
-		TC_PRINT("lseek failed [%d]\n", (int)res);
-		close(file);
-		file = -1;
-		return TC_FAIL;
-	}
-
-	brw = read(file, read_buff, sizeof(read_buff));
-	if (brw < 0) {
-		TC_PRINT("Failed reading file [%d]\n", (int)brw);
-		close(file);
-		file = -1;
-		return TC_FAIL;
-	}
-
-	/* Check for array overrun */
-	brw = (brw < 80) ? brw : brw - 1;
-
-	read_buff[brw] = 0;
-
-	if (strcmp(test_str + 2, read_buff)) {
-		TC_PRINT("Error - Data read does not match data written\n");
-		TC_PRINT("Data read:\"%s\"\n\n", read_buff);
-		return TC_FAIL;
-	}
-
-	return TC_PASS;
-}
-
-static int test_file_close(void)
-{
-	int res = 0;
-
-	if (file >= 0) {
-		res = close(file);
-		if (res < 0) {
-			TC_ERROR("Failed closing file: %d, errno=%d\n", res, errno);
-			/* FIXME: restructure tests as per #46897 */
-			__ASSERT_NO_MSG(res == 0);
-		}
-
-		file = -1;
-	}
-
-	return res;
-}
-
-
-static int test_file_truncate(void)
-{
-	int res = 0;
-	size_t truncate_size = sizeof(test_str) - 4;
-
-	if (file < 0) {
-		return res;
-	}
-
-	res = ftruncate(file, truncate_size);
-	if (res) {
-		TC_PRINT("Error truncating file [%d]\n", res);
-		res = TC_FAIL;
-	}
-
-	close(file);
-	file = -1;
-	return res;
-}
-
-static int test_file_delete(void)
-{
-	int res;
-
-	res = unlink(TEST_FILE);
-	if (res) {
-		TC_PRINT("Error deleting file [%d]\n", res);
-		return res;
-	}
-
-	return res;
-}
-
-static void after_fn(void *unused)
-{
-	ARG_UNUSED(unused);
-
-	test_file_close();
-	unlink(TEST_FILE);
-}
-
-ZTEST_SUITE(posix_fs_file_test, NULL, test_mount, NULL, after_fn,
-	    test_unmount);
-
-/**
- * @brief Test for POSIX open API
- *
- * @details Test opens new file through POSIX open API.
- */
-ZTEST(posix_fs_file_test, test_fs_open)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_file_open() == TC_PASS);
-}
-
-/**
- * @brief Test for POSIX write API
- *
- * @details Test writes some data through POSIX write API.
- */
-ZTEST(posix_fs_file_test, test_fs_write)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_file_open() == TC_PASS);
-	zassert_true(test_file_write() == TC_PASS);
-}
-
-/**
- * @brief Test for POSIX write API
- *
- * @details Test reads data back through POSIX read API.
- */
-ZTEST(posix_fs_file_test, test_fs_read)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_file_open() == TC_PASS);
-	zassert_true(test_file_write() == TC_PASS);
-	zassert_true(test_file_read() == TC_PASS);
-}
-
-/**
- * @brief Test for POSIX ftruncate API
- *
- * @details Test truncate the file through POSIX ftruncate API.
- */
-ZTEST(posix_fs_file_test, test_fs_truncate)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_file_open() == TC_PASS);
-	zassert_true(test_file_write() == TC_PASS);
-	zassert_true(test_file_truncate() == TC_PASS);
-}
-
-/**
- * @brief Test for POSIX close API
- *
- * @details Test closes the open file through POSIX close API.
- */
-ZTEST(posix_fs_file_test, test_fs_close)
-{
-	/* FIXME: restructure tests as per #46897 */
-	zassert_true(test_file_open() == TC_PASS);
-	zassert_true(test_file_close() == TC_PASS);
-}
-
-/**
- * @brief Test for POSIX unlink API
- *
- * @details Test deletes a file through POSIX unlink API.
- */
-ZTEST(posix_fs_file_test, test_fs_unlink)
-{
-	zassert_true(test_file_open() == TC_PASS);
-	zassert_true(test_file_delete() == TC_PASS);
-}
-
-ZTEST(posix_fs_file_test, test_fs_fd_leak)
-{
-	const int reps =
-	    MAX(CONFIG_POSIX_OPEN_MAX, ZVFS_OPEN_SIZE) + 5;
-
-	for (int i = 0; i < reps; i++) {
-		if (i > 0) {
-			zassert_true(test_file_open() == TC_PASS);
-		}
-
-		if (i < reps - 1) {
-			zassert_true(test_file_close() == TC_PASS);
-		}
-	}
-}
-
-ZTEST(posix_fs_file_test, test_file_open_truncate)
-{
-	struct stat buf = {0};
-
-	zassert_ok(test_file_open());
-	zassert_ok(test_file_write());
-	zassert_ok(test_file_close());
-	file = open(TEST_FILE, O_RDWR | O_TRUNC);
-	zassert_not_equal(file, -1,
-			  "File open failed for truncate mode");
-
-	zassert_ok(test_file_close());
-	zassert_ok(stat(TEST_FILE, &buf));
-	zassert_equal(buf.st_size, 0, "Error: file is not truncated");
-	zassert_ok(test_file_delete());
-}
diff --git a/tests/posix/fs/src/test_fs_open_flags.c b/tests/posix/fs/src/test_fs_open_flags.c
deleted file mode 100644
index a655affcbda..00000000000
--- a/tests/posix/fs/src/test_fs_open_flags.c
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Copyright (c) 2020 Nordic Semiconductor ASA
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <string.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include "test_fs.h"
-
-#define THE_FILE FATFS_MNTP"/the_file.txt"
-
-static int test_file_open_flags(void)
-{
-	int fd = 0;
-	int data = 0;
-	int ret;
-
-	/* 1 Check opening non-existent without O_CREAT */
-	TC_PRINT("Open of non-existent file, flags = 0\n");
-	fd = open(THE_FILE, 0);
-	if (fd >= 0 || errno != ENOENT) {
-		TC_PRINT("Expected fail; fd = %d, errno = %d\n", fd, errno);
-		if (fd >= 0) {
-			close(fd);
-		}
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Open on non-existent file, flags = O_RDONLY\n");
-	fd = open(THE_FILE, O_RDONLY);
-	if (fd >= 0 || errno != ENOENT) {
-		TC_PRINT("Expected fail; fd = %d, errno = %d\n", fd, errno);
-		if (fd >= 0) {
-			close(fd);
-		}
-		return TC_FAIL;
-	}
-	TC_PRINT("Open on non-existent file, flags = O_WRONLY\n");
-	fd = open(THE_FILE, O_WRONLY);
-	if (fd >= 0 || errno != ENOENT) {
-		TC_PRINT("Expected fail; fd = %d, errno = %d\n", fd, errno);
-		if (fd >= 0) {
-			close(fd);
-		}
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Open on non-existent file, flags = O_RDWR\n");
-	fd = open(THE_FILE, O_RDWR);
-	if (fd >= 0 || errno != ENOENT) {
-		TC_PRINT("Expected fail; fd = %d, errno = %d\n", fd, errno);
-		if (fd >= 0) {
-			close(fd);
-		}
-		return TC_FAIL;
-	}
-	/* end 1 */
-
-	/* 2 Create file for read only, attempt to read, attempt to write */
-	TC_PRINT("Open on non-existent file, flags = O_CREAT | O_WRONLY\n");
-	fd = open(THE_FILE, O_CREAT | O_WRONLY, 0440);
-	if (fd < 0) {
-		TC_PRINT("Expected success; fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt read file opened with flags = O_CREAT | O_WRONLY\n");
-	ret = read(fd, &data, sizeof(data));
-	if (ret > 0 || errno != EACCES) {
-		TC_PRINT("Expected fail, ret = %d, errno = %d\n", ret, errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt write file opened with flags = O_CREAT | O_WRONLY\n");
-	ret = write(fd, &data, sizeof(data));
-	if (ret <= 0 || errno != EACCES) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-	/* end 2 */
-
-
-	/* 3 Attempt read/write operation on file opened with flags = 0 */
-	TC_PRINT("Attempt open existing with flags = 0\n");
-	fd = open(THE_FILE, 0);
-	if (fd < 0) {
-		TC_PRINT("Expected success, fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt read file opened with flags = 0\n");
-	ret = read(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt write file opened with flags = 0\n");
-	ret = write(fd, &data, sizeof(data));
-	if (ret >= 0 || errno != EACCES) {
-		TC_PRINT("Expected fail, ret = %d, errno = %d\n", ret, errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-	/* end 3 */
-
-	/* 4 Attempt read/write on file opened with flags O_RDONLY */
-	/* File does have content after previous tests. */
-	TC_PRINT("Attempt open existing with flags = O_RDONLY\n");
-	fd = open(THE_FILE, O_RDONLY);
-	if (fd < 0) {
-		TC_PRINT("Expected success, fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt read file opened with flags = O_RDONLY\n");
-	ret = read(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt write file opened with flags = O_RDONLY\n");
-	ret = write(fd, &data, sizeof(data));
-	if (ret >= 0 || errno != EACCES) {
-		TC_PRINT("Expected fail, ret = %d, errno = %d\n", ret, errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-	/* end 4 */
-
-	/* 5 Attempt read/write on file opened with flags O_WRONLY */
-	/* File does have content after previous tests. */
-	TC_PRINT("Attempt open existing with flags = O_WRONLY\n");
-	fd = open(THE_FILE, O_WRONLY);
-	if (fd < 0) {
-		TC_PRINT("Expected success, fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt read file opened with flags = O_WRONLY\n");
-	ret = read(fd, &data, sizeof(data));
-	if (ret >= 0 || errno != EACCES) {
-		TC_PRINT("Expected fail, ret = %d, errno = %d\n", ret, errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt write file opened with flags = O_WRONLY\n");
-	ret = write(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-	/* end 5 */
-
-	/* 6 Attempt read/write on file opened with flags O_APPEND | O_WRONLY */
-	TC_PRINT("Attempt open existing with flags = O_APPEND | O_WRONLY\n");
-	fd = open(THE_FILE, O_APPEND | O_WRONLY);
-	if (fd < 0) {
-		TC_PRINT("Expected success, fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt read file opened with flags = O_APPEND | O_WRONLY\n");
-	ret = read(fd, &data, sizeof(data));
-	if (ret >= 0 || errno != EACCES) {
-		TC_PRINT("Expected fail, ret = %d, errno = %d\n", ret, errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt write to opened with flags = O_APPEND | O_WRONLY\n");
-	ret = write(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-	/* end 6 */
-
-	/* 7 Attempt read/write on file opened with flags O_APPEND | O_RDWR */
-	TC_PRINT("Attempt open existing with flags = O_APPEND | O_RDWR\n");
-	fd = open(THE_FILE, O_APPEND | O_RDWR);
-	if (fd < 0) {
-		TC_PRINT("Expected success, fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-
-	TC_PRINT("Attempt read file opened with flags = O_APPEND | O_RDWR\n");
-	lseek(fd, 0, SEEK_SET);
-	ret = read(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	TC_PRINT("Attempt write file opened with flags = O_APPEND | O_RDWR\n");
-	ret = write(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-	/* end 7 */
-
-	/* 8 Check if appended file is always written at the end */
-	TC_PRINT("Attempt write to file opened with O_APPEND | O_RDWR\n");
-	/* Clean start */
-	unlink(THE_FILE);
-	fd = open(THE_FILE, O_CREAT | O_WRONLY, 0440);
-	if (fd < 0) {
-		TC_PRINT("Expected success, fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-	ret = write(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-
-	fd = open(THE_FILE, O_APPEND | O_RDWR);
-	if (fd < 0) {
-		TC_PRINT("Expected success, fd = %d, errno = %d\n", fd, errno);
-		return TC_FAIL;
-	}
-
-	lseek(fd, 0, SEEK_SET);
-	ret = write(fd, &data, sizeof(data));
-	if (ret < 0) {
-		TC_PRINT("Expected success, ret = %d, errno = %d\n", ret,
-			 errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	ret = lseek(fd, 0, SEEK_END);
-
-	if (ret != (sizeof(data) * 2)) {
-		TC_PRINT("Expected file size %zu, ret = %d, errno = %d\n",
-			 sizeof(data) * 2, ret, errno);
-		close(fd);
-		return TC_FAIL;
-	}
-
-	close(fd);
-	/* end 8 */
-
-	return TC_PASS;
-}
-
-/**
- * @brief Test for POSIX open flags
- *
- * @details Test attempts to open file with different combinations of open
- * flags and checks if operations on files are permitted according to flags.
- */
-ZTEST(posix_fs_test, test_fs_open_flags)
-{
-	zassert_true(test_file_open_flags() == TC_PASS);
-}
diff --git a/tests/posix/fs/src/test_fs_stat.c b/tests/posix/fs/src/test_fs_stat.c
deleted file mode 100644
index 4a94bc49832..00000000000
--- a/tests/posix/fs/src/test_fs_stat.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (c) 2023 Nikhef
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <string.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <dirent.h>
-#include "test_fs.h"
-
-#define FILL_SIZE 128
-
-#define TEST_FILE_SIZE     80
-#define TEST_DIR_FILE_SIZE 1000
-
-#define TEST_EMPTY_FILE FATFS_MNTP "/empty.dat"
-
-static void create_file(const char *filename, uint32_t size)
-{
-	int fh;
-
-	fh = open(filename, O_CREAT | O_WRONLY, 0440);
-	zassert(fh >= 0, "Failed creating test file");
-
-	uint8_t filling[FILL_SIZE];
-
-	while (size > FILL_SIZE) {
-		zassert_equal(FILL_SIZE, write(fh, filling, FILL_SIZE));
-		size -= FILL_SIZE;
-	}
-
-	zassert_equal(size, write(fh, filling, size));
-
-	zassert_ok(close(fh));
-}
-
-static void before_fn(void *unused)
-{
-	ARG_UNUSED(unused);
-
-	zassert_ok(mkdir(TEST_DIR, 0070));
-
-	create_file(TEST_FILE, TEST_FILE_SIZE);
-	create_file(TEST_DIR_FILE, TEST_DIR_FILE_SIZE);
-	create_file(TEST_EMPTY_FILE, 0);
-}
-
-static void after_fn(void *unused)
-{
-	ARG_UNUSED(unused);
-
-	zassert_ok(unlink(TEST_FILE));
-	zassert_ok(unlink(TEST_DIR_FILE));
-	zassert_ok(unlink(TEST_DIR));
-}
-
-ZTEST_SUITE(posix_fs_stat_test, NULL, test_mount, before_fn, after_fn, test_unmount);
-
-/**
- * @brief Test stat command on file
- *
- * @details Tests file in root, file in directroy, non-existing file and empty file.
- */
-ZTEST(posix_fs_stat_test, test_fs_stat_file)
-{
-	struct stat buf;
-
-	zassert_equal(0, stat(TEST_FILE, &buf));
-	zassert_equal(TEST_FILE_SIZE, buf.st_size);
-	zassert_equal(S_IFREG, buf.st_mode);
-
-	zassert_equal(0, stat(TEST_DIR_FILE, &buf));
-	zassert_equal(TEST_DIR_FILE_SIZE, buf.st_size);
-	zassert_equal(S_IFREG, buf.st_mode);
-
-	zassert_not_equal(0, stat(TEST_ROOT "foo.txt", &buf));
-	zassert_not_equal(0, stat("", &buf));
-
-	zassert_equal(0, stat(TEST_EMPTY_FILE, &buf));
-
-	zassert_equal(0, buf.st_size);
-	zassert_equal(S_IFREG, buf.st_mode);
-}
-
-/**
- * @brief Test stat command on dir
- *
- * @details Tests if we can retrieve stastics for a directory. This should only provide S_IFDIR
- *          return value.
- */
-ZTEST(posix_fs_stat_test, test_fs_stat_dir)
-{
-	struct stat buf;
-
-	zassert_equal(0, stat(TEST_DIR, &buf));
-
-	zassert_equal(0, buf.st_size);
-	zassert_equal(S_IFDIR, buf.st_mode);
-
-	/* note: for posix compatibility should should actually work */
-	zassert_not_equal(0, stat(TEST_ROOT, &buf));
-}
-
-/**
- * @brief Test fstat command on file
- *
- * @details Tests file in root, file in directroy, and empty file
- */
-ZTEST(posix_fs_stat_test, test_fs_fstat_file)
-{
-	struct stat buf;
-
-	int test_file_fd = open(TEST_FILE, O_RDONLY);
-	int dir_file_fd = open(TEST_DIR_FILE, O_RDONLY);
-	int empty_file_fd = open(TEST_EMPTY_FILE, O_RDONLY);
-
-	zassert_not_equal(-1, test_file_fd);
-	zassert_equal(0, fstat(test_file_fd, &buf));
-	zassert_equal(TEST_FILE_SIZE, buf.st_size);
-	zassert_equal(S_IFREG, buf.st_mode);
-	close(test_file_fd);
-
-	zassert_not_equal(-1, dir_file_fd);
-	zassert_equal(0, fstat(dir_file_fd, &buf));
-	zassert_equal(TEST_DIR_FILE_SIZE, buf.st_size);
-	zassert_equal(S_IFREG, buf.st_mode);
-	close(dir_file_fd);
-
-	zassert_not_equal(-1, empty_file_fd);
-	zassert_equal(0, fstat(empty_file_fd, &buf));
-	zassert_equal(0, buf.st_size);
-	zassert_equal(S_IFREG, buf.st_mode);
-	close(empty_file_fd);
-}
-
-/**
- * @brief Test fstat command on dir
- *
- * @details Tests if we can retrieve stastics for a directory.
- */
-ZTEST(posix_fs_stat_test, test_fs_fstat_dir)
-{
-	struct stat buf;
-
-	int fd = open(TEST_DIR, O_RDONLY);
-
-	/*
-	 * if this failed it means open doesn't support directories
-	 * so skip the rest of the test
-	 */
-	if (fd == -1) {
-		ztest_test_skip();
-	}
-
-	zassert_equal(0, fstat(fd, &buf));
-	zassert_equal(0, buf.st_size);
-	zassert_equal(S_IFDIR, buf.st_mode);
-	close(fd);
-}
diff --git a/tests/posix/fs/testcase.yaml b/tests/posix/fs/testcase.yaml
deleted file mode 100644
index f5fb98269b9..00000000000
--- a/tests/posix/fs/testcase.yaml
+++ /dev/null
@@ -1,46 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - filesystem
-    - fatfs
-  min_ram: 128
-  modules:
-    - fatfs
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_x86
-    - qemu_riscv64
-tests:
-  portability.posix.fs: {}
-  portability.posix.fs.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.fs.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.fs.tls:
-    filter: CONFIG_ARCH_HAS_THREAD_LOCAL_STORAGE and CONFIG_TOOLCHAIN_SUPPORTS_THREAD_LOCAL_STORAGE
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=n
-      - CONFIG_THREAD_LOCAL_STORAGE=y
-  portability.posix.fs.tls.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1 and CONFIG_ARCH_HAS_THREAD_LOCAL_STORAGE and
-      CONFIG_TOOLCHAIN_SUPPORTS_THREAD_LOCAL_STORAGE
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-      - CONFIG_THREAD_LOCAL_STORAGE=y
-  portability.posix.fs.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
-  portability.posix.fs.tls.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/headers/CMakeLists.txt b/tests/posix/headers/CMakeLists.txt
deleted file mode 100644
index f34002d6cec..00000000000
--- a/tests/posix/headers/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_headers)
-
-FILE(GLOB app_sources src/*.c)
-target_sources(app PRIVATE ${app_sources})
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/headers/boards/mimxrt1015_evk.overlay b/tests/posix/headers/boards/mimxrt1015_evk.overlay
deleted file mode 100644
index 9b54fd40dfa..00000000000
--- a/tests/posix/headers/boards/mimxrt1015_evk.overlay
+++ /dev/null
@@ -1,11 +0,0 @@
-/*
- * Copyright 2023 NXP
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-/ {
-	chosen {
-		zephyr,sram = &ocram;
-	};
-};
diff --git a/tests/posix/headers/prj.conf b/tests/posix/headers/prj.conf
deleted file mode 100644
index 6dc0857d177..00000000000
--- a/tests/posix/headers/prj.conf
+++ /dev/null
@@ -1,26 +0,0 @@
-CONFIG_ZTEST=y
-
-# for POSIX_FILESYSTEM
-CONFIG_POSIX_FILE_SYSTEM=y
-
-# for networking things to work
-CONFIG_NETWORKING=y
-CONFIG_POSIX_NETWORKING=y
-CONFIG_NET_TEST=y
-CONFIG_TEST_RANDOM_GENERATOR=y
-
-# For e.g. sched_get_priority_max()
-CONFIG_POSIX_PRIORITY_SCHEDULING=y
-
-# For putmsg(), etc
-CONFIG_POSIX_SYSTEM_INTERFACES=y
-CONFIG_XSI=y
-CONFIG_XSI_STREAMS=y
-
-# for when CONFIG_POSIX_AEP_CHOICE_PSE53 is not selected
-CONFIG_POSIX_THREADS=y
-CONFIG_POSIX_TIMERS=y
-CONFIG_POSIX_MESSAGE_PASSING=y
-CONFIG_EVENTFD=y
-CONFIG_POSIX_C_LIB_EXT=y
-CONFIG_POSIX_DEVICE_IO=y
diff --git a/tests/posix/headers/src/_common.h b/tests/posix/headers/src/_common.h
deleted file mode 100644
index 47325c05473..00000000000
--- a/tests/posix/headers/src/_common.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#pragma once
-
-#include <limits.h>
-#include <stddef.h>
-#include <stdint.h>
-
-#include <zephyr/ztest.h>
diff --git a/tests/posix/headers/src/_main.c b/tests/posix/headers/src/_main.c
deleted file mode 100644
index 87e634f9b8e..00000000000
--- a/tests/posix/headers/src/_main.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-ZTEST_SUITE(posix_headers, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/headers/src/aio_h.c b/tests/posix/headers/src/aio_h.c
deleted file mode 100644
index 45a15ca38bd..00000000000
--- a/tests/posix/headers/src/aio_h.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2024 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <aio.h>
-
-ZTEST(posix_headers, test_aio_h)
-{
-#ifdef CONFIG_POSIX_ASYNCHRONOUS_IO
-	zassert_not_equal(offsetof(struct aiocb, aio_fildes), -1);
-	zassert_not_equal(offsetof(struct aiocb, aio_offset), -1);
-	zassert_not_equal(offsetof(struct aiocb, aio_buf), -1);
-	zassert_not_equal(offsetof(struct aiocb, aio_nbytes), -1);
-	zassert_not_equal(offsetof(struct aiocb, aio_reqprio), -1);
-#ifdef CONFIG_POSIX_REALTIME_SIGNALS
-	zassert_not_equal(offsetof(struct aiocb, aio_sigevent), -1);
-#endif
-	zassert_not_equal(offsetof(struct aiocb, aio_lio_opcode), -1);
-
-	zassert_not_null(aio_cancel);
-	zassert_not_null(aio_error);
-	zassert_not_null(aio_fsync);
-	zassert_not_null(aio_read);
-	zassert_not_null(aio_return);
-	zassert_not_null(aio_suspend);
-	zassert_not_null(aio_write);
-	zassert_not_null(lio_listio);
-#endif
-}
diff --git a/tests/posix/headers/src/arpa_inet_h.c b/tests/posix/headers/src/arpa_inet_h.c
deleted file mode 100644
index 2426e46bdab..00000000000
--- a/tests/posix/headers/src/arpa_inet_h.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <arpa/inet.h>
-
-/**
- * @brief existence test for `<arpa/inet.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/arpa_inet.h.html">arpa/inet.h</a>
- */
-ZTEST(posix_headers, test_arpa_inet_h)
-{
-	zassert_not_equal(-1, htonl(0));
-	zassert_not_equal(-1, htons(0));
-	zassert_not_equal(-1, ntohl(0));
-	zassert_not_equal(-1, ntohs(0));
-
-	if (IS_ENABLED(CONFIG_POSIX_NETWORKING)) {
-		/* zassert_not_null(inet_addr); */ /* not implemented */
-		/* zassert_not_null(inet_ntoa); */ /* not implemented */
-		zassert_not_null(inet_ntop);
-		zassert_not_null(inet_pton);
-	}
-}
diff --git a/tests/posix/headers/src/dirent_h.c b/tests/posix/headers/src/dirent_h.c
deleted file mode 100644
index 6e2d83c7a41..00000000000
--- a/tests/posix/headers/src/dirent_h.c
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <dirent.h>
-
-/**
- * @brief existence test for `<dirent.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/dirent.h.html">dirent.h</a>
- */
-ZTEST(posix_headers, test_dirent_h)
-{
-#ifdef CONFIG_POSIX_AEP_CHOICE_PSE53
-	zassert_not_equal((DIR *)-1, (DIR *)NULL);
-
-	zassert_not_equal(-1, offsetof(struct dirent, d_ino));
-	zassert_not_equal(-1, offsetof(struct dirent, d_name));
-
-	/* zassert_not_null(alphasort); */ /* not implemented */
-	zassert_not_null(closedir);
-	/* zassert_not_null(dirfd); */     /* not implemented */
-	/* zassert_not_null(fdopendir); */ /* not implemented */
-	zassert_not_null(opendir);
-	zassert_not_null(readdir);
-	zassert_not_null(readdir_r);
-	/* zassert_not_null(rewinddir); */ /* not implemented */
-	/* zassert_not_null(scandir); */   /* not implemented */
-	/* zassert_not_null(seekdir); */   /* not implemented */
-	/* zassert_not_null(telldir); */   /* not implemented */
-#endif
-}
diff --git a/tests/posix/headers/src/mqueue_h.c b/tests/posix/headers/src/mqueue_h.c
deleted file mode 100644
index abdf8c79e98..00000000000
--- a/tests/posix/headers/src/mqueue_h.c
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <mqueue.h>
-
-/**
- * @brief existence test for `<mqueue.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/mqueue.h.html">mqueue.h</a>
- */
-ZTEST(posix_headers, test_mqueue_h)
-{
-	zassert_not_equal((mqd_t)-1, (mqd_t)NULL);
-
-	zassert_not_equal(-1, offsetof(struct mq_attr, mq_flags));
-	zassert_not_equal(-1, offsetof(struct mq_attr, mq_maxmsg));
-	zassert_not_equal(-1, offsetof(struct mq_attr, mq_msgsize));
-	zassert_not_equal(-1, offsetof(struct mq_attr, mq_curmsgs));
-
-	if (IS_ENABLED(CONFIG_POSIX_AEP_CHOICE_PSE53)) {
-		zassert_not_null(mq_close);
-		zassert_not_null(mq_getattr);
-		zassert_not_null(mq_notify);
-		zassert_not_null(mq_open);
-		zassert_not_null(mq_receive);
-		zassert_not_null(mq_send);
-		zassert_not_null(mq_setattr);
-		zassert_not_null(mq_timedreceive);
-		zassert_not_null(mq_timedsend);
-		zassert_not_null(mq_unlink);
-	}
-}
diff --git a/tests/posix/headers/src/net_if_h.c b/tests/posix/headers/src/net_if_h.c
deleted file mode 100644
index 3ebba2333d7..00000000000
--- a/tests/posix/headers/src/net_if_h.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <net/if.h>
-
-/**
- * @brief existence test for `<net/if.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/net_if.h.html">net/if.h</a>
- */
-ZTEST(posix_headers, test_net_if_h)
-{
-	zassert_not_equal(-1, offsetof(struct if_nameindex, if_index));
-	zassert_not_equal(-1, offsetof(struct if_nameindex, if_name));
-
-	zassert_not_equal(-1, IF_NAMESIZE);
-
-	if (IS_ENABLED(CONFIG_POSIX_NETWORKING)) {
-		zassert_not_null(if_freenameindex);
-		zassert_not_null(if_indextoname);
-		zassert_not_null(if_nameindex);
-		zassert_not_null(if_nametoindex);
-	}
-}
diff --git a/tests/posix/headers/src/netdb_h.c b/tests/posix/headers/src/netdb_h.c
deleted file mode 100644
index 1c5eb6ffea7..00000000000
--- a/tests/posix/headers/src/netdb_h.c
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <netdb.h>
-
-/**
- * @brief existence test for `<netdb.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netdb.h.html>netdb.h</a>
- */
-ZTEST(posix_headers, test_netdb_h)
-{
-	zassert_not_equal(-1, offsetof(struct hostent, h_name));
-	zassert_not_equal(-1, offsetof(struct hostent, h_aliases));
-	zassert_not_equal(-1, offsetof(struct hostent, h_addrtype));
-	zassert_not_equal(-1, offsetof(struct hostent, h_length));
-	zassert_not_equal(-1, offsetof(struct hostent, h_addr_list));
-
-	zassert_not_equal(-1, offsetof(struct netent, n_name));
-	zassert_not_equal(-1, offsetof(struct netent, n_aliases));
-	zassert_not_equal(-1, offsetof(struct netent, n_addrtype));
-	zassert_not_equal(-1, offsetof(struct netent, n_net));
-
-	zassert_not_equal(-1, offsetof(struct protoent, p_name));
-	zassert_not_equal(-1, offsetof(struct protoent, p_aliases));
-	zassert_not_equal(-1, offsetof(struct protoent, p_proto));
-
-	zassert_not_equal(-1, offsetof(struct servent, s_name));
-	zassert_not_equal(-1, offsetof(struct servent, s_aliases));
-	zassert_not_equal(-1, offsetof(struct servent, s_port));
-	zassert_not_equal(-1, offsetof(struct servent, s_proto));
-
-	/* zassert_equal(IPPORT_RESERVED, UINT16_MAX); */ /* not implemented */
-
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_flags));
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_family));
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_socktype));
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_protocol));
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_addrlen));
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_addr));
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_canonname));
-	zassert_not_equal(-1, offsetof(struct addrinfo, ai_next));
-
-	zassert_not_equal(-1, AI_PASSIVE);
-	zassert_not_equal(-1, AI_CANONNAME);
-	zassert_not_equal(-1, AI_NUMERICHOST);
-	zassert_not_equal(-1, AI_NUMERICSERV);
-	zassert_not_equal(-1, AI_V4MAPPED);
-	zassert_not_equal(-1, AI_ALL);
-	zassert_not_equal(-1, AI_ADDRCONFIG);
-
-	zassert_not_equal(-1, NI_NOFQDN);
-	zassert_not_equal(-1, NI_NUMERICHOST);
-	zassert_not_equal(-1, NI_NAMEREQD);
-	zassert_not_equal(-1, NI_NUMERICSERV);
-	/* zassert_not_equal(-1, NI_NUMERICSCOPE); */ /* not implemented */
-	zassert_not_equal(-1, NI_DGRAM);
-
-	zassert_not_equal(-1, EAI_AGAIN);
-	zassert_equal(-1, EAI_BADFLAGS);
-	zassert_not_equal(-1, EAI_FAIL);
-	zassert_not_equal(-1, EAI_FAMILY);
-	zassert_not_equal(-1, EAI_MEMORY);
-	zassert_not_equal(-1, EAI_NONAME);
-	zassert_not_equal(-1, EAI_SERVICE);
-	zassert_not_equal(-1, EAI_SOCKTYPE);
-	zassert_not_equal(-1, EAI_SYSTEM);
-	zassert_not_equal(-1, EAI_OVERFLOW);
-
-	if (IS_ENABLED(CONFIG_POSIX_NETWORKING)) {
-		zassert_not_null(endhostent);
-		zassert_not_null(endnetent);
-		zassert_not_null(endprotoent);
-		zassert_not_null(endservent);
-		zassert_not_null(freeaddrinfo);
-		zassert_not_null(gai_strerror);
-		zassert_not_null(getaddrinfo);
-		zassert_not_null(gethostent);
-		zassert_not_null(getnameinfo);
-		zassert_not_null(getnetbyaddr);
-		zassert_not_null(getnetbyname);
-		zassert_not_null(getnetent);
-		zassert_not_null(getprotobyname);
-		zassert_not_null(getprotobynumber);
-		zassert_not_null(getprotoent);
-		zassert_not_null(getservbyname);
-		zassert_not_null(getservbyport);
-		zassert_not_null(getservent);
-		zassert_not_null(sethostent);
-		zassert_not_null(setnetent);
-		zassert_not_null(setprotoent);
-		zassert_not_null(setservent);
-	}
-}
diff --git a/tests/posix/headers/src/netinet_in_h.c b/tests/posix/headers/src/netinet_in_h.c
deleted file mode 100644
index ae89b9b399d..00000000000
--- a/tests/posix/headers/src/netinet_in_h.c
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <netinet/in.h>
-
-/**
- * @brief existence test for `<netinet/in.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_in.h.html">netinet/in.h</a>
- */
-ZTEST(posix_headers, test_netinet_in_h)
-{
-	zexpect_equal(sizeof(in_port_t), sizeof(uint16_t));
-	zexpect_equal(sizeof(in_addr_t), sizeof(uint32_t));
-
-	zexpect_not_equal(-1, offsetof(struct in_addr, s_addr));
-
-	zexpect_not_equal(-1, offsetof(struct sockaddr_in, sin_family));
-	zexpect_not_equal(-1, offsetof(struct sockaddr_in, sin_port));
-	zexpect_not_equal(-1, offsetof(struct sockaddr_in, sin_addr));
-
-	zexpect_not_equal(-1, offsetof(struct in6_addr, s6_addr));
-	zexpect_equal(sizeof(((struct in6_addr *)NULL)->s6_addr), 16 * sizeof(uint8_t));
-
-	zexpect_not_equal(-1, offsetof(struct sockaddr_in6, sin6_family));
-	zexpect_not_equal(-1, offsetof(struct sockaddr_in6, sin6_port));
-	/* not implemented */
-	/* zexpect_not_equal(-1, offsetof(struct sockaddr_in6, sin6_flowinfo)); */
-	zexpect_not_equal(-1, offsetof(struct sockaddr_in6, sin6_addr));
-	zexpect_not_equal(-1, offsetof(struct sockaddr_in6, sin6_scope_id));
-
-	zexpect_not_null(&in6addr_any);
-	zexpect_not_null(&in6addr_loopback);
-	struct in6_addr any6 = IN6ADDR_ANY_INIT;
-	struct in6_addr lo6 = IN6ADDR_LOOPBACK_INIT;
-
-	struct in6_addr mcast6 = { { { 0xff, 0 } } };
-	struct in6_addr ll6 = { { { 0xfe, 0x80, 0x01, 0x02,
-				0, 0, 0, 0, 0, 0x01 } } };
-	struct in6_addr sl6  = { { { 0xfe, 0xc0, 0, 0x01, 0x02 } } };
-	struct in6_addr v4mapped = { { { 0, 0, 0, 0, 0, 0, 0, 0,
-				0xff, 0xff, 0xff, 0xff, 0xc0, 0, 0x02, 0x01 } } };
-	struct in6_addr mcnl6 = { { { 0xff, 0x01, 0, 0, 0, 0, 0, 0,
-				0, 0, 0, 0, 0, 0, 0, 0x01 } } };
-	struct in6_addr mcll6 = { { { 0xff, 0x02, 0, 0, 0, 0, 0, 0,
-				0, 0, 0, 0, 0, 0, 0, 0x01 } } };
-	struct in6_addr mcsl6 = { { { 0xff, 0x05, 0, 0, 0, 0, 0, 0,
-				0, 0, 0, 0, 0, 0, 0, 0x01 } } };
-	struct in6_addr mcol6 = { { { 0xff, 0x08, 0, 0, 0, 0, 0, 0,
-				0, 0, 0, 0, 0, 0, 0, 0x01 } } };
-	struct in6_addr mcg6 = { { { 0xff, 0x0e, 0, 0, 0, 0, 0, 0,
-				0, 0, 0, 0, 0, 0, 0, 0x01 } } };
-
-	zexpect_not_equal(-1, offsetof(struct ipv6_mreq, ipv6mr_multiaddr));
-	zexpect_not_equal(-1, offsetof(struct ipv6_mreq, ipv6mr_ifindex));
-
-	zexpect_not_equal(-1, IPPROTO_IP);
-	zexpect_not_equal(-1, IPPROTO_IPV6);
-	zexpect_not_equal(-1, IPPROTO_ICMP);
-	zexpect_not_equal(-1, IPPROTO_RAW);
-	zexpect_not_equal(-1, IPPROTO_TCP);
-	zexpect_not_equal(-1, IPPROTO_UDP);
-
-	zexpect_not_equal(-1, INADDR_ANY);
-	zexpect_equal(0xffffffff, INADDR_BROADCAST);
-
-	zexpect_equal(INET_ADDRSTRLEN, 16);
-	zexpect_equal(INET6_ADDRSTRLEN, 46);
-
-	zexpect_equal(IPV6_ADD_MEMBERSHIP, IPV6_JOIN_GROUP);
-	zexpect_equal(IPV6_DROP_MEMBERSHIP, IPV6_LEAVE_GROUP);
-	zexpect_not_equal(-1, IPV6_MULTICAST_HOPS);
-	/* zexpect_not_equal(-1, IPV6_MULTICAST_IF); */ /* not implemented */
-	/* zexpect_not_equal(-1, IPV6_MULTICAST_LOOP); */ /* not implemented */
-	zexpect_not_equal(-1, IPV6_UNICAST_HOPS);
-	zexpect_not_equal(-1, IPV6_V6ONLY);
-
-	zexpect_true(IN6_IS_ADDR_UNSPECIFIED(&any6));
-	zexpect_true(IN6_IS_ADDR_LOOPBACK(&lo6));
-
-	zexpect_true(IN6_IS_ADDR_MULTICAST(&mcast6));
-	zexpect_true(IN6_IS_ADDR_LINKLOCAL(&ll6));
-	zexpect_true(IN6_IS_ADDR_SITELOCAL(&sl6));
-	zexpect_true(IN6_IS_ADDR_V4MAPPED(&v4mapped));
-	/* IN6_IS_ADDR_V4COMPAT(&lo6); */ /* not implemented */
-	zexpect_true(IN6_IS_ADDR_MC_NODELOCAL(&mcnl6));
-	zexpect_true(IN6_IS_ADDR_MC_LINKLOCAL(&mcll6));
-	zexpect_true(IN6_IS_ADDR_MC_SITELOCAL(&mcsl6));
-	zexpect_true(IN6_IS_ADDR_MC_ORGLOCAL(&mcol6));
-	zexpect_true(IN6_IS_ADDR_MC_GLOBAL(&mcg6));
-}
diff --git a/tests/posix/headers/src/netinet_tcp_h.c b/tests/posix/headers/src/netinet_tcp_h.c
deleted file mode 100644
index 57deaf5eccd..00000000000
--- a/tests/posix/headers/src/netinet_tcp_h.c
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <netinet/tcp.h>
-
-/**
- * @brief existence test for `<netinet/tcp.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_tcp.h.html">netinet/tcp.h</a>
- */
-ZTEST(posix_headers, test_netinet_tcp_h)
-{
-	zassert_not_equal(-1, TCP_NODELAY);
-}
diff --git a/tests/posix/headers/src/poll_h.c b/tests/posix/headers/src/poll_h.c
deleted file mode 100644
index 28ddfc1acd8..00000000000
--- a/tests/posix/headers/src/poll_h.c
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <poll.h>
-
-/**
- * @brief existence test for `<poll.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/poll.h.html">poll.h</a>
- */
-ZTEST(posix_headers, test_poll_h)
-{
-	zassert_not_equal(-1, offsetof(struct pollfd, fd));
-	zassert_not_equal(-1, offsetof(struct pollfd, events));
-	zassert_not_equal(-1, offsetof(struct pollfd, revents));
-
-	zassert_true(sizeof(nfds_t) <= sizeof(long));
-
-	zassert_not_equal(-1, POLLIN);
-	/* zassert_not_equal(-1, POLLRDNORM); */ /* not implemented */
-	/* zassert_not_equal(-1, POLLRDBAND); */ /* not implemented */
-	zassert_not_equal(-1, POLLPRI);
-	zassert_not_equal(-1, POLLOUT);
-	/* zassert_not_equal(-1, POLLWRNORM); */ /* not implemented */
-	/* zassert_not_equal(-1, POLLWRBAND); */ /* not implemented */
-	zassert_not_equal(-1, POLLERR);
-	zassert_not_equal(-1, POLLHUP);
-	zassert_not_equal(-1, POLLNVAL);
-
-	if (IS_ENABLED(CONFIG_POSIX_DEVICE_IO)) {
-		zassert_not_null(poll);
-	}
-}
diff --git a/tests/posix/headers/src/pthread_h.c b/tests/posix/headers/src/pthread_h.c
deleted file mode 100644
index b9c8a3771da..00000000000
--- a/tests/posix/headers/src/pthread_h.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <pthread.h>
-
-/**
- * @brief existence test for `<pthread.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html">pthread.h</a>
- */
-ZTEST(posix_headers, test_pthread_h)
-{
-#ifdef CONFIG_POSIX_AEP_CHOICE_PSE53
-	zassert_not_equal(-42, PTHREAD_BARRIER_SERIAL_THREAD);
-
-	zassert_not_equal(-1, PTHREAD_CANCEL_ASYNCHRONOUS);
-	zassert_not_equal(-1, PTHREAD_CANCEL_DEFERRED);
-
-	zassert_not_equal(-1, PTHREAD_CANCEL_ENABLE);
-	zassert_not_equal(-1, PTHREAD_CANCEL_DISABLE);
-
-	zassert_not_equal((void *)-42, PTHREAD_CANCELED);
-
-	zassert_not_equal(-1, PTHREAD_CREATE_DETACHED);
-	zassert_not_equal(-1, PTHREAD_CREATE_JOINABLE);
-
-	zassert_not_equal(-1, PTHREAD_EXPLICIT_SCHED);
-	zassert_not_equal(-1, PTHREAD_INHERIT_SCHED);
-
-	zassert_not_equal(-1, PTHREAD_MUTEX_DEFAULT);
-	zassert_not_equal(-1, PTHREAD_MUTEX_ERRORCHECK);
-	zassert_not_equal(-1, PTHREAD_MUTEX_ERRORCHECK);
-	zassert_not_equal(-1, PTHREAD_MUTEX_RECURSIVE);
-	/* zassert_not_equal(-1, PTHREAD_MUTEX_ROBUST); */  /* not implemented */
-	/* zassert_not_equal(-1, PTHREAD_MUTEX_STALLED); */ /* not implemented */
-
-	__unused pthread_once_t once = PTHREAD_ONCE_INIT;
-
-	/* zassert_not_equal(-1, PTHREAD_PRIO_INHERIT); */ /* not implemented */
-	zassert_not_equal(-1, PTHREAD_PRIO_NONE);
-	/* zassert_not_equal(-1, PTHREAD_PRIO_PROTECT); */ /* not implemented */
-
-	zassert_not_equal(-1, PTHREAD_PROCESS_SHARED);
-	zassert_not_equal(-1, PTHREAD_PROCESS_PRIVATE);
-
-	zassert_not_equal(-1, PTHREAD_SCOPE_PROCESS);
-	zassert_not_equal(-1, PTHREAD_SCOPE_SYSTEM);
-
-	__unused pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
-	__unused pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;
-	/* pthread_rwlock_t lock = POSIX_READER_WRITER_LOCKS_INITIALIZER; */ /* not implemented */
-
-	zassert_not_null(pthread_atfork);
-	zassert_not_null(pthread_attr_destroy);
-	zassert_not_null(pthread_attr_getdetachstate);
-	zassert_not_null(pthread_attr_getguardsize);
-	zassert_not_null(pthread_attr_getinheritsched);
-	zassert_not_null(pthread_attr_getschedparam);
-	zassert_not_null(pthread_attr_getschedpolicy);
-	zassert_not_null(pthread_attr_getscope);
-	zassert_not_null(pthread_attr_getstack);
-	zassert_not_null(pthread_attr_getstacksize);
-	zassert_not_null(pthread_attr_init);
-	zassert_not_null(pthread_attr_setdetachstate);
-	zassert_not_null(pthread_attr_setguardsize);
-	zassert_not_null(pthread_attr_setinheritsched);
-	zassert_not_null(pthread_attr_setschedparam);
-	zassert_not_null(pthread_attr_setschedpolicy);
-	zassert_not_null(pthread_attr_setscope);
-	zassert_not_null(pthread_attr_setstack);
-	zassert_not_null(pthread_attr_setstacksize);
-	zassert_not_null(pthread_barrier_destroy);
-	zassert_not_null(pthread_barrier_init);
-	zassert_not_null(pthread_barrier_wait);
-	zassert_not_null(pthread_barrierattr_destroy);
-	/* zassert_not_null(pthread_barrierattr_getpshared); */ /* not implemented */
-	zassert_not_null(pthread_barrierattr_init);
-	/* zassert_not_null(pthread_barrierattr_setpshared); */ /* not implemented */
-	zassert_not_null(pthread_cancel);
-	zassert_not_null(pthread_cond_broadcast);
-	zassert_not_null(pthread_cond_destroy);
-	zassert_not_null(pthread_cond_init);
-	zassert_not_null(pthread_cond_signal);
-	zassert_not_null(pthread_cond_timedwait);
-	zassert_not_null(pthread_cond_wait);
-	zassert_not_null(pthread_condattr_destroy);
-	zassert_not_null(pthread_condattr_getclock);
-	/* zassert_not_null(pthread_condattr_getpshared); */ /* not implemented */
-	zassert_not_null(pthread_condattr_init);
-	zassert_not_null(pthread_condattr_setclock);
-	/* zassert_not_null(pthread_condattr_setpshared); */ /* not implemented */
-	zassert_not_null(pthread_create);
-	zassert_not_null(pthread_detach);
-	zassert_not_null(pthread_equal);
-	zassert_not_null(pthread_exit);
-	zassert_not_null(pthread_getconcurrency);
-	/* zassert_not_null(pthread_getcpuclockid); */ /* not implemented */
-	zassert_not_null(pthread_getschedparam);
-	zassert_not_null(pthread_getspecific);
-	zassert_not_null(pthread_join);
-	zassert_not_null(pthread_key_create);
-	zassert_not_null(pthread_key_delete);
-	/* zassert_not_null(pthread_mutex_consistent); */ /* not implemented */
-	zassert_not_null(pthread_mutex_destroy);
-	zassert_not_null(pthread_mutex_getprioceiling);
-	zassert_not_null(pthread_mutex_init);
-	zassert_not_null(pthread_mutex_lock);
-	zassert_not_null(pthread_mutex_setprioceiling);
-	zassert_not_null(pthread_mutex_timedlock);
-	zassert_not_null(pthread_mutex_trylock);
-	zassert_not_null(pthread_mutex_unlock);
-	zassert_not_null(pthread_mutexattr_destroy);
-	zassert_not_null(pthread_mutexattr_getprioceiling);
-	zassert_not_null(pthread_mutexattr_getprotocol);
-	/* zassert_not_null(pthread_mutexattr_getpshared); */ /* not implemented */
-	/* zassert_not_null(pthread_mutexattr_getrobust); */  /* not implemented */
-	zassert_not_null(pthread_mutexattr_gettype);
-	zassert_not_null(pthread_mutexattr_init);
-	zassert_not_null(pthread_mutexattr_setprioceiling);
-	zassert_not_null(pthread_mutexattr_setprotocol);
-	/* zassert_not_null(pthread_mutexattr_setpshared); */     /* not implemented */
-	/* zassert_not_null(pthread_mutexattr_setrobust); */      /* not implemented */
-	zassert_not_null(pthread_mutexattr_settype);
-	zassert_not_null(pthread_once);
-	zassert_not_null(pthread_rwlock_destroy);
-	zassert_not_null(pthread_rwlock_init);
-	zassert_not_null(pthread_rwlock_rdlock);
-	zassert_not_null(pthread_rwlock_timedrdlock);
-	zassert_not_null(pthread_rwlock_timedwrlock);
-	zassert_not_null(pthread_rwlock_tryrdlock);
-	zassert_not_null(pthread_rwlock_trywrlock);
-	zassert_not_null(pthread_rwlock_unlock);
-	zassert_not_null(pthread_rwlock_wrlock);
-	zassert_not_null(pthread_rwlockattr_destroy);
-	zassert_not_null(pthread_rwlockattr_getpshared);
-	zassert_not_null(pthread_rwlockattr_init);
-	zassert_not_null(pthread_rwlockattr_setpshared);
-	zassert_not_null(pthread_self);
-	zassert_not_null(pthread_setcancelstate);
-	zassert_not_null(pthread_setcanceltype);
-	zassert_not_null(pthread_setconcurrency);
-	zassert_not_null(pthread_setschedparam);
-	zassert_not_null(pthread_setschedprio);
-	zassert_not_null(pthread_setspecific);
-	zassert_not_null(pthread_spin_destroy);
-	zassert_not_null(pthread_spin_init);
-	zassert_not_null(pthread_spin_lock);
-	zassert_not_null(pthread_spin_trylock);
-	zassert_not_null(pthread_spin_unlock);
-	zassert_not_null(pthread_testcancel);
-#endif
-}
diff --git a/tests/posix/headers/src/sched_h.c b/tests/posix/headers/src/sched_h.c
deleted file mode 100644
index 76133d83d48..00000000000
--- a/tests/posix/headers/src/sched_h.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <sched.h>
-
-/**
- * @brief existence test for `<sched.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sched.h.html">sched.h</a>
- */
-ZTEST(posix_headers, test_sched_h)
-{
-	zassert_not_equal(-1, offsetof(struct sched_param, sched_priority));
-
-	zassert_not_equal(-1, SCHED_FIFO);
-	zassert_not_equal(-1, SCHED_RR);
-	/* zassert_not_equal(-1, SCHED_SPORADIC); */ /* not implemented */
-	/* zassert_not_equal(-1, SCHED_OTHER); */ /* not implemented */
-
-#ifdef CONFIG_POSIX_PRIORITY_SCHEDULING
-	zassert_not_null(sched_get_priority_max);
-	zassert_not_null(sched_get_priority_min);
-
-	zassert_not_null(sched_getparam);
-	zassert_not_null(sched_getscheduler);
-
-	zassert_not_null(sched_rr_get_interval);
-
-	zassert_not_null(sched_setparam);
-	zassert_not_null(sched_setscheduler);
-#endif
-
-#ifdef CONFIG_POSIX_THREADS
-	zassert_not_null(sched_yield);
-#endif
-}
diff --git a/tests/posix/headers/src/semaphore_h.c b/tests/posix/headers/src/semaphore_h.c
deleted file mode 100644
index 296148b0b0e..00000000000
--- a/tests/posix/headers/src/semaphore_h.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <semaphore.h>
-
-/**
- * @brief existence test for `<semaphore.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html">semaphore.h</a>
- */
-ZTEST(posix_headers, test_semaphore_h)
-{
-	/* zassert_not_equal(SEM_FAILED, (sem_t *)42); */ /* not implemented */
-
-	if (IS_ENABLED(CONFIG_POSIX_AEP_CHOICE_PSE53)) {
-		zassert_not_null(sem_close);
-		zassert_not_null(sem_destroy);
-		zassert_not_null(sem_getvalue);
-		zassert_not_null(sem_init);
-		zassert_not_null(sem_open);
-		zassert_not_null(sem_post);
-		zassert_not_null(sem_timedwait);
-		zassert_not_null(sem_trywait);
-		zassert_not_null(sem_unlink);
-		zassert_not_null(sem_wait);
-	}
-}
diff --git a/tests/posix/headers/src/signal_h.c b/tests/posix/headers/src/signal_h.c
deleted file mode 100644
index dd8ffc5ef4c..00000000000
--- a/tests/posix/headers/src/signal_h.c
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <limits.h>
-#include <signal.h>
-#include <stdlib.h>
-
-/**
- * @brief existence test for `<signal.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html">signal.h</a>
- */
-ZTEST(posix_headers, test_signal_h)
-{
-	typedef void (*my_sig_handler_t)(int signo);
-
-	my_sig_handler_t handler;
-
-	handler = SIG_DFL;
-	handler = SIG_ERR;
-	handler = SIG_IGN;
-
-#if defined(CONFIG_POSIX_SIGNALS)
-	/* zassert_not_equal(-1, SIG_HOLD); */ /* not implemented */
-#endif
-
-	zassert_not_equal((sig_atomic_t)-1, (sig_atomic_t)0);
-
-#if defined(CONFIG_POSIX_SIGNALS)
-	zassert_not_equal((pid_t)-1, (pid_t)0);
-#endif
-
-#if defined(CONFIG_POSIX_REALTIME_SIGNALS)
-	zassert_not_equal(-1, offsetof(struct sigevent, sigev_notify));
-	zassert_not_equal(-1, offsetof(struct sigevent, sigev_signo));
-	zassert_not_equal(-1, offsetof(struct sigevent, sigev_value));
-	zassert_not_equal(-1, offsetof(struct sigevent, sigev_notify_function));
-	zassert_not_equal(-1, offsetof(struct sigevent, sigev_notify_attributes));
-
-	zassert_not_equal(-1, SIGEV_NONE);
-	zassert_not_equal(-1, SIGEV_SIGNAL);
-	zassert_not_equal(-1, SIGEV_THREAD);
-#endif
-
-#if defined(CONFIG_POSIX_SIGNALS)
-	zassert_not_equal(-1, offsetof(union sigval, sival_int));
-	zassert_not_equal(-1, offsetof(union sigval, sival_ptr));
-
-	zassert_true(SIGRTMAX - SIGRTMIN >= 0);
-
-	zassert_not_equal(-1, SIG_BLOCK);
-	zassert_not_equal(-1, SIG_UNBLOCK);
-	zassert_not_equal(-1, SIG_SETMASK);
-
-	zassert_not_equal(-1, offsetof(struct sigaction, sa_handler));
-	zassert_not_equal(-1, offsetof(struct sigaction, sa_mask));
-	zassert_not_equal(-1, offsetof(struct sigaction, sa_flags));
-#if defined(CONFIG_POSIX_REALTIME_SIGNALS) && !defined(CONFIG_NEWLIB_LIBC)
-	zassert_not_equal(-1, offsetof(struct sigaction, sa_sigaction));
-#endif
-
-	zassert_not_equal(-1, offsetof(siginfo_t, si_signo));
-	zassert_not_equal(-1, offsetof(siginfo_t, si_code));
-	zassert_not_equal(-1, offsetof(siginfo_t, si_value));
-#endif
-
-	/* zassert_not_equal(-1, SA_NOCLDSTOP); */ /* not implemented */
-	/* zassert_not_equal(-1, SA_ONSTACK); */ /* not implemented */
-	/* zassert_not_equal(-1, SA_RESETHAND); */ /* not implemented */
-	/* zassert_not_equal(-1, SA_RESTART); */ /* not implemented */
-	/* zassert_not_equal(-1, SA_SIGINFO); */ /* not implemented */
-	/* zassert_not_equal(-1, SA_NOCLDWAIT); */ /* not implemented */
-	/* zassert_not_equal(-1, SA_NODEFER); */ /* not implemented */
-
-	/* zassert_not_equal(-1, SS_ONSTACK); */ /* not implemented */
-	/* zassert_not_equal(-1, SS_DISABLE); */ /* not implemented */
-
-	/* zassert_not_equal(-1, MINSIGSTKSZ); */ /* not implemented */
-	/* zassert_not_equal(-1, SIGSTKSZ); */ /* not implemented */
-
-	/* mcontext_t mctx = {0}; */ /* not implemented */
-
-	/* zassert_not_equal(-1, offsetof(ucontext_t, uc_link)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(ucontext_t, uc_sigmask)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(ucontext_t, uc_stack)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(ucontext_t, uc_mcontext)); */ /* not implemented */
-
-	/* zassert_not_equal(-1, offsetof(stack_t, ss_sp)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(stack_t, ss_size)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(stack_t, ss_flags)); */ /* not implemented */
-
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_signo)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_code)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_errno)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_pid)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_uid)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_addr)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_status)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_band)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(siginfo_t, si_value)); */ /* not implemented */
-
-	/* zassert_not_equal(-1, ILL_ILLOPC); */ /* not implemented */
-	/* zassert_not_equal(-1, ILL_ILLOPN); */ /* not implemented */
-	/* zassert_not_equal(-1, ILL_ILLADR); */ /* not implemented */
-	/* zassert_not_equal(-1, ILL_ILLTRP); */ /* not implemented */
-	/* zassert_not_equal(-1, ILL_PRVOPC); */ /* not implemented */
-	/* zassert_not_equal(-1, ILL_PRVREG); */ /* not implemented */
-	/* zassert_not_equal(-1, ILL_COPROC); */ /* not implemented */
-	/* zassert_not_equal(-1, ILL_BADSTK); */ /* not implemented */
-
-	/* zassert_not_equal(-1, FPE_INTDIV); */ /* not implemented */
-	/* zassert_not_equal(-1, FPE_INTOVF); */ /* not implemented */
-	/* zassert_not_equal(-1, FPE_FLTDIV); */ /* not implemented */
-	/* zassert_not_equal(-1, FPE_FLTOVF); */ /* not implemented */
-	/* zassert_not_equal(-1, FPE_FLTUND); */ /* not implemented */
-	/* zassert_not_equal(-1, FPE_FLTRES); */ /* not implemented */
-	/* zassert_not_equal(-1, FPE_FLTINV); */ /* not implemented */
-	/* zassert_not_equal(-1, FPE_FLTSUB); */ /* not implemented */
-
-	/* zassert_not_equal(-1, SEGV_MAPERR); */ /* not implemented */
-	/* zassert_not_equal(-1, SEGV_ACCERR); */ /* not implemented */
-
-	/* zassert_not_equal(-1, BUS_ADRALN); */ /* not implemented */
-	/* zassert_not_equal(-1, BUS_ADRERR); */ /* not implemented */
-	/* zassert_not_equal(-1, BUS_OBJERR); */ /* not implemented */
-
-	/* zassert_not_equal(-1, TRAP_BRKPT); */ /* not implemented */
-	/* zassert_not_equal(-1, TRAP_TRACE); */ /* not implemented */
-
-	/* zassert_not_equal(-1, CLD_EXITED); */ /* not implemented */
-	/* zassert_not_equal(-1, CLD_KILLED); */ /* not implemented */
-	/* zassert_not_equal(-1, CLD_DUMPED); */ /* not implemented */
-	/* zassert_not_equal(-1, CLD_TRAPPED); */ /* not implemented */
-	/* zassert_not_equal(-1, CLD_STOPPED); */ /* not implemented */
-	/* zassert_not_equal(-1, CLD_CONTINUED); */ /* not implemented */
-
-	zassert_not_equal(-1, SI_USER);
-	zassert_not_equal(-1, SI_QUEUE);
-	zassert_not_equal(-1, SI_TIMER);
-	zassert_not_equal(-1, SI_ASYNCIO);
-	zassert_not_equal(-1, SI_MESGQ);
-
-#ifdef CONFIG_POSIX_SIGNALS
-	zassert_true(SIGRTMIN >= 0);
-	zassert_true(SIGRTMAX >= SIGRTMIN);
-	zassert_not_equal(-1, SIGABRT);
-	zassert_not_equal(-1, SIGALRM);
-	zassert_not_equal(-1, SIGBUS);
-	zassert_not_equal(-1, SIGCHLD);
-	zassert_not_equal(-1, SIGCONT);
-	zassert_not_equal(-1, SIGFPE);
-	zassert_not_equal(-1, SIGHUP);
-	zassert_not_equal(-1, SIGILL);
-	zassert_not_equal(-1, SIGINT);
-	zassert_not_equal(-1, SIGKILL);
-	zassert_not_equal(-1, SIGPIPE);
-	zassert_not_equal(-1, SIGQUIT);
-	zassert_not_equal(-1, SIGSEGV);
-	zassert_not_equal(-1, SIGSTOP);
-	zassert_not_equal(-1, SIGTERM);
-	zassert_not_equal(-1, SIGTSTP);
-	zassert_not_equal(-1, SIGTTIN);
-	zassert_not_equal(-1, SIGTTOU);
-	zassert_not_equal(-1, SIGUSR1);
-	zassert_not_equal(-1, SIGUSR2);
-	zassert_not_equal(-1, SIGTRAP);
-	zassert_not_equal(-1, SIGURG);
-	zassert_not_equal(-1, SIGXCPU);
-	zassert_not_equal(-1, SIGXFSZ);
-	zassert_not_null(abort);
-	zassert_not_null(kill);
-	zassert_not_null(pthread_sigmask);
-	zassert_not_null(raise);
-	zassert_not_null(sigaction);
-	zassert_not_null(sigaddset);
-	zassert_not_null(sigdelset);
-	zassert_not_null(sigemptyset);
-	zassert_not_null(sigfillset);
-	zassert_not_null(sigismember);
-	zassert_not_null(signal);
-	zassert_not_null(sigpending);
-	zassert_not_null(sigprocmask);
-	zassert_not_null(sigsuspend);
-	zassert_not_null(sigwait);
-	zassert_not_null(strsignal);
-#endif /* CONFIG_POSIX_SIGNALS */
-
-	if (IS_ENABLED(CONFIG_POSIX_AEP_CHOICE_PSE53)) {
-		/* zassert_not_null(killpg); */ /* not implemented */
-		/* zassert_not_null(psiginfo); */ /* not implemented */
-		/* zassert_not_null(psignal); */ /* not implemented */
-		/* zassert_not_null(pthread_kill); */ /* not implemented */
-		/* zassert_not_null(sigaltstack); */ /* not implemented */
-		/* zassert_not_null(sighold); */ /* not implemented */
-		/* zassert_not_null(sigignore); */ /* not implemented */
-		/* zassert_not_null(siginterrupt); */ /* not implemented */
-		/* zassert_not_null(sigpause); */ /* not implemented */
-		/* zassert_not_null(sigqueue); */ /* not implemented */
-		/* zassert_not_null(sigrelse); */ /* not implemented */
-		/* zassert_not_null(sigset); */ /* not implemented */
-		/* zassert_not_null(sigtimedwait); */ /* not implemented */
-		/* zassert_not_null(sigwaitinfo); */ /* not implemented */
-	}
-}
diff --git a/tests/posix/headers/src/stropts_h.c b/tests/posix/headers/src/stropts_h.c
deleted file mode 100644
index 82141e106e7..00000000000
--- a/tests/posix/headers/src/stropts_h.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 2024 Abhinav Srivastava
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include "_common.h"
-
-#include <stropts.h>
-
-/**
- * @brief Test existence and basic functionality of stropts.h
- *
- * @see stropts.h
- */
-ZTEST(posix_headers, test_stropts_h)
-{
-#ifdef CONFIG_POSIX_AEP_CHOICE_PSE53
-	zassert_not_null((void *)putmsg, "putmsg is null");
-	zassert_not_null((void *)fdetach, "fdetach is null");
-	zassert_not_null((void *)fattach, "fattach is null");
-	zassert_not_null((void *)getmsg, "getmsg is null");
-	zassert_not_null((void *)getpmsg, "getpmsg is null");
-	zassert_not_null((void *)isastream, "isastream is null");
-
-	zassert_true(sizeof(((struct strbuf *)0)->maxlen) > 0, "maxlen size is 0");
-	zassert_true(sizeof(((struct strbuf *)0)->len) > 0, "len size is 0");
-	zassert_true(sizeof(((struct strbuf *)0)->buf) > 0, "buf size is 0");
-	zassert_not_equal(RS_HIPRI, ~RS_HIPRI);
-	#endif
-}
diff --git a/tests/posix/headers/src/sys_eventfd_h.c b/tests/posix/headers/src/sys_eventfd_h.c
deleted file mode 100644
index 9fc6a201a33..00000000000
--- a/tests/posix/headers/src/sys_eventfd_h.c
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <sys/eventfd.h>
-
-/**
- * @brief existence test for `<sys/eventfd.h>`
- *
- * @note the eventfd API is not (yet) a part of POSIX.
- *
- * @see <a href="https://man7.org/linux/man-pages/man2/eventfd.2.html">sys/eventfd.h</a>
- */
-ZTEST(posix_headers, test_sys_eventfd_h)
-{
-	/* zassert_not_equal(-1, EFD_CLOEXEC); */ /* not implemented */
-	zassert_not_equal(-1, EFD_NONBLOCK);
-	zassert_not_equal(-1, EFD_SEMAPHORE);
-
-	zassert_not_equal((eventfd_t)-1, (eventfd_t)0);
-
-	if (IS_ENABLED(CONFIG_EVENTFD)) {
-		zassert_not_null(eventfd);
-		zassert_not_null(eventfd_read);
-		zassert_not_null(eventfd_write);
-	}
-}
diff --git a/tests/posix/headers/src/sys_ioctl_h.c b/tests/posix/headers/src/sys_ioctl_h.c
deleted file mode 100644
index 34c379c904d..00000000000
--- a/tests/posix/headers/src/sys_ioctl_h.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <sys/ioctl.h>
-
-/**
- * @brief existence test for `<sys/ioctl.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/ioctl.html">ioctl</a>
- * @see <a href="https://man7.org/linux/man-pages/man2/ioctl.2.html">ioctl(2)</a>
- */
-ZTEST(posix_headers, test_sys_ioctl_h)
-{
-	if (IS_ENABLED(CONFIG_POSIX_AEP_CHOICE_PSE53)) {
-		zassert_not_null(ioctl);
-	}
-}
diff --git a/tests/posix/headers/src/sys_select_h.c b/tests/posix/headers/src/sys_select_h.c
deleted file mode 100644
index be651deae6a..00000000000
--- a/tests/posix/headers/src/sys_select_h.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <sys/select.h>
-
-/**
- * @brief existence test for `<sys/select.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_select.h.html">sys/select.h</a>
- */
-ZTEST(posix_headers, test_sys_select_h)
-{
-	fd_set fds = {0};
-
-	zassert_not_equal(-1, FD_SETSIZE);
-
-	if (IS_ENABLED(CONFIG_POSIX_DEVICE_IO)) {
-
-		FD_CLR(0, &fds);
-		FD_ISSET(0, &fds);
-		FD_SET(0, &fds);
-		FD_ZERO(&fds);
-
-		zassert_not_null(pselect);
-		zassert_not_null(select);
-	}
-}
diff --git a/tests/posix/headers/src/sys_socket_h.c b/tests/posix/headers/src/sys_socket_h.c
deleted file mode 100644
index e90d38b7d79..00000000000
--- a/tests/posix/headers/src/sys_socket_h.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <sys/socket.h>
-
-/**
- * @brief existence test for `<sys/socket.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html">sys/socket.h</a>
- */
-ZTEST(posix_headers, test_sys_socket_h)
-{
-	struct cmsghdr cmsg = {0};
-	struct msghdr mhdr = {0};
-
-	zassert_true(sizeof(socklen_t) >= sizeof(uint32_t));
-	zassert_true((sa_family_t)-1 >= 0);
-
-	zassert_not_equal(-1, offsetof(struct sockaddr, sa_family));
-	/*
-	 * FIXME: in zephyr, we define struct sockaddr in <zephyr/net/net_ip.h>
-	 * The sa_data field is defined (incorrectly) as data.
-	 * Fixing that is a (possibly breaking) tree-wide change.
-	 */
-	/* zassert_not_equal(-1, offsetof(struct sockaddr, sa_data)); */ /* not implemented */
-
-	zassert_not_equal(-1, offsetof(struct sockaddr_storage, ss_family));
-	zassert_equal(offsetof(struct sockaddr, sa_family),
-		      offsetof(struct sockaddr_storage, ss_family));
-
-	zassert_not_equal(-1, offsetof(struct msghdr, msg_name));
-	zassert_not_equal(-1, offsetof(struct msghdr, msg_namelen));
-	zassert_not_equal(-1, offsetof(struct msghdr, msg_iov));
-	zassert_not_equal(-1, offsetof(struct msghdr, msg_iovlen));
-	zassert_not_equal(-1, offsetof(struct msghdr, msg_control));
-	zassert_not_equal(-1, offsetof(struct msghdr, msg_controllen));
-	zassert_not_equal(-1, offsetof(struct msghdr, msg_flags));
-
-	zassert_not_equal(-1, offsetof(struct cmsghdr, cmsg_len));
-	zassert_not_equal(-1, offsetof(struct cmsghdr, cmsg_level));
-	zassert_not_equal(-1, offsetof(struct cmsghdr, cmsg_type));
-
-	ARG_UNUSED(CMSG_DATA(&cmsg));
-	__unused struct cmsghdr *next = CMSG_NXTHDR(&mhdr, &cmsg);
-	__unused struct cmsghdr *first = CMSG_FIRSTHDR(&mhdr);
-
-	zassert_not_equal(-1, offsetof(struct linger, l_onoff));
-	zassert_not_equal(-1, offsetof(struct linger, l_linger));
-
-	zassert_not_equal(-1, SOCK_DGRAM);
-	zassert_not_equal(-1, SOCK_RAW);
-	/* zassert_not_equal(-1, SOCK_SEQPACKET); */ /* not implemented */
-	zassert_not_equal(-1, SOCK_STREAM);
-
-	zassert_not_equal(-1, SO_ACCEPTCONN);
-	zassert_not_equal(-1, SO_BROADCAST);
-	zassert_not_equal(-1, SO_DEBUG);
-	zassert_not_equal(-1, SO_DONTROUTE);
-	zassert_not_equal(-1, SO_ERROR);
-	zassert_not_equal(-1, SO_KEEPALIVE);
-	zassert_not_equal(-1, SO_LINGER);
-	zassert_not_equal(-1, SO_OOBINLINE);
-	zassert_not_equal(-1, SO_RCVBUF);
-	zassert_not_equal(-1, SO_RCVLOWAT);
-	zassert_not_equal(-1, SO_RCVTIMEO);
-	zassert_not_equal(-1, SO_REUSEADDR);
-	zassert_not_equal(-1, SO_SNDBUF);
-	zassert_not_equal(-1, SO_SNDLOWAT);
-	zassert_not_equal(-1, SO_SNDTIMEO);
-	zassert_not_equal(-1, SO_TYPE);
-
-	zassert_not_equal(-1, SOMAXCONN);
-
-	/* zassert_not_equal(-1, MSG_CTRUNC); */ /* not implemented */
-	/* zassert_not_equal(-1, MSG_DONTROUTE); */ /* not implemented */
-	/* zassert_not_equal(-1, MSG_EOR); */ /* not implemented */
-	/* zassert_not_equal(-1, MSG_OOB); */ /* not implemented */
-	/* zassert_not_equal(-1, MSG_NOSIGNAL); */ /* not implemented */
-	zassert_not_equal(-1, MSG_PEEK);
-	zassert_not_equal(-1, MSG_TRUNC);
-	zassert_not_equal(-1, MSG_WAITALL);
-
-	zassert_not_equal(-1, AF_INET);
-	zassert_not_equal(-1, AF_INET6);
-	zassert_not_equal(-1, AF_UNIX);
-	zassert_not_equal(-1, AF_UNSPEC);
-
-	zassert_not_equal(-1, SHUT_RD);
-	zassert_not_equal(-1, SHUT_RDWR);
-	zassert_not_equal(-1, SHUT_WR);
-
-	if (IS_ENABLED(CONFIG_POSIX_NETWORKING)) {
-		zassert_not_null(accept);
-		zassert_not_null(bind);
-		zassert_not_null(connect);
-		zassert_not_null(getpeername);
-		zassert_not_null(getsockname);
-		zassert_not_null(listen);
-		zassert_not_null(recv);
-		zassert_not_null(recvfrom);
-		/* zassert_not_null(recvmsg); */ /* not implemented */
-		zassert_not_null(send);
-		zassert_not_null(sendmsg);
-		zassert_not_null(sendto);
-		zassert_not_null(setsockopt);
-		zassert_not_null(shutdown);
-		zassert_not_null(sockatmark);
-		zassert_not_null(socket);
-		zassert_not_null(socketpair);
-	}
-}
diff --git a/tests/posix/headers/src/sys_time_h.c b/tests/posix/headers/src/sys_time_h.c
deleted file mode 100644
index aa87eadf589..00000000000
--- a/tests/posix/headers/src/sys_time_h.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <sys/time.h>
-
-/**
- * @brief existence test for `<sys/time.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_time.h.html">sys/time.h</a>
- */
-ZTEST(posix_headers, test_sys_time_h)
-{
-	zassert_not_equal(-1, offsetof(struct timeval, tv_sec));
-	zassert_not_equal(-1, offsetof(struct timeval, tv_usec));
-
-	/* zassert_not_equal(-1, offsetof(struct itimerval, it_interval)); */ /* not implemented */
-	/* zassert_not_equal(-1, offsetof(struct itimerval, it_value)); */ /* not implemented */
-
-	/* zassert_not_equal(-1, ITIMER_REAL); */ /* not implemented */
-	/* zassert_not_equal(-1, ITIMER_VIRTUAL); */ /* not implemented */
-	/* zassert_not_equal(-1, ITIMER_PROF); */ /* not implemented */
-
-	if (IS_ENABLED(CONFIG_XSI_SINGLE_PROCESS)) {
-		/* zassert_not_null(getitimer); */ /* not implemented */
-		zassert_not_null(gettimeofday);
-		/* zassert_not_null(setitimer); */ /* not implemented */
-		/* zassert_not_null(utimes); */ /* not implemented */
-	}
-}
diff --git a/tests/posix/headers/src/types_h.c b/tests/posix/headers/src/types_h.c
deleted file mode 100644
index 09ba5eab85a..00000000000
--- a/tests/posix/headers/src/types_h.c
+++ /dev/null
@@ -1,12 +0,0 @@
-/*
- * Copyright The Zephyr Project Contributors
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-/* _GNU_SOURCE causes extra headers to be included and can cause dependency
- * loops
- */
-#define _GNU_SOURCE
-
-#include <sys/types.h>
diff --git a/tests/posix/headers/src/unistd_h.c b/tests/posix/headers/src/unistd_h.c
deleted file mode 100644
index 36fbe6f4fa2..00000000000
--- a/tests/posix/headers/src/unistd_h.c
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
- * Copyright (c) 2022 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "_common.h"
-
-#include <unistd.h>
-
-/**
- * @brief existence test for `<unistd.h>`
- *
- * @see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html">unistd.h</a>
- */
-ZTEST(posix_headers, test_unistd_h)
-{
-	/* zassert_not_equal(-1, F_OK); */ /* not implemented */
-	/* zassert_not_equal(-1, R_OK); */ /* not implemented */
-	/* zassert_not_equal(-1, W_OK); */ /* not implemented */
-	/* zassert_not_equal(-1, X_OK); */ /* not implemented */
-
-#if defined(CONFIG_POSIX_SINGLE_PROCESS)
-	zassert_not_equal(INT_MIN, _CS_PATH);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_ILP32_OFF32_CFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_ILP32_OFF32_LDFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_ILP32_OFF32_LIBS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_ILP32_OFFBIG_LIBS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_LP64_OFF64_CFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_LP64_OFF64_LDFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_LP64_OFF64_LIBS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_LPBIG_OFFBIG_LIBS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_THREADS_CFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_THREADS_LDFLAGS);
-	zassert_not_equal(INT_MIN, _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS);
-	zassert_not_equal(INT_MIN, _CS_V7_ENV);
-#endif
-
-	/* zassert_not_equal(-1, F_LOCK); */ /* not implemented */
-	/* zassert_not_equal(-1, F_TEST); */ /* not implemented */
-	/* zassert_not_equal(-1, F_TLOCK); */ /* not implemented */
-	/* zassert_not_equal(-1, F_ULOCK); */ /* not implemented */
-
-	/* zassert_not_equal(INT_MIN, _PC_2_SYMLINKS); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_ALLOC_SIZE_MIN); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_ASYNC_IO); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_CHOWN_RESTRICTED); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_FILESIZEBITS); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_LINK_MAX); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_MAX_CANON); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_MAX_INPUT); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_NAME_MAX); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_NO_TRUNC); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_PATH_MAX); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_PIPE_BUF); */ /* not imp``lemented */
-	/* zassert_not_equal(INT_MIN, _PC_PRIO_IO); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_REC_INCR_XFER_SIZE); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_REC_MAX_XFER_SIZE); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_REC_MIN_XFER_SIZE); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_REC_XFER_ALIGN); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_SYMLINK_MAX); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_SYNC_IO); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_TIMESTAMP_RESOLUTION); */ /* not implemented */
-	/* zassert_not_equal(INT_MIN, _PC_VDISABLE); */ /* not implemented */
-
-	zassert_not_equal(INT_MIN, _SC_2_C_BIND);
-	zassert_not_equal(INT_MIN, _SC_2_C_DEV);
-	zassert_not_equal(INT_MIN, _SC_2_CHAR_TERM);
-	zassert_not_equal(INT_MIN, _SC_2_FORT_DEV);
-	zassert_not_equal(INT_MIN, _SC_2_FORT_RUN);
-	zassert_not_equal(INT_MIN, _SC_2_LOCALEDEF);
-	zassert_not_equal(INT_MIN, _SC_2_PBS);
-	zassert_not_equal(INT_MIN, _SC_2_PBS_ACCOUNTING);
-	zassert_not_equal(INT_MIN, _SC_2_PBS_CHECKPOINT);
-	zassert_not_equal(INT_MIN, _SC_2_PBS_LOCATE);
-	zassert_not_equal(INT_MIN, _SC_2_PBS_MESSAGE);
-	zassert_not_equal(INT_MIN, _SC_2_PBS_TRACK);
-	zassert_not_equal(INT_MIN, _SC_2_SW_DEV);
-	zassert_not_equal(INT_MIN, _SC_2_UPE);
-	zassert_not_equal(INT_MIN, _SC_2_VERSION);
-	zassert_not_equal(INT_MIN, _SC_ADVISORY_INFO);
-	zassert_not_equal(INT_MIN, _SC_AIO_LISTIO_MAX);
-	zassert_not_equal(INT_MIN, _SC_AIO_MAX);
-	zassert_not_equal(INT_MIN, _SC_AIO_PRIO_DELTA_MAX);
-	zassert_not_equal(INT_MIN, _SC_ARG_MAX);
-	zassert_not_equal(INT_MIN, _SC_ASYNCHRONOUS_IO);
-	zassert_not_equal(INT_MIN, _SC_ATEXIT_MAX);
-	zassert_not_equal(INT_MIN, _SC_BARRIERS);
-	zassert_not_equal(INT_MIN, _SC_BC_BASE_MAX);
-	zassert_not_equal(INT_MIN, _SC_BC_DIM_MAX);
-	zassert_not_equal(INT_MIN, _SC_BC_SCALE_MAX);
-	zassert_not_equal(INT_MIN, _SC_BC_STRING_MAX);
-	zassert_not_equal(INT_MIN, _SC_CHILD_MAX);
-	zassert_not_equal(INT_MIN, _SC_CLK_TCK);
-	zassert_not_equal(INT_MIN, _SC_CLOCK_SELECTION);
-	zassert_not_equal(INT_MIN, _SC_COLL_WEIGHTS_MAX);
-	zassert_not_equal(INT_MIN, _SC_CPUTIME);
-	zassert_not_equal(INT_MIN, _SC_DELAYTIMER_MAX);
-	zassert_not_equal(INT_MIN, _SC_EXPR_NEST_MAX);
-	zassert_not_equal(INT_MIN, _SC_FSYNC);
-	zassert_not_equal(INT_MIN, _SC_GETGR_R_SIZE_MAX);
-	zassert_not_equal(INT_MIN, _SC_GETPW_R_SIZE_MAX);
-	zassert_not_equal(INT_MIN, _SC_HOST_NAME_MAX);
-	zassert_not_equal(INT_MIN, _SC_IOV_MAX);
-	zassert_not_equal(INT_MIN, _SC_IPV6);
-	zassert_not_equal(INT_MIN, _SC_JOB_CONTROL);
-	zassert_not_equal(INT_MIN, _SC_LINE_MAX);
-	zassert_not_equal(INT_MIN, _SC_LOGIN_NAME_MAX);
-	zassert_not_equal(INT_MIN, _SC_MAPPED_FILES);
-	zassert_not_equal(INT_MIN, _SC_MEMLOCK);
-	zassert_not_equal(INT_MIN, _SC_MEMLOCK_RANGE);
-	zassert_not_equal(INT_MIN, _SC_MEMORY_PROTECTION);
-	zassert_not_equal(INT_MIN, _SC_MESSAGE_PASSING);
-	zassert_not_equal(INT_MIN, _SC_MONOTONIC_CLOCK);
-	zassert_not_equal(INT_MIN, _SC_MQ_OPEN_MAX);
-	zassert_not_equal(INT_MIN, _SC_MQ_PRIO_MAX);
-	zassert_not_equal(INT_MIN, _SC_NGROUPS_MAX);
-	zassert_not_equal(INT_MIN, _SC_OPEN_MAX);
-	zassert_not_equal(INT_MIN, _SC_PAGE_SIZE);
-	zassert_not_equal(INT_MIN, _SC_PAGESIZE);
-	zassert_not_equal(INT_MIN, _SC_PRIORITIZED_IO);
-	zassert_not_equal(INT_MIN, _SC_PRIORITY_SCHEDULING);
-	zassert_not_equal(INT_MIN, _SC_RAW_SOCKETS);
-	zassert_not_equal(INT_MIN, _SC_RE_DUP_MAX);
-	zassert_not_equal(INT_MIN, _SC_READER_WRITER_LOCKS);
-	zassert_not_equal(INT_MIN, _SC_REALTIME_SIGNALS);
-	zassert_not_equal(INT_MIN, _SC_REGEXP);
-	zassert_not_equal(INT_MIN, _SC_RTSIG_MAX);
-	zassert_not_equal(INT_MIN, _SC_SAVED_IDS);
-	zassert_not_equal(INT_MIN, _SC_SEM_NSEMS_MAX);
-	zassert_not_equal(INT_MIN, _SC_SEM_VALUE_MAX);
-	zassert_not_equal(INT_MIN, _SC_SEMAPHORES);
-	zassert_not_equal(INT_MIN, _SC_SHARED_MEMORY_OBJECTS);
-	zassert_not_equal(INT_MIN, _SC_SHELL);
-	zassert_not_equal(INT_MIN, _SC_SIGQUEUE_MAX);
-	zassert_not_equal(INT_MIN, _SC_SPAWN);
-	zassert_not_equal(INT_MIN, _SC_SPIN_LOCKS);
-	zassert_not_equal(INT_MIN, _SC_SPORADIC_SERVER);
-	zassert_not_equal(INT_MIN, _SC_SS_REPL_MAX);
-	zassert_not_equal(INT_MIN, _SC_STREAM_MAX);
-	zassert_not_equal(INT_MIN, _SC_SYMLOOP_MAX);
-	zassert_not_equal(INT_MIN, _SC_SYNCHRONIZED_IO);
-	zassert_not_equal(INT_MIN, _SC_THREAD_ATTR_STACKADDR);
-	zassert_not_equal(INT_MIN, _SC_THREAD_ATTR_STACKSIZE);
-	zassert_not_equal(INT_MIN, _SC_THREAD_CPUTIME);
-	zassert_not_equal(INT_MIN, _SC_THREAD_DESTRUCTOR_ITERATIONS);
-	zassert_not_equal(INT_MIN, _SC_THREAD_KEYS_MAX);
-	zassert_not_equal(INT_MIN, _SC_THREAD_PRIO_INHERIT);
-	zassert_not_equal(INT_MIN, _SC_THREAD_PRIO_PROTECT);
-	zassert_not_equal(INT_MIN, _SC_THREAD_PRIORITY_SCHEDULING);
-	zassert_not_equal(INT_MIN, _SC_THREAD_PROCESS_SHARED);
-	zassert_not_equal(INT_MIN, _SC_THREAD_ROBUST_PRIO_INHERIT);
-	zassert_not_equal(INT_MIN, _SC_THREAD_ROBUST_PRIO_PROTECT);
-	zassert_not_equal(INT_MIN, _SC_THREAD_SAFE_FUNCTIONS);
-	zassert_not_equal(INT_MIN, _SC_THREAD_SPORADIC_SERVER);
-	zassert_not_equal(INT_MIN, _SC_THREAD_STACK_MIN);
-	zassert_not_equal(INT_MIN, _SC_THREAD_THREADS_MAX);
-	zassert_not_equal(INT_MIN, _SC_THREADS);
-	zassert_not_equal(INT_MIN, _SC_TIMEOUTS);
-	zassert_not_equal(INT_MIN, _SC_TIMER_MAX);
-	zassert_not_equal(INT_MIN, _SC_TIMERS);
-	zassert_not_equal(INT_MIN, _SC_TRACE);
-	zassert_not_equal(INT_MIN, _SC_TRACE_EVENT_FILTER);
-	zassert_not_equal(INT_MIN, _SC_TRACE_EVENT_NAME_MAX);
-	zassert_not_equal(INT_MIN, _SC_TRACE_INHERIT);
-	zassert_not_equal(INT_MIN, _SC_TRACE_LOG);
-	zassert_not_equal(INT_MIN, _SC_TRACE_NAME_MAX);
-	zassert_not_equal(INT_MIN, _SC_TRACE_SYS_MAX);
-	zassert_not_equal(INT_MIN, _SC_TRACE_USER_EVENT_MAX);
-	zassert_not_equal(INT_MIN, _SC_TTY_NAME_MAX);
-	zassert_not_equal(INT_MIN, _SC_TYPED_MEMORY_OBJECTS);
-	zassert_not_equal(INT_MIN, _SC_TZNAME_MAX);
-	zassert_not_equal(INT_MIN, _SC_V7_ILP32_OFF32);
-	zassert_not_equal(INT_MIN, _SC_V7_ILP32_OFFBIG);
-	zassert_not_equal(INT_MIN, _SC_V7_LP64_OFF64);
-	zassert_not_equal(INT_MIN, _SC_V7_LPBIG_OFFBIG);
-	zassert_not_equal(INT_MIN, _SC_V6_ILP32_OFF32);
-	zassert_not_equal(INT_MIN, _SC_V6_ILP32_OFFBIG);
-	zassert_not_equal(INT_MIN, _SC_V6_LP64_OFF64);
-	zassert_not_equal(INT_MIN, _SC_V6_LPBIG_OFFBIG);
-	zassert_not_equal(INT_MIN, _SC_VERSION);
-	zassert_not_equal(INT_MIN, _SC_XOPEN_CRYPT);
-	zassert_not_equal(INT_MIN, _SC_XOPEN_ENH_I18N);
-	zassert_not_equal(INT_MIN, _SC_XOPEN_REALTIME);
-	zassert_not_equal(INT_MIN, _SC_XOPEN_REALTIME_THREADS);
-	zassert_not_equal(INT_MIN, _SC_XOPEN_SHM);
-	zassert_not_equal(INT_MIN, _SC_XOPEN_STREAMS);
-	zassert_not_equal(INT_MIN, _SC_XOPEN_UNIX);
-	/* zassert_not_equal(INT_MIN, _SC_XOPEN_UUCP); */ /* not implemented */
-	zassert_not_equal(INT_MIN, _SC_XOPEN_VERSION);
-
-	/* zassert_equal(STDERR_FILENO, 2); */ /* not implemented */
-	/* zassert_equal(STDIN_FILENO, 0); */ /* not implemented */
-	/* zassert_equal(STDOUT_FILENO, 1); */ /* not implemented */
-
-#if !defined(_POSIX_C_SOURCE)
-	zassert_not_equal(INT_MIN, _POSIX_VDISABLE);
-#endif
-
-#ifdef CONFIG_POSIX_AEP_CHOICE_PSE53
-	/* zassert_not_null(access); */ /* not implemented */
-	/* zassert_not_null(alarm); */ /* not implemented */
-	/* zassert_not_null(chdir); */ /* not implemented */
-	/* zassert_not_null(chown); */ /* not implemented */
-	zassert_not_null(close);
-	/* zassert_not_null(confstr); */ /* not implemented */
-	/* zassert_not_null(crypt); */ /* not implemented */
-	/* zassert_not_null(dup); */ /* not implemented */
-	/* zassert_not_null(dup2); */ /* not implemented */
-	zassert_not_null(_exit);
-	/* zassert_not_null(encrypt); */ /* not implemented */
-	/* zassert_not_null(execl); */ /* not implemented */
-	/* zassert_not_null(execle); */ /* not implemented */
-	/* zassert_not_null(execlp); */ /* not implemented */
-	/* zassert_not_null(execv); */ /* not implemented */
-	/* zassert_not_null(execve); */ /* not implemented */
-	/* zassert_not_null(execvp); */ /* not implemented */
-	/* zassert_not_null(faccessat); */ /* not implemented */
-	/* zassert_not_null(fchdir); */ /* not implemented */
-	/* zassert_not_null(fchown); */ /* not implemented */
-	/* zassert_not_null(fchownat); */ /* not implemented */
-	zassert_not_null(fdatasync);
-	/* zassert_not_null(fexecve); */ /* not implemented */
-	/* zassert_not_null(fork); */ /* not implemented */
-	/* zassert_not_null(fpathconf); */ /* not implemented */
-	zassert_not_null(fsync);
-	zassert_not_null(ftruncate);
-	/* zassert_not_null(getcwd); */ /* not implemented */
-	/* zassert_not_null(getegid); */ /* not implemented */
-	/* zassert_not_null(geteuid); */ /* not implemented */
-	/* zassert_not_null(getgid); */ /* not implemented */
-	/* zassert_not_null(getgroups); */ /* not implemented */
-	/* zassert_not_null(gethostid); */ /* not implemented */
-	/* zassert_not_null(gethostname); */ /* not implemented */
-	/* zassert_not_null(getlogin); */ /* not implemented */
-	/* zassert_not_null(getlogin_r); */ /* not implemented */
-	zassert_not_null(getopt);
-	/* zassert_not_null(getpgid); */ /* not implemented */
-	/* zassert_not_null(getpgrp); */ /* not implemented */
-	zassert_not_null(getpid);
-	/* zassert_not_null(getppid); */ /* not implemented */
-	/* zassert_not_null(getsid); */ /* not implemented */
-	/* zassert_not_null(getuid); */ /* not implemented */
-	/* zassert_not_null(isatty); */ /* not implemented */
-	/* zassert_not_null(lchown); */ /* not implemented */
-	/* zassert_not_null(link); */ /* not implemented */
-	/* zassert_not_null(linkat); */ /* not implemented */
-	/* zassert_not_null(lockf); */ /* not implemented */
-	zassert_not_null(lseek);
-	/* zassert_not_null(nice); */ /* not implemented */
-	/* zassert_not_null(pathconf); */ /* not implemented */
-	/* zassert_not_null(pause); */ /* not implemented */
-	/* zassert_not_null(pipe); */ /* not implemented */
-	/* zassert_not_null(pread); */ /* not implemented */
-	/* zassert_not_null(pwrite); */ /* not implemented */
-	zassert_not_null(read);
-	/* zassert_not_null(readlink); */ /* not implemented */
-	/* zassert_not_null(readlinkat); */ /* not implemented */
-	/* zassert_not_null(rmdir); */ /* not implemented */
-	/* zassert_not_null(setegid); */ /* not implemented */
-	/* zassert_not_null(seteuid); */ /* not implemented */
-	/* zassert_not_null(setgid); */ /* not implemented */
-	/* zassert_not_null(setpgid); */ /* not implemented */
-	/* zassert_not_null(setpgrp); */ /* not implemented */
-	/* zassert_not_null(setregid); */ /* not implemented */
-	/* zassert_not_null(setreuid); */ /* not implemented */
-	/* zassert_not_null(setsid); */ /* not implemented */
-	/* zassert_not_null(setuid); */ /* not implemented */
-	zassert_not_null(sleep);
-	/* zassert_not_null(swab); */ /* not implemented */
-	/* zassert_not_null(symlink); */ /* not implemented */
-	/* zassert_not_null(symlinkat); */ /* not implemented */
-	/* zassert_not_null(sync); */ /* not implemented */
-	/* zassert_not_null(sysconf); */ /* not implemented */
-	/* zassert_not_null(tcgetpgrp); */ /* not implemented */
-	/* zassert_not_null(tcsetpgrp); */ /* not implemented */
-	/* zassert_not_null(truncate); */ /* not implemented */
-	/* zassert_not_null(ttyname); */ /* not implemented */
-	/* zassert_not_null(ttyname_r); */ /* not implemented */
-	zassert_not_null(unlink);
-	/* zassert_not_null(unlinkat); */ /* not implemented */
-	zassert_not_null(write);
-#endif
-}
diff --git a/tests/posix/headers/testcase.yaml b/tests/posix/headers/testcase.yaml
deleted file mode 100644
index a5c9687289b..00000000000
--- a/tests/posix/headers/testcase.yaml
+++ /dev/null
@@ -1,50 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-  min_ram: 32
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_x86_64
-tests:
-  portability.posix.headers.with_posix_api:
-    extra_configs:
-      - CONFIG_POSIX_AEP_CHOICE_PSE53=y
-  portability.posix.headers.without_posix_api: {}
-  portability.posix.headers.minimal.with_posix_api:
-    extra_configs:
-      - CONFIG_POSIX_AEP_CHOICE_PSE53=y
-  portability.posix.headers.minimal.without_posix_api: {}
-  portability.posix.headers.picolibc.with_posix_api:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_POSIX_AEP_CHOICE_PSE53=y
-      - CONFIG_PICOLIBC=y
-  portability.posix.headers.picolibc.without_posix_api:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
-  portability.posix.headers.newlib.with_posix_api:
-    tags: newlib
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_POSIX_AEP_CHOICE_PSE53=y
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.headers.newlib.without_posix_api:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.headers.arcmwdtlib.with_posix_api:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_POSIX_AEP_CHOICE_PSE53=y
-      - CONFIG_ARCMWDT_LIBC=y
-  portability.posix.headers.arcmwdtlib.without_posix_api:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_ARCMWDT_LIBC=y
diff --git a/tests/posix/multi_process/CMakeLists.txt b/tests/posix/multi_process/CMakeLists.txt
deleted file mode 100644
index c7ddea3ab71..00000000000
--- a/tests/posix/multi_process/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_multi_process)
-
-FILE(GLOB app_sources src/*.c)
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/multi_process/prj.conf b/tests/posix/multi_process/prj.conf
deleted file mode 100644
index 5ad1124362b..00000000000
--- a/tests/posix/multi_process/prj.conf
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_MULTI_PROCESS=y
diff --git a/tests/posix/multi_process/src/_main.c b/tests/posix/multi_process/src/_main.c
deleted file mode 100644
index 365afda2b1f..00000000000
--- a/tests/posix/multi_process/src/_main.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-ZTEST_SUITE(posix_multi_process, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/multi_process/src/getpid.c b/tests/posix/multi_process/src/getpid.c
deleted file mode 100644
index 6082bdac901..00000000000
--- a/tests/posix/multi_process/src/getpid.c
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(posix_multi_process, test_getpid)
-{
-	pid_t pid = getpid();
-
-	zexpect_true(pid > 0, "invalid pid: %d", pid);
-}
diff --git a/tests/posix/multi_process/src/sleep.c b/tests/posix/multi_process/src/sleep.c
deleted file mode 100644
index 527e33c60f6..00000000000
--- a/tests/posix/multi_process/src/sleep.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2022, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-
-struct waker_work {
-	k_tid_t tid;
-	struct k_work_delayable dwork;
-};
-static struct waker_work wake_work;
-
-static void waker_func(struct k_work *work)
-{
-	struct waker_work *ww;
-	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
-
-	ww = CONTAINER_OF(dwork, struct waker_work, dwork);
-	k_wakeup(ww->tid);
-}
-K_WORK_DELAYABLE_DEFINE(waker, waker_func);
-
-ZTEST(posix_multi_process, test_sleep)
-{
-	uint32_t then;
-	uint32_t now;
-	/* call sleep(10), wakeup after 1s, expect >= 8s left */
-	const uint32_t sleep_min_s = 1;
-	const uint32_t sleep_max_s = 10;
-	const uint32_t sleep_rem_s = 8;
-
-	/* sleeping for 0s should return 0 */
-	zassert_ok(sleep(0));
-
-	/* test that sleeping for 1s sleeps for at least 1s */
-	then = k_uptime_get();
-	zassert_equal(0, sleep(1));
-	now = k_uptime_get();
-	zassert_true((now - then) >= 1 * MSEC_PER_SEC);
-
-	/* test that sleeping for 2s sleeps for at least 2s */
-	then = k_uptime_get();
-	zassert_equal(0, sleep(2));
-	now = k_uptime_get();
-	zassert_true((now - then) >= 2 * MSEC_PER_SEC);
-
-	/* test that sleep reports the remainder */
-	wake_work.tid = k_current_get();
-	k_work_init_delayable(&wake_work.dwork, waker_func);
-	zassert_equal(1, k_work_schedule(&wake_work.dwork, K_SECONDS(sleep_min_s)));
-	zassert_true(sleep(sleep_max_s) >= sleep_rem_s);
-}
diff --git a/tests/posix/multi_process/src/times.c b/tests/posix/multi_process/src/times.c
deleted file mode 100644
index 1b815d9e5fe..00000000000
--- a/tests/posix/multi_process/src/times.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <sys/times.h>
-
-#include <zephyr/kernel.h>
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-ZTEST(posix_multi_process, test_times)
-{
-	static const struct {
-		const char *name;
-		size_t offset;
-	} fields[] = {
-		{
-			.name = "utime",
-			.offset = offsetof(struct tms, tms_utime),
-		},
-		{
-			.name = "stime",
-			.offset = offsetof(struct tms, tms_stime),
-		},
-		{
-			.name = "cutime",
-			.offset = offsetof(struct tms, tms_cutime),
-		},
-		{
-			.name = "cstime",
-			.offset = offsetof(struct tms, tms_cstime),
-		},
-	};
-	struct tms test_tms[2] = {};
-	clock_t rtime[2];
-
-	rtime[0] = times(&test_tms[0]);
-	k_msleep(MSEC_PER_SEC);
-	rtime[1] = times(&test_tms[1]);
-
-	zexpect_not_equal(rtime[0], -1);
-	zexpect_not_equal(rtime[1], -1);
-
-	printk("t0: rtime: %ld utime: %ld stime: %ld cutime: %ld cstime: %ld\n", rtime[0],
-	       test_tms[0].tms_utime, test_tms[0].tms_stime, test_tms[0].tms_cutime,
-	       test_tms[0].tms_cstime);
-	printk("t1: rtime: %ld utime: %ld stime: %ld cutime: %ld cstime: %ld\n", rtime[1],
-	       test_tms[1].tms_utime, test_tms[1].tms_stime, test_tms[1].tms_cutime,
-	       test_tms[1].tms_cstime);
-
-	ARRAY_FOR_EACH(fields, i) {
-		const char *name = fields[i].name;
-		size_t offset = fields[i].offset;
-
-		clock_t t0 = *(clock_t *)((uint8_t *)&test_tms[0] + offset);
-		clock_t t1 = *(clock_t *)((uint8_t *)&test_tms[1] + offset);
-
-		zexpect_true(t1 >= t0, "time moved backward for tms_%s: t0: %ld t1: %ld", name, t0,
-			     t1);
-	}
-}
diff --git a/tests/posix/multi_process/testcase.yaml b/tests/posix/multi_process/testcase.yaml
deleted file mode 100644
index c3d77f932d6..00000000000
--- a/tests/posix/multi_process/testcase.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - multi_process
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_riscv64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.muti_process: {}
-  portability.posix.muti_process.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.muti_process.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.muti_process.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/net/CMakeLists.txt b/tests/posix/net/CMakeLists.txt
deleted file mode 100644
index a383c174491..00000000000
--- a/tests/posix/net/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_net)
-
-FILE(GLOB app_sources src/*.c)
-
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/tests/posix/net/prj.conf b/tests/posix/net/prj.conf
deleted file mode 100644
index e29924edb58..00000000000
--- a/tests/posix/net/prj.conf
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG_ZTEST=y
-CONFIG_NET_TEST=y
-CONFIG_TEST_RANDOM_GENERATOR=y
-
-CONFIG_POSIX_AEP_CHOICE_PSE53=y
-CONFIG_POSIX_NETWORKING=y
-CONFIG_NETWORKING=y
diff --git a/tests/posix/net/src/gethostname.c b/tests/posix/net/src/gethostname.c
deleted file mode 100644
index 2094775194e..00000000000
--- a/tests/posix/net/src/gethostname.c
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(net, test_gethostname)
-{
-	char hostname[CONFIG_NET_HOSTNAME_MAX_LEN + 1];
-	int ret;
-
-	ret = gethostname(hostname, sizeof(hostname));
-	zassert_equal(ret, 0, "gethostname() failed: %d", ret);
-
-	zassert_equal(strcmp(hostname, CONFIG_NET_HOSTNAME), 0,
-		      "gethostname() returned unexpected hostname: %s", hostname);
-}
diff --git a/tests/posix/net/src/if.c b/tests/posix/net/src/if.c
deleted file mode 100644
index b51e62a5490..00000000000
--- a/tests/posix/net/src/if.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2024, Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/logging/log.h>
-#include <zephyr/net/net_if.h>
-#include <net/if.h>
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-ZTEST(net, test_if_indextoname)
-{
-	char *name;
-	size_t n = 0;
-	struct net_if *iface;
-	char a[IF_NAMESIZE];
-	char b[IF_NAMESIZE];
-
-	NET_IFACE_COUNT(&n);
-	TC_PRINT("%zu interfaces\n", n);
-	for (size_t i = 0; i < n; i++) {
-		memset(a, 0, sizeof(a));
-		memset(b, 0, sizeof(b));
-		name = if_indextoname(i + 1, a);
-		zassert_equal(name, a);
-		TC_PRINT("interface %zu: %s\n", i + 1, name);
-		iface = net_if_get_by_index(i + 1);
-		zassert_not_null(iface);
-		zassert_true(net_if_get_name(iface, b, IF_NAMESIZE) >= 0);
-		zassert_mem_equal(a, b, IF_NAMESIZE);
-	}
-}
-
-ZTEST(net, test_if_freenameindex)
-{
-	if_freenameindex(NULL);
-	if_freenameindex(if_nameindex());
-}
-
-ZTEST(net, test_if_nameindex)
-{
-	size_t n = 0;
-	struct if_nameindex *ni;
-
-	NET_IFACE_COUNT(&n);
-	TC_PRINT("%zu interfaces\n", n);
-
-	ni = if_nameindex();
-	if (ni == NULL) {
-		zassert_equal(errno, ENOBUFS);
-		return;
-	}
-
-	for (size_t i = 0; i < n; i++) {
-		zassert_equal(i + 1, ni[i].if_index);
-		zassert_not_null(ni[i].if_name);
-		TC_PRINT("interface %zu: %s\n", i + 1, ni[i].if_name);
-		zassert_equal(0, ni[n].if_index);
-		zassert_is_null(ni[n].if_name);
-	}
-
-	if_freenameindex(ni);
-}
-
-ZTEST(net, test_if_nametoindex)
-{
-	size_t n = 0;
-	char buf[IF_NAMESIZE];
-
-	NET_IFACE_COUNT(&n);
-	TC_PRINT("%zu interfaces\n", n);
-	for (size_t i = 0; i < n; i++) {
-		memset(buf, 0, sizeof(buf));
-		zassert_not_null(if_indextoname(i + 1, buf));
-		TC_PRINT("interface %zu: %s\n", i + 1, buf);
-		zassert_equal(i + 1, if_nametoindex(buf));
-	}
-}
diff --git a/tests/posix/net/src/inet_addr.c b/tests/posix/net/src/inet_addr.c
deleted file mode 100644
index 6f99014a76b..00000000000
--- a/tests/posix/net/src/inet_addr.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (c) 2024, Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <stdint.h>
-
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-ZTEST(net, test_inet_addr)
-{
-	in_addr_t ret;
-	static const struct parm {
-		const char *in;
-		int out;
-	} parms[] = {
-	/* expect failure */
-#ifndef CONFIG_ARCH_POSIX
-		{NULL, (uint32_t)-1}, /* this value will segfault using the host libc */
-#endif
-		{".", (uint32_t)-1},
-		{"..", (uint32_t)-1},
-		{"...", (uint32_t)-1},
-		{"-1.-2.-3.-4", (uint32_t)-1},
-		{"256.65536.4294967296.18446744073709551616", (uint32_t)-1},
-		{"a.b.c.d", (uint32_t)-1},
-		{"0.0.0.1234", (uint32_t)-1},
-		{"0.0.0.12a", (uint32_t)-1},
-		{" 1.2.3.4", (uint32_t)-1},
-
-		/* expect success */
-		{"0.0.0.0", htonl(0)},
-		{"000.00.0.0", htonl(0)},
-		{"127.0.0.1", htonl(0x7f000001)},
-		{"1.2.3.4", htonl(0x01020304)},
-		{"1.2.3.4    ", htonl(0x01020304)},
-		{"0.0.0.123 a", htonl(0x0000007b)},
-		{"255.255.255.255", htonl(0xffffffffU)},
-	};
-
-	ARRAY_FOR_EACH_PTR(parms, p) {
-		ret = inet_addr(p->in);
-		zexpect_equal(ret, p->out, "inet_addr(%s) failed. expect: %d actual: %d", p->in,
-			      p->out, ret);
-	}
-}
diff --git a/tests/posix/net/src/inet_ntoa.c b/tests/posix/net/src/inet_ntoa.c
deleted file mode 100644
index 362257f0668..00000000000
--- a/tests/posix/net/src/inet_ntoa.c
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2024, Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <arpa/inet.h>
-#include <netinet/in.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(net, test_inet_ntoa)
-{
-	struct in_addr in;
-
-	in.s_addr = htonl(0x7f000001);
-	zassert_mem_equal(inet_ntoa(in), "127.0.0.1", strlen("127.0.0.1") + 1);
-
-	in.s_addr = htonl(0);
-	zassert_mem_equal(inet_ntoa(in), "0.0.0.0", strlen("0.0.0.0") + 1);
-
-	in.s_addr = htonl(0xffffffffU);
-	zassert_mem_equal(inet_ntoa(in), "255.255.255.255", strlen("255.255.255.255") + 1);
-}
diff --git a/tests/posix/net/src/main.c b/tests/posix/net/src/main.c
deleted file mode 100644
index bbb25dcacfc..00000000000
--- a/tests/posix/net/src/main.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * Copyright (c) 2024, Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-ZTEST_SUITE(net, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/net/testcase.yaml b/tests/posix/net/testcase.yaml
deleted file mode 100644
index 2075c84e102..00000000000
--- a/tests/posix/net/testcase.yaml
+++ /dev/null
@@ -1,39 +0,0 @@
-common:
-  depends_on: netif
-  min_ram: 16
-  tags:
-    - iface
-    - net
-    - posix
-  # dependent on netif support
-  integration_platforms:
-    - mps2/an385
-    - qemu_x86
-  # Building with the host libC links to if_*() from the host libc which causes the test to crash
-  # immediately.
-  filter: not CONFIG_NATIVE_LIBC
-tests:
-  portability.posix.net:
-    extra_configs:
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.posix.net.armclang_std_libc:
-    toolchain_allow: armclang
-    extra_configs:
-      - CONFIG_ARMCLANG_STD_LIBC=y
-  portability.posix.net.arcmwdtlib:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_ARCMWDT_LIBC=y
-  portability.posix.net.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.posix.net.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.net.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/rwlocks/CMakeLists.txt b/tests/posix/rwlocks/CMakeLists.txt
deleted file mode 100644
index 5043854b6bd..00000000000
--- a/tests/posix/rwlocks/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_rw_locks)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/rwlocks/prj.conf b/tests/posix/rwlocks/prj.conf
deleted file mode 100644
index 7463b9537b5..00000000000
--- a/tests/posix/rwlocks/prj.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_RW_LOCKS=y
-
-CONFIG_DYNAMIC_THREAD=y
-CONFIG_DYNAMIC_THREAD_POOL_SIZE=3
-CONFIG_THREAD_STACK_INFO=y
diff --git a/tests/posix/rwlocks/src/main.c b/tests/posix/rwlocks/src/main.c
deleted file mode 100644
index aaf859663bf..00000000000
--- a/tests/posix/rwlocks/src/main.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-
-#include <zephyr/logging/log.h>
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define N_THR 3
-BUILD_ASSERT(N_THR <= CONFIG_DYNAMIC_THREAD_POOL_SIZE, "Insufficient number of dynamic threads");
-
-LOG_MODULE_REGISTER(posix_rwlock_test);
-
-static pthread_rwlock_t rwlock;
-
-static void *thread_top(void *p1)
-{
-	int ret;
-	pthread_t id;
-
-	id = (pthread_t)pthread_self();
-	ret = pthread_rwlock_tryrdlock(&rwlock);
-	if (ret != 0) {
-		LOG_DBG("Not able to get RD lock on trying, try again");
-		zassert_ok(pthread_rwlock_rdlock(&rwlock), "Failed to acquire write lock");
-	}
-
-	LOG_DBG("Thread %d got RD lock", id);
-	usleep(USEC_PER_MSEC);
-	LOG_DBG("Thread %d releasing RD lock", id);
-	zassert_ok(pthread_rwlock_unlock(&rwlock), "Failed to unlock");
-
-	LOG_DBG("Thread %d acquiring WR lock", id);
-	ret = pthread_rwlock_trywrlock(&rwlock);
-	if (ret != 0) {
-		zassert_ok(pthread_rwlock_wrlock(&rwlock), "Failed to acquire WR lock");
-	}
-
-	LOG_DBG("Thread %d acquired WR lock", id);
-	usleep(USEC_PER_MSEC);
-	LOG_DBG("Thread %d releasing WR lock", id);
-	zassert_ok(pthread_rwlock_unlock(&rwlock), "Failed to unlock");
-
-	return NULL;
-}
-
-ZTEST(posix_rw_locks, test_rw_lock)
-{
-	int ret;
-	pthread_t newthread[N_THR];
-	struct timespec time;
-	void *status;
-
-	time.tv_sec = 1;
-	time.tv_nsec = 0;
-
-	zassert_equal(pthread_rwlock_destroy(&rwlock), EINVAL);
-	zassert_equal(pthread_rwlock_rdlock(&rwlock), EINVAL);
-	zassert_equal(pthread_rwlock_wrlock(&rwlock), EINVAL);
-	zassert_equal(pthread_rwlock_trywrlock(&rwlock), EINVAL);
-	zassert_equal(pthread_rwlock_tryrdlock(&rwlock), EINVAL);
-	zassert_equal(pthread_rwlock_timedwrlock(&rwlock, &time), EINVAL);
-	zassert_equal(pthread_rwlock_timedrdlock(&rwlock, &time), EINVAL);
-	zassert_equal(pthread_rwlock_unlock(&rwlock), EINVAL);
-
-	zassert_ok(pthread_rwlock_init(&rwlock, NULL), "Failed to create rwlock");
-	LOG_DBG("main acquire WR lock and 3 threads acquire RD lock");
-	zassert_ok(pthread_rwlock_timedwrlock(&rwlock, &time), "Failed to acquire write lock");
-
-	/* Creating N preemptive threads in increasing order of priority */
-	for (int i = 0; i < N_THR; i++) {
-		zassert_ok(pthread_create(&newthread[i], NULL, thread_top, NULL),
-			   "Low memory to thread new thread");
-	}
-
-	/* Delay to give change to child threads to run */
-	usleep(USEC_PER_MSEC);
-	LOG_DBG("Parent thread releasing WR lock");
-	zassert_ok(pthread_rwlock_unlock(&rwlock), "Failed to unlock");
-
-	/* Let child threads acquire RD Lock */
-	usleep(USEC_PER_MSEC);
-	LOG_DBG("Parent thread acquiring WR lock again");
-
-	zassert_ok(clock_gettime(CLOCK_REALTIME, &time));
-	time.tv_sec += 2;
-
-	ret = pthread_rwlock_timedwrlock(&rwlock, &time);
-	if (ret) {
-		zassert_ok(pthread_rwlock_wrlock(&rwlock), "Failed to acquire write lock");
-	}
-
-	LOG_DBG("Parent thread acquired WR lock again");
-	usleep(USEC_PER_MSEC);
-	LOG_DBG("Parent thread releasing WR lock again");
-	zassert_ok(pthread_rwlock_unlock(&rwlock), "Failed to unlock");
-
-	LOG_DBG("3 threads acquire WR lock");
-	LOG_DBG("Main thread acquiring RD lock");
-
-	ret = pthread_rwlock_timedrdlock(&rwlock, &time);
-	if (ret != 0) {
-		zassert_ok(pthread_rwlock_rdlock(&rwlock), "Failed to lock");
-	}
-
-	LOG_DBG("Main thread acquired RD lock");
-	usleep(USEC_PER_MSEC);
-	LOG_DBG("Main thread releasing RD lock");
-	zassert_ok(pthread_rwlock_unlock(&rwlock), "Failed to unlock");
-
-	for (int i = 0; i < N_THR; i++) {
-		zassert_ok(pthread_join(newthread[i], &status), "Failed to join");
-	}
-
-	zassert_ok(pthread_rwlock_destroy(&rwlock), "Failed to destroy rwlock");
-}
-
-static void test_pthread_rwlockattr_pshared_common(bool set, int pshared)
-{
-	int tmp_pshared = 4242;
-	pthread_rwlockattr_t attr;
-
-	zassert_ok(pthread_rwlockattr_init(&attr));
-	zassert_ok(pthread_rwlockattr_getpshared(&attr, &tmp_pshared));
-	zassert_equal(tmp_pshared, PTHREAD_PROCESS_PRIVATE);
-	if (set) {
-		zassert_ok(pthread_rwlockattr_setpshared(&attr, pshared));
-		zassert_ok(pthread_rwlockattr_getpshared(&attr, &tmp_pshared));
-		zassert_equal(tmp_pshared, pshared);
-	}
-	zassert_ok(pthread_rwlockattr_destroy(&attr));
-}
-
-ZTEST(posix_rw_locks, test_pthread_rwlockattr_getpshared)
-{
-	test_pthread_rwlockattr_pshared_common(false, 0);
-}
-
-ZTEST(posix_rw_locks, test_pthread_rwlockattr_setpshared)
-{
-	test_pthread_rwlockattr_pshared_common(true, PTHREAD_PROCESS_PRIVATE);
-	test_pthread_rwlockattr_pshared_common(true, PTHREAD_PROCESS_SHARED);
-}
-
-ZTEST_SUITE(posix_rw_locks, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/rwlocks/testcase.yaml b/tests/posix/rwlocks/testcase.yaml
deleted file mode 100644
index 9e31cbc07d0..00000000000
--- a/tests/posix/rwlocks/testcase.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - rwlocks
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_riscv64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.rwlocks: {}
-  portability.posix.rwlocks.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.rwlocks.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-      - CONFIG_NEWLIB_LIBC_MIN_REQUIRED_HEAP_SIZE=8192
-  portability.posix.rwlocks.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/semaphores/CMakeLists.txt b/tests/posix/semaphores/CMakeLists.txt
deleted file mode 100644
index b43570e197d..00000000000
--- a/tests/posix/semaphores/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_semaphores)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/semaphores/Kconfig b/tests/posix/semaphores/Kconfig
deleted file mode 100644
index 8da58b91138..00000000000
--- a/tests/posix/semaphores/Kconfig
+++ /dev/null
@@ -1,11 +0,0 @@
-# Copyright (c) 2023, Meta
-# SPDX-License-Identifier: Apache-2.0
-
-config TEST_SEM_N_LOOPS
-	int "Number of loops in semaphore test"
-	range 16 1024
-	default 32
-	help
-	  This option is specific to semaphore.test_named_semaphore in semaphore.c
-
-source "Kconfig.zephyr"
diff --git a/tests/posix/semaphores/prj.conf b/tests/posix/semaphores/prj.conf
deleted file mode 100644
index 803ae3b3898..00000000000
--- a/tests/posix/semaphores/prj.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_SEMAPHORES=y
-
-CONFIG_DYNAMIC_THREAD=y
-CONFIG_DYNAMIC_THREAD_POOL_SIZE=2
-CONFIG_THREAD_STACK_INFO=y
diff --git a/tests/posix/semaphores/src/main.c b/tests/posix/semaphores/src/main.c
deleted file mode 100644
index c8b566349a6..00000000000
--- a/tests/posix/semaphores/src/main.c
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <pthread.h>
-#include <semaphore.h>
-#include <time.h>
-
-#include <zephyr/sys/timeutil.h>
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define WAIT_TIME_MS 100
-BUILD_ASSERT(WAIT_TIME_MS > 0, "WAIT_TIME_MS must be posistive");
-
-/* based on the current structure of this unit test */
-BUILD_ASSERT(CONFIG_DYNAMIC_THREAD_POOL_SIZE >= 2, "CONFIG_DYNAMIC_THREAD_POOL_SIZE must be >= 2");
-
-static void *child_func(void *p1)
-{
-	sem_t *sem = (sem_t *)p1;
-
-	zassert_equal(sem_post(sem), 0, "sem_post failed");
-	return NULL;
-}
-
-static void semaphore_test(sem_t *sem)
-{
-	pthread_t thread1, thread2;
-	int val, ret;
-	struct timespec abstime;
-
-	/* TESTPOINT: Check if sema value is less than
-	 * CONFIG_POSIX_SEM_VALUE_MAX
-	 */
-	zassert_equal(sem_init(sem, 0, (CONFIG_POSIX_SEM_VALUE_MAX + 1)), -1,
-		      "value larger than %d\n", CONFIG_POSIX_SEM_VALUE_MAX);
-	zassert_equal(errno, EINVAL);
-
-	zassert_equal(sem_init(sem, 0, 0), 0, "sem_init failed");
-
-	/* TESTPOINT: Check if semaphore value is as set */
-	zassert_equal(sem_getvalue(sem, &val), 0);
-	zassert_equal(val, 0);
-
-	/* TESTPOINT: Check if sema is acquired when it
-	 * is not available
-	 */
-	zassert_equal(sem_trywait(sem), -1);
-	zassert_equal(errno, EAGAIN);
-
-	ret = pthread_create(&thread1, NULL, child_func, sem);
-	zassert_equal(ret, 0, "Thread creation failed");
-
-	zassert_equal(clock_gettime(CLOCK_REALTIME, &abstime), 0, "clock_gettime failed");
-
-	timespec_add(&abstime, &(struct timespec){.tv_sec = WAIT_TIME_MS / MSEC_PER_SEC,
-						  (WAIT_TIME_MS % MSEC_PER_SEC) * NSEC_PER_MSEC});
-
-	/* TESPOINT: Wait to acquire sem given by thread1 */
-	zassert_equal(sem_timedwait(sem, &abstime), 0);
-
-	/* TESTPOINT: Semaphore is already acquired, check if
-	 * no semaphore is available
-	 */
-	zassert_equal(sem_timedwait(sem, &abstime), -1);
-	zassert_equal(errno, ETIMEDOUT);
-
-	zassert_equal(sem_destroy(sem), 0, "semaphore is not destroyed");
-
-	/* TESTPOINT: Initialize sema with 1 */
-	zassert_equal(sem_init(sem, 0, 1), 0, "sem_init failed");
-	zassert_equal(sem_getvalue(sem, &val), 0);
-	zassert_equal(val, 1);
-
-	zassert_equal(sem_destroy(sem), -1, "acquired semaphore is destroyed");
-	zassert_equal(errno, EBUSY);
-
-	/* TESTPOINT: take semaphore which is initialized with 1 */
-	zassert_equal(sem_trywait(sem), 0);
-
-	zassert_equal(pthread_create(&thread2, NULL, child_func, sem), 0, "Thread creation failed");
-
-	/* TESTPOINT: Wait and acquire semaphore till thread2 gives */
-	zassert_equal(sem_wait(sem), 0, "sem_wait failed");
-
-	/* Make sure the threads are terminated */
-	zassert_ok(pthread_join(thread1, NULL));
-	zassert_ok(pthread_join(thread2, NULL));
-}
-
-ZTEST(posix_semaphores, test_semaphore)
-{
-	sem_t sema;
-
-	/* TESTPOINT: Call sem_post with invalid kobject */
-	zassert_equal(sem_post(NULL), -1,
-		      "sem_post of"
-		      " invalid semaphore object didn't fail");
-	zassert_equal(errno, EINVAL);
-
-	/* TESTPOINT: sem_destroy with invalid kobject */
-	zassert_equal(sem_destroy(NULL), -1,
-		      "invalid"
-		      " semaphore is destroyed");
-	zassert_equal(errno, EINVAL);
-
-	semaphore_test(&sema);
-}
-
-int nsem_get_ref_count(sem_t *sem);
-size_t nsem_get_list_len(void);
-
-static void *nsem_open_func(void *p)
-{
-	const char *name = (char *)p;
-
-	for (int i = 0; i < CONFIG_TEST_SEM_N_LOOPS; i++) {
-		zassert_not_null(sem_open(name, 0, 0, 0), "%s is NULL", name);
-		k_msleep(1);
-	}
-
-	/* Unlink after finished opening */
-	zassert_ok(sem_unlink(name));
-	return NULL;
-}
-
-static void *nsem_close_func(void *p)
-{
-	sem_t *sem = (sem_t *)p;
-
-	/* Make sure that we have enough ref_count's initially */
-	k_msleep(CONFIG_TEST_SEM_N_LOOPS >> 1);
-
-	for (int i = 0; i < CONFIG_TEST_SEM_N_LOOPS; i++) {
-		zassert_ok(sem_close(sem));
-		k_msleep(1);
-	}
-
-	/* Close the last `sem` */
-	zassert_ok(sem_close(sem));
-	return NULL;
-}
-
-ZTEST(posix_semaphores, test_named_semaphore)
-{
-	pthread_t thread1, thread2;
-	sem_t *sem1, *sem2, *different_sem1;
-
-	/* If `name` is invalid */
-	sem1 = sem_open(NULL, 0, 0, 0);
-	zassert_equal(errno, EINVAL);
-	zassert_equal_ptr(sem1, SEM_FAILED);
-	zassert_equal(nsem_get_list_len(), 0);
-
-	/* Attempt to open a named sem that doesn't exist */
-	sem1 = sem_open("sem1", 0, 0, 0);
-	zassert_equal(errno, ENOENT);
-	zassert_equal_ptr(sem1, SEM_FAILED);
-	zassert_equal(nsem_get_list_len(), 0);
-
-	/* Name exceeds CONFIG_POSIX_SEM_NAMELEN_MAX */
-	char name_too_long[CONFIG_POSIX_SEM_NAMELEN_MAX + 2];
-
-	for (size_t i = 0; i < sizeof(name_too_long) - 1; i++) {
-		name_too_long[i] = 'a';
-	}
-	name_too_long[sizeof(name_too_long) - 1] = '\0';
-
-	sem1 = sem_open(name_too_long, 0, 0, 0);
-	zassert_equal(errno, ENAMETOOLONG, "\"%s\" should be longer than %d", name_too_long,
-		      CONFIG_POSIX_SEM_NAMELEN_MAX);
-	zassert_equal_ptr(sem1, SEM_FAILED);
-	zassert_equal(nsem_get_list_len(), 0);
-
-	/* `value` greater than CONFIG_POSIX_SEM_VALUE_MAX */
-	sem1 = sem_open("sem1", O_CREAT, 0, (CONFIG_POSIX_SEM_VALUE_MAX + 1));
-	zassert_equal(errno, EINVAL);
-	zassert_equal_ptr(sem1, SEM_FAILED);
-	zassert_equal(nsem_get_list_len(), 0);
-
-	/* Open named sem */
-	sem1 = sem_open("sem1", O_CREAT, 0, 0);
-	zassert_equal(nsem_get_ref_count(sem1), 2);
-	zassert_equal(nsem_get_list_len(), 1);
-	sem2 = sem_open("sem2", O_CREAT, 0, 0);
-	zassert_equal(nsem_get_ref_count(sem2), 2);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Open created named sem repeatedly */
-	for (size_t i = 1; i <= CONFIG_TEST_SEM_N_LOOPS; i++) {
-		sem_t *new_sem1, *new_sem2;
-
-		/* oflags are ignored (except when both O_CREAT & O_EXCL are set) */
-		new_sem1 = sem_open("sem1", i % 2 == 0 ? O_CREAT : 0, 0, 0);
-		zassert_not_null(new_sem1);
-		zassert_equal_ptr(new_sem1, sem1); /* Should point to the same sem */
-		new_sem2 = sem_open("sem2", i % 2 == 0 ? O_CREAT : 0, 0, 0);
-		zassert_not_null(new_sem2);
-		zassert_equal_ptr(new_sem2, sem2);
-
-		/* ref_count should increment */
-		zassert_equal(nsem_get_ref_count(sem1), 2 + i);
-		zassert_equal(nsem_get_ref_count(sem2), 2 + i);
-
-		/* Should reuse the same named sem instead of creating another one */
-		zassert_equal(nsem_get_list_len(), 2);
-	}
-
-	/* O_CREAT and O_EXCL are set and the named semaphore already exists */
-	zassert_equal_ptr((sem_open("sem1", O_CREAT | O_EXCL, 0, 0)), SEM_FAILED);
-	zassert_equal(errno, EEXIST);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	zassert_equal(sem_close(NULL), -1);
-	zassert_equal(errno, EINVAL);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Close sem */
-	for (size_t i = CONFIG_TEST_SEM_N_LOOPS;
-	     /* close until one left, required by the test later */
-	     i >= 1; i--) {
-		zassert_ok(sem_close(sem1));
-		zassert_equal(nsem_get_ref_count(sem1), 2 + i - 1);
-
-		zassert_ok(sem_close(sem2));
-		zassert_equal(nsem_get_ref_count(sem2), 2 + i - 1);
-
-		zassert_equal(nsem_get_list_len(), 2);
-	}
-
-	/* If `name` is invalid */
-	zassert_equal(sem_unlink(NULL), -1);
-	zassert_equal(errno, EINVAL);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Attempt to unlink a named sem that doesn't exist */
-	zassert_equal(sem_unlink("sem3"), -1);
-	zassert_equal(errno, ENOENT);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Name exceeds CONFIG_POSIX_SEM_NAMELEN_MAX */
-	char long_sem_name[CONFIG_POSIX_SEM_NAMELEN_MAX + 2];
-
-	for (int i = 0; i < CONFIG_POSIX_SEM_NAMELEN_MAX + 1; i++) {
-		long_sem_name[i] = 'a';
-	}
-	long_sem_name[CONFIG_POSIX_SEM_NAMELEN_MAX + 1] = '\0';
-
-	zassert_equal(sem_unlink(long_sem_name), -1);
-	zassert_equal(errno, ENAMETOOLONG);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Unlink sem1 when it is still being used */
-	zassert_equal(nsem_get_ref_count(sem1), 2);
-	zassert_ok(sem_unlink("sem1"));
-	/* sem won't be destroyed */
-	zassert_equal(nsem_get_ref_count(sem1), 1);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Create another sem with the name of an unlinked sem */
-	different_sem1 = sem_open("sem1", O_CREAT, 0, 0);
-	zassert_not_null(different_sem1);
-	/* The created sem will be a different instance */
-	zassert(different_sem1 != sem1, "");
-	zassert_equal(nsem_get_list_len(), 3);
-
-	/* Destruction of sem1 will be postponed until all references to the semaphore have been
-	 * destroyed by calls to sem_close()
-	 */
-	zassert_ok(sem_close(sem1));
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Closing a linked sem won't destroy the sem */
-	zassert_ok(sem_close(sem2));
-	zassert_equal(nsem_get_ref_count(sem2), 1);
-	zassert_equal(nsem_get_list_len(), 2);
-
-	/* Instead the sem will be destroyed upon call to sem_unlink() */
-	zassert_ok(sem_unlink("sem2"));
-	zassert_equal(nsem_get_list_len(), 1);
-
-	/* What we have left open here is `different_sem` as "sem1", which has a ref_count of 2 */
-	zassert_equal(nsem_get_ref_count(different_sem1), 2);
-
-	/* Stress test: open & close "sem1" repeatedly */
-	zassert_ok(pthread_create(&thread1, NULL, nsem_open_func, "sem1"));
-	zassert_ok(pthread_create(&thread2, NULL, nsem_close_func, different_sem1));
-
-	/* Make sure the threads are terminated */
-	zassert_ok(pthread_join(thread1, NULL));
-	zassert_ok(pthread_join(thread2, NULL));
-
-	/* All named semaphores should be destroyed here */
-	zassert_equal(nsem_get_list_len(), 0);
-
-	/* Create a new named sem to be used in the normal semaphore test */
-	sem1 = sem_open("nsem", O_CREAT, 0, 0);
-	zassert_equal(nsem_get_list_len(), 1);
-	zassert_equal(nsem_get_ref_count(sem1), 2);
-
-	/* Run the semaphore test with the created named semaphore */
-	semaphore_test(sem1);
-
-	/* List length and ref_count shouldn't change after the test */
-	zassert_equal(nsem_get_list_len(), 1);
-	zassert_equal(nsem_get_ref_count(sem1), 2);
-
-	/* Unless it is unlinked and closed */
-	sem_unlink("nsem");
-	sem_close(sem1);
-	zassert_equal(nsem_get_list_len(), 0);
-}
-
-ZTEST_SUITE(posix_semaphores, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/semaphores/testcase.yaml b/tests/posix/semaphores/testcase.yaml
deleted file mode 100644
index 5201ad90283..00000000000
--- a/tests/posix/semaphores/testcase.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - semaphores
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_x86_64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.semaphores: {}
-  portability.posix.semaphores.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.semaphores.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.semaphores.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/signals/CMakeLists.txt b/tests/posix/signals/CMakeLists.txt
deleted file mode 100644
index 1c61d68cf1e..00000000000
--- a/tests/posix/signals/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_signals)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/signals/prj.conf b/tests/posix/signals/prj.conf
deleted file mode 100644
index 3cf0e3d3db5..00000000000
--- a/tests/posix/signals/prj.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_PSE51=y
-CONFIG_POSIX_SIGNALS=y
-
-CONFIG_DYNAMIC_THREAD=y
-CONFIG_THREAD_STACK_INFO=y
-CONFIG_DYNAMIC_THREAD_POOL_SIZE=1
diff --git a/tests/posix/signals/src/main.c b/tests/posix/signals/src/main.c
deleted file mode 100644
index 69f8bd7a5eb..00000000000
--- a/tests/posix/signals/src/main.c
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * Copyright (c) 2023 Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define SIGNO_WORD_IDX(_signo) (_signo / BITS_PER_LONG)
-#define SIGNO_WORD_BIT(_signo) (_signo & BIT_MASK(LOG2(BITS_PER_LONG)))
-
-#define SIGSET_NLONGS (sizeof(sigset_t) / sizeof(unsigned long))
-BUILD_ASSERT(SIGSET_NLONGS > 0, "sigset_t has no storage");
-
-ZTEST(posix_signals, test_sigemptyset)
-{
-	sigset_t set;
-	unsigned long *const _set = (unsigned long *)&set;
-
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		_set[i] = -1;
-	}
-
-	zassert_ok(sigemptyset(&set));
-
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		zassert_equal(_set[i], 0u, "set.sig[%d] is not empty: 0x%lx", i, _set[i]);
-	}
-}
-
-ZTEST(posix_signals, test_sigfillset)
-{
-	sigset_t set = (sigset_t){0};
-	unsigned long *const _set = (unsigned long *)&set;
-
-	zassert_ok(sigfillset(&set));
-
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		zassert_equal(_set[i], -1, "set.sig[%d] is not filled: 0x%lx", i, _set[i]);
-	}
-}
-
-ZTEST(posix_signals, test_sigaddset_oor)
-{
-	sigset_t set = (sigset_t){0};
-
-	zassert_equal(sigaddset(&set, -1), -1, "rc should be -1");
-	zassert_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-
-	zassert_equal(sigaddset(&set, 0), -1, "rc should be -1");
-	zassert_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-
-	zassert_equal(sigaddset(&set, SIGRTMAX + 1), -1, "rc should be -1");
-	zassert_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-}
-
-ZTEST(posix_signals, test_sigaddset)
-{
-	int signo;
-	sigset_t set = (sigset_t){0};
-	unsigned long *const _set = (unsigned long *)&set;
-	sigset_t target = (sigset_t){0};
-	unsigned long *const _target = (unsigned long *)&target;
-
-	signo = SIGHUP;
-	zassert_ok(sigaddset(&set, signo));
-	WRITE_BIT(_target[0], signo, 1);
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		zassert_equal(_set[i], _target[i],
-			      "set.sig[%d of %d] has content: %lx, expected %lx", i,
-			      (int)(SIGSET_NLONGS - 1), _set[i], _target[i]);
-	}
-
-	signo = SIGSYS;
-	zassert_ok(sigaddset(&set, signo));
-	WRITE_BIT(_target[0], signo, 1);
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		zassert_equal(_set[i], _target[i],
-			      "set.sig[%d of %d] has content: %lx, expected %lx", i,
-			      (int)(SIGSET_NLONGS - 1), _set[i], _target[i]);
-	}
-
-	/* TODO: move rt signal tests to realtime_signals testsuite */
-	static const int rtsigs[] = {SIGRTMIN, SIGRTMAX};
-
-	ARRAY_FOR_EACH(rtsigs, i) {
-		int expected_ret = 0;
-		int expected_errno = 0;
-
-		signo = rtsigs[i];
-		if (signo >= SIGSET_NLONGS * BITS_PER_LONG) {
-			/* Some libc's provide a sigset_t that is too small for real-time signals */
-			expected_ret = -1;
-			expected_errno = EINVAL;
-		} else {
-			WRITE_BIT(_target[signo / BITS_PER_LONG], signo % BITS_PER_LONG, 1);
-		}
-
-		errno = 0;
-		zassert_equal(sigaddset(&set, signo), expected_ret);
-		zassert_equal(errno, expected_errno);
-		for (int i = 0; i < SIGSET_NLONGS; i++) {
-			zassert_equal(_set[i], _target[i],
-				      "set.sig[%d of %d] has content: %lx, expected %lx", i,
-				      (int)(SIGSET_NLONGS - 1), _set[i], _target[i]);
-		}
-	}
-}
-
-ZTEST(posix_signals, test_sigdelset_oor)
-{
-	sigset_t set = (sigset_t){0};
-
-	zassert_equal(sigdelset(&set, -1), -1, "rc should be -1");
-	zassert_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-
-	zassert_equal(sigdelset(&set, 0), -1, "rc should be -1");
-	zassert_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-
-	zassert_equal(sigdelset(&set, SIGRTMAX + 1), -1, "rc should be -1");
-	zassert_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-}
-
-ZTEST(posix_signals, test_sigdelset)
-{
-	int signo;
-	sigset_t set = (sigset_t){0};
-	unsigned long *const _set = (unsigned long *)&set;
-	sigset_t target = (sigset_t){0};
-	unsigned long *const _target = (unsigned long *)&target;
-
-	zassert_ok(sigfillset(&set));
-	zassert_ok(sigfillset(&target));
-
-	signo = SIGHUP;
-	zassert_ok(sigdelset(&set, signo));
-	WRITE_BIT(_target[0], signo, 0);
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		zassert_equal(_set[i], _target[i],
-			      "set.sig[%d of %d] has content: %lx, expected %lx", i,
-			      (int)(SIGSET_NLONGS - 1), _set[i], _target[i]);
-	}
-
-	signo = SIGSYS;
-	zassert_ok(sigdelset(&set, signo));
-	WRITE_BIT(_target[0], signo, 0);
-	for (int i = 0; i < SIGSET_NLONGS; i++) {
-		zassert_equal(_set[i], _target[i],
-			      "set.sig[%d of %d] has content: %lx, expected %lx", i,
-			      (int)(SIGSET_NLONGS - 1), _set[i], _target[i]);
-	}
-
-	/* TODO: move rt signal tests to realtime_signals testsuite */
-	static const int rtsigs[] = {SIGRTMIN, SIGRTMAX};
-
-	ARRAY_FOR_EACH(rtsigs, i) {
-		int expected_ret = 0;
-		int expected_errno = 0;
-
-		signo = rtsigs[i];
-		if (signo >= SIGSET_NLONGS * BITS_PER_LONG) {
-			/* Some libc's provide a sigset_t that is too small for real-time signals */
-			expected_ret = -1;
-			expected_errno = EINVAL;
-		} else {
-			WRITE_BIT(_target[signo / BITS_PER_LONG], signo % BITS_PER_LONG, 0);
-		}
-
-		errno = 0;
-		zassert_equal(sigdelset(&set, signo), expected_ret);
-		zassert_equal(errno, expected_errno);
-		for (int i = 0; i < SIGSET_NLONGS; i++) {
-			zassert_equal(_set[i], _target[i],
-				      "set.sig[%d of %d] has content: %lx, expected %lx", i,
-				      (int)(SIGSET_NLONGS - 1), _set[i], _target[i]);
-		}
-	}
-}
-
-ZTEST(posix_signals, test_sigismember_oor)
-{
-	int res;
-	sigset_t set = {0};
-
-	res = sigismember(&set, -1);
-	zexpect_equal(res, -1, "rc should be -1 but is %d", res);
-	zexpect_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-
-	res = sigismember(&set, 0);
-	zexpect_equal(res, -1, "rc should be -1 but is %d", res);
-	zexpect_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-
-	res = sigismember(&set, SIGRTMAX + 1);
-	zexpect_equal(res, -1, "rc should be -1 but is %d", res);
-	zexpect_equal(errno, EINVAL, "errno should be %s", "EINVAL");
-}
-
-ZTEST(posix_signals, test_sigismember)
-{
-	sigset_t set = (sigset_t){0};
-	unsigned long *const _set = (unsigned long *)&set;
-
-	_set[0] = BIT(SIGHUP) | BIT(SIGSYS);
-
-	zassert_equal(sigismember(&set, SIGHUP), 1, "%s expected to be member", "SIGHUP");
-	zassert_equal(sigismember(&set, SIGSYS), 1, "%s expected to be member", "SIGSYS");
-
-	zassert_equal(sigismember(&set, SIGKILL), 0, "%s not expected to be member", "SIGKILL");
-	zassert_equal(sigismember(&set, SIGTERM), 0, "%s not expected to be member", "SIGTERM");
-
-	/* TODO: move rt signal tests to realtime_signals testsuite */
-	static const int rtsigs[] = {SIGRTMIN, SIGRTMAX};
-
-	ARRAY_FOR_EACH(rtsigs, i) {
-		int expected_ret = 1;
-		int expected_errno = 0;
-		int signo = rtsigs[i];
-
-		if (signo >= SIGSET_NLONGS * BITS_PER_LONG) {
-			/* Some libc's provide a sigset_t that is too small for real-time signals */
-			expected_ret = -1;
-			expected_errno = EINVAL;
-		} else {
-			WRITE_BIT(_set[signo / BITS_PER_LONG], signo % BITS_PER_LONG, 1);
-		}
-
-		errno = 0;
-		zassert_equal(sigismember(&set, signo), expected_ret);
-		zassert_equal(errno, expected_errno);
-	}
-}
-
-ZTEST(posix_signals, test_signal_strsignal)
-{
-	/* Using -INT_MAX here because compiler resolves INT_MIN to (-2147483647 - 1) */
-	char buf[sizeof("RT signal -" STRINGIFY(INT_MAX))] = {0};
-
-	zassert_mem_equal(strsignal(-1), "Invalid signal", sizeof("Invalid signal"));
-	zassert_mem_equal(strsignal(0), "Invalid signal", sizeof("Invalid signal"));
-	zassert_mem_equal(strsignal(SIGRTMAX + 1), "Invalid signal", sizeof("Invalid signal"));
-
-	zassert_mem_equal(strsignal(30), "Signal 30", sizeof("Signal 30"));
-	snprintf(buf, sizeof(buf), "RT signal %d", SIGRTMIN - SIGRTMIN);
-	zassert_mem_equal(strsignal(SIGRTMIN), buf, strlen(buf));
-	snprintf(buf, sizeof(buf), "RT signal %d", SIGRTMAX - SIGRTMIN);
-	zassert_mem_equal(strsignal(SIGRTMAX), buf, strlen(buf));
-
-#ifdef CONFIG_POSIX_SIGNAL_STRING_DESC
-	zassert_mem_equal(strsignal(SIGHUP), "Hangup", sizeof("Hangup"));
-	zassert_mem_equal(strsignal(SIGSYS), "Bad system call", sizeof("Bad system call"));
-#else
-	snprintf(buf, sizeof(buf), "Signal %d", SIGHUP);
-	zassert_mem_equal(strsignal(SIGHUP), buf, strlen(buf));
-	snprintf(buf, sizeof(buf), "Signal %d", SIGSYS);
-	zassert_mem_equal(strsignal(SIGSYS), buf, strlen(buf));
-#endif
-}
-
-typedef int (*sigmask_fn)(int how, const sigset_t *set, sigset_t *oset);
-static void *test_sigmask_entry(void *arg)
-{
-/* for clarity */
-#define SIG_GETMASK SIG_SETMASK
-
-	enum {
-		NEW,
-		OLD,
-	};
-	static sigset_t set[2];
-	const int invalid_how = 0x9a2ba9e;
-	sigmask_fn sigmask = arg;
-
-	/* invalid how results in EINVAL */
-	zassert_equal(sigmask(invalid_how, NULL, NULL), EINVAL);
-	zassert_equal(sigmask(invalid_how, &set[NEW], &set[OLD]), EINVAL);
-
-	/* verify setting / getting masks */
-	zassert_ok(sigemptyset(&set[NEW]));
-	zassert_ok(sigmask(SIG_SETMASK, &set[NEW], NULL));
-	zassert_ok(sigfillset(&set[OLD]));
-	zassert_ok(sigmask(SIG_GETMASK, NULL, &set[OLD]));
-	zassert_mem_equal(&set[OLD], &set[NEW], sizeof(set[OLD]));
-
-	zassert_ok(sigfillset(&set[NEW]));
-	zassert_ok(sigmask(SIG_SETMASK, &set[NEW], NULL));
-	zassert_ok(sigemptyset(&set[OLD]));
-	zassert_ok(sigmask(SIG_GETMASK, NULL, &set[OLD]));
-	zassert_mem_equal(&set[OLD], &set[NEW], sizeof(set[OLD]));
-
-	/* start with an empty mask */
-	zassert_ok(sigemptyset(&set[NEW]));
-	zassert_ok(sigmask(SIG_SETMASK, &set[NEW], NULL));
-
-	/* verify SIG_BLOCK: expect (SIGUSR1 | SIGUSR2 | SIGHUP) */
-	zassert_ok(sigemptyset(&set[NEW]));
-	zassert_ok(sigaddset(&set[NEW], SIGUSR1));
-	zassert_ok(sigmask(SIG_BLOCK, &set[NEW], NULL));
-
-	zassert_ok(sigemptyset(&set[NEW]));
-	zassert_ok(sigaddset(&set[NEW], SIGUSR2));
-	zassert_ok(sigaddset(&set[NEW], SIGHUP));
-	zassert_ok(sigmask(SIG_BLOCK, &set[NEW], NULL));
-
-	zassert_ok(sigemptyset(&set[OLD]));
-	zassert_ok(sigaddset(&set[OLD], SIGUSR1));
-	zassert_ok(sigaddset(&set[OLD], SIGUSR2));
-	zassert_ok(sigaddset(&set[OLD], SIGHUP));
-
-	zassert_ok(sigmask(SIG_GETMASK, NULL, &set[NEW]));
-	zassert_mem_equal(&set[NEW], &set[OLD], sizeof(set[NEW]));
-
-	/* start with full mask */
-	zassert_ok(sigfillset(&set[NEW]));
-	zassert_ok(sigmask(SIG_SETMASK, &set[NEW], NULL));
-
-	/* verify SIG_UNBLOCK: expect ~(SIGUSR1 | SIGUSR2 | SIGHUP) */
-	zassert_ok(sigemptyset(&set[NEW]));
-	zassert_ok(sigaddset(&set[NEW], SIGUSR1));
-	zassert_ok(sigmask(SIG_UNBLOCK, &set[NEW], NULL));
-
-	zassert_ok(sigemptyset(&set[NEW]));
-	zassert_ok(sigaddset(&set[NEW], SIGUSR2));
-	zassert_ok(sigaddset(&set[NEW], SIGHUP));
-	zassert_ok(sigmask(SIG_UNBLOCK, &set[NEW], NULL));
-
-	zassert_ok(sigfillset(&set[OLD]));
-	zassert_ok(sigdelset(&set[OLD], SIGUSR1));
-	zassert_ok(sigdelset(&set[OLD], SIGUSR2));
-	zassert_ok(sigdelset(&set[OLD], SIGHUP));
-
-	zassert_ok(sigmask(SIG_GETMASK, NULL, &set[NEW]));
-	zassert_mem_equal(&set[NEW], &set[OLD], sizeof(set[NEW]));
-
-	return NULL;
-}
-
-ZTEST(posix_signals, test_pthread_sigmask)
-{
-	pthread_t th;
-
-	zassert_ok(pthread_create(&th, NULL, test_sigmask_entry, pthread_sigmask));
-	zassert_ok(pthread_join(th, NULL));
-}
-
-ZTEST(posix_signals, test_sigprocmask)
-{
-	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
-		if (!IS_ENABLED(CONFIG_ASSERT)) {
-			zassert_not_ok(sigprocmask(SIG_SETMASK, NULL, NULL));
-			zassert_equal(errno, ENOSYS);
-		}
-	} else {
-		pthread_t th;
-
-		zassert_ok(pthread_create(&th, NULL, test_sigmask_entry, sigprocmask));
-		zassert_ok(pthread_join(th, NULL));
-	}
-}
-
-ZTEST_SUITE(posix_signals, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/signals/testcase.yaml b/tests/posix/signals/testcase.yaml
deleted file mode 100644
index eb2e02bb6ec..00000000000
--- a/tests/posix/signals/testcase.yaml
+++ /dev/null
@@ -1,61 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - signals
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  min_flash: 64
-  min_ram: 32
-  # Exclude qemu_arc/qemu_arc_hs5x for now because of qemu_arc issue
-  # qemu-system-arc: /usr/src/debug/nativesdk-qemu-arc/git/target/arc/decoder-v2.c:266:
-  #   arc_find_format_v2: Assertion `mcount != 0' failed.
-  # Aborted (core dumped)
-  platform_exclude:
-    - qemu_arc/qemu_arc_hs5x
-tests:
-  portability.posix.signals:
-    integration_platforms:
-      - qemu_riscv64
-  portability.posix.signals.minimal:
-    integration_platforms:
-      - qemu_riscv64
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.signals.newlib:
-    integration_platforms:
-      - qemu_riscv64
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.signals.picolibc:
-    integration_platforms:
-      - qemu_riscv64
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
-  portability.posix.signals.strginal_no_desc:
-    integration_platforms:
-      - qemu_riscv64
-    extra_configs:
-      - CONFIG_POSIX_SIGNAL_STRING_DESC=n
-  portability.posix.signals.big_nsig:
-    integration_platforms:
-      - qemu_riscv64
-    extra_configs:
-      - CONFIG_POSIX_RTSIG_MAX=1024
-  portability.posix.signals.native:
-    platform_allow:
-      - native_sim
-      - native_sim/native/64
-    integration_platforms:
-      - native_sim
-      - native_sim/native/64
-    integration_toolchains:
-      - host
-      - llvm
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/single_process/CMakeLists.txt b/tests/posix/single_process/CMakeLists.txt
deleted file mode 100644
index a8cfbed3443..00000000000
--- a/tests/posix/single_process/CMakeLists.txt
+++ /dev/null
@@ -1,14 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_single_process)
-
-FILE(GLOB app_sources src/*.c)
-
-target_sources(app PRIVATE ${app_sources})
-
-# For setenv() and unsetenv()
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-# For getenv_r() visibility and testing
-target_compile_definitions(app PRIVATE _BSD_SOURCE)
diff --git a/tests/posix/single_process/prj.conf b/tests/posix/single_process/prj.conf
deleted file mode 100644
index 0f709a68362..00000000000
--- a/tests/posix/single_process/prj.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ZTEST=y
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_SINGLE_PROCESS=y
-
-# Let's explicitly choose PICOLIBC, so it is used if supported even if it would not have been the
-# default (otherwise native targets default to the host C library)
-CONFIG_PICOLIBC=y
-CONFIG_COMMON_LIBC_MALLOC=y
diff --git a/tests/posix/single_process/src/confstr.c b/tests/posix/single_process/src/confstr.c
deleted file mode 100644
index f11ccf1ba89..00000000000
--- a/tests/posix/single_process/src/confstr.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-#include <zephyr/sys/util.h>
-
-ZTEST(posix_single_process, test_confstr)
-{
-	char buf[1];
-
-	/* degenerate cases */
-	{
-		struct arg {
-			int name;
-			char *buf;
-			size_t len;
-		};
-
-		const struct arg arg1s[] = {
-			{-1, NULL, 0},
-			{-1, NULL, sizeof(buf)},
-			{-1, buf, 0},
-			{-1, buf, sizeof(buf)},
-		};
-
-		const struct arg arg2s[] = {
-			{_CS_PATH, NULL, 0},
-			{_CS_PATH, buf, 0},
-		};
-
-		const struct arg arg3s[] = {
-			{_CS_PATH, NULL, sizeof(buf)},
-		};
-
-		ARRAY_FOR_EACH_PTR(arg1s, arg) {
-			errno = 0;
-			zassert_equal(0, confstr(arg->name, arg->buf, arg->len));
-			zassert_equal(errno, EINVAL);
-		}
-
-		ARRAY_FOR_EACH_PTR(arg2s, arg) {
-			errno = 0;
-			buf[0] = 0xff;
-			zassert_true(confstr(arg->name, arg->buf, arg->len) > 0);
-			zassert_equal(errno, 0);
-			zassert_equal((uint8_t)buf[0], 0xff);
-		}
-
-		ARRAY_FOR_EACH_PTR(arg3s, arg) {
-			errno = 0;
-			zassert_true(confstr(arg->name, arg->buf, arg->len) > 0);
-			zassert_equal(errno, 0);
-		}
-	}
-
-	buf[0] = 0xff;
-	zassert_true(confstr(_CS_PATH, buf, sizeof(buf) > 0));
-	zassert_equal(buf[0], '\0');
-}
diff --git a/tests/posix/single_process/src/env.c b/tests/posix/single_process/src/env.c
deleted file mode 100644
index ebe19b75228..00000000000
--- a/tests/posix/single_process/src/env.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <zephyr/ztest.h>
-
-#define M_HOME "/home/zephyr"
-#define M_UID  "1000"
-#define M_PWD  "/tmp"
-
-#define _m_alt_home "/this/path/is/much/longer/than" M_HOME
-
-#define DEFINE_ENVIRON(_handle, _key, _val) char _handle[] = _key "=" _val
-#define RESET_ENVIRON(_handle, _key, _val)                                                         \
-	snprintf(_handle, ARRAY_SIZE(_handle), "%s=%s", _key, _val)
-
-#if defined(CONFIG_NEWLIB_LIBC) || defined(CONFIG_PICOLIBC)
-/* newlib headers seem to be missing this */
-int getenv_r(const char *name, char *val, size_t len);
-#endif
-
-extern char **environ;
-static char **old_environ;
-
-static DEFINE_ENVIRON(home, "HOME", M_HOME);
-static DEFINE_ENVIRON(uid, "UID", M_UID);
-static DEFINE_ENVIRON(pwd, "PWD", M_PWD);
-
-static char *environ_for_test[] = {home, uid, pwd, NULL};
-
-ZTEST(posix_single_process, test_getenv)
-{
-	zassert_equal(getenv(NULL), NULL);
-	zassert_equal(getenv(""), NULL);
-	zassert_equal(getenv("invalid=key"), NULL);
-	zassert_equal(getenv("HOME=" M_HOME), NULL);
-	zassert_equal(getenv("PWDR"), NULL);
-
-	zassert_mem_equal(getenv("HOME"), M_HOME, strlen(M_HOME) + 1);
-	zassert_mem_equal(getenv("UID"), M_UID, strlen(M_UID) + 1);
-	zassert_mem_equal(getenv("PWD"), M_PWD, strlen(M_PWD) + 1);
-}
-
-ZTEST(posix_single_process, test_getenv_r)
-{
-	static char buf[16];
-	static const int exp_errno[] = {
-		EINVAL, EINVAL, EINVAL, EINVAL, ENOENT, ENOENT, ENOENT, EINVAL, EINVAL, EINVAL,
-	};
-	static const struct args_s {
-		const char *name;
-		char *buf;
-		size_t size;
-	} args[] = {
-		/* invalid input */
-		{NULL, NULL, 0},
-		{NULL, NULL, 42},
-		{NULL, buf, 0},
-		{NULL, buf, sizeof(buf)},
-		{"hello", NULL, 0},
-		{"hello", NULL, 42},
-		{"hello", buf, 0},
-
-		/* invalid names */
-		{"", buf, sizeof(buf)},
-		{"invalid=key", buf, sizeof(buf)},
-		{"HOME=", buf, sizeof(buf)},
-	};
-
-	BUILD_ASSERT(ARRAY_SIZE(exp_errno) == ARRAY_SIZE(args));
-
-	ARRAY_FOR_EACH(args, i) {
-		errno = 0;
-		zassert_equal(getenv_r(args[i].name, args[i].buf, args[i].size), -1,
-			      "getenv_r(\"%s\", %p, %zu): expected to fail", args[i].name,
-			      args[i].buf, args[i].size);
-		zassert_equal(errno, exp_errno[i],
-			      "getenv_r(\"%s\", %p, %zu): act_errno: %d exp_errno: %d",
-			      args[i].name, args[i].buf, args[i].size, errno, exp_errno[i]);
-	}
-
-	zassert_mem_equal(getenv("HOME"), M_HOME, strlen(M_HOME) + 1);
-	zassert_mem_equal(getenv("UID"), M_UID, strlen(M_UID) + 1);
-	zassert_mem_equal(getenv("PWD"), M_PWD, strlen(M_PWD) + 1);
-}
-
-ZTEST(posix_single_process, test_setenv)
-{
-	zassert_equal(setenv(NULL, NULL, 0), -1);
-	zassert_equal(errno, EINVAL);
-
-	/*
-	 * bug in picolibc / newlib
-	 * https://github.com/picolibc/picolibc/issues/648
-	 */
-	zassert_equal(setenv("", "42", 0), -1);
-	zassert_equal(errno, EINVAL);
-
-	zassert_equal(setenv("invalid=key", "42", 0), -1);
-	zassert_equal(errno, EINVAL);
-
-	/* do not overwrite if environ[key] exists */
-	zassert_ok(setenv("HOME", "/root", 0));
-	zassert_mem_equal(getenv("HOME"), M_HOME, strlen(M_HOME) + 1);
-
-	/* should overwrite (without malloc) */
-	zassert_ok(setenv("HOME", "/root", 1));
-	zassert_mem_equal(getenv("HOME"), "/root", strlen("/root") + 1);
-}
-
-ZTEST(posix_single_process, test_unsetenv)
-{
-	/* not hardened / application should fault */
-	zassert_equal(unsetenv(NULL), -1);
-	zassert_equal(errno, EINVAL);
-
-	errno = 0;
-	/* bug in picolibc / newlib */
-	zassert_equal(unsetenv(""), -1);
-	zassert_equal(errno, EINVAL);
-
-	zassert_equal(unsetenv("invalid=key"), -1);
-	zassert_equal(errno, EINVAL);
-
-	/* restore original environ */
-	environ = old_environ;
-	/* should overwrite (requires realloc) */
-	zassert_ok(setenv("HOME", _m_alt_home, 1));
-	zassert_mem_equal(getenv("HOME"), _m_alt_home, strlen(_m_alt_home) + 1);
-	zassert_ok(unsetenv("HOME"));
-	zassert_is_null(getenv("HOME"));
-}
-
-ZTEST(posix_single_process, test_watertight)
-{
-	extern size_t posix_env_get_allocated_space(void);
-
-	char buf[4];
-
-	/* restore original environ, which should support realloc, free, etc */
-	environ = old_environ;
-
-	for (int i = 0; i < 256; ++i) {
-		snprintf(buf, sizeof(buf), "%u", i);
-		zassert_ok(setenv("COUNTER", buf, 1));
-		zassert_mem_equal(getenv("COUNTER"), buf, strlen(buf));
-		zassert_ok(getenv_r("COUNTER", buf, sizeof(buf)));
-		zassert_equal(atoi(buf), i);
-		zassert_ok(unsetenv("COUNTER"));
-	}
-
-	zassert_equal(posix_env_get_allocated_space(), 0);
-}
-
-void test_env_before(void)
-{
-	old_environ = environ;
-
-	RESET_ENVIRON(home, "HOME", M_HOME);
-	RESET_ENVIRON(uid, "UID", M_UID);
-	RESET_ENVIRON(pwd, "PWD", M_PWD);
-	environ_for_test[0] = home;
-	environ_for_test[1] = uid;
-	environ_for_test[2] = pwd;
-
-	zassert_equal((environ = environ_for_test), environ_for_test);
-}
-
-void test_env_after(void)
-{
-	environ = old_environ;
-}
diff --git a/tests/posix/single_process/src/main.c b/tests/posix/single_process/src/main.c
deleted file mode 100644
index c3384de6048..00000000000
--- a/tests/posix/single_process/src/main.c
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- * Copyright (c) 2024, Marvin Ouma <pancakesdeath@protonmail.com>
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-void test_env_before(void);
-void test_env_after(void);
-
-static void before(void *arg)
-{
-	test_env_before();
-}
-
-static void after(void *arg)
-{
-	test_env_after();
-}
-
-ZTEST_SUITE(posix_single_process, NULL, NULL, before, after, NULL);
diff --git a/tests/posix/single_process/src/sysconf.c b/tests/posix/single_process/src/sysconf.c
deleted file mode 100644
index c129734ffee..00000000000
--- a/tests/posix/single_process/src/sysconf.c
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- * Copyright (c) 2024, Adam Wojasinski <awojasinski@baylibre.com>
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-#include <unistd.h>
-
-ZTEST(posix_single_process, test_posix_sysconf)
-{
-	long ret;
-
-	/* SC that's implemented */
-	ret = sysconf(_SC_VERSION);
-	zassert_equal(ret, _POSIX_VERSION, "sysconf returned unexpected value %ld", ret);
-
-	/* SC that's not implemented */
-	ret = sysconf(_SC_ADVISORY_INFO);
-	zassert_equal(ret, -1, "sysconf returned unexpected value %ld", ret);
-
-	/* SC that value depends on target's configuration */
-	ret = sysconf(_SC_SEMAPHORES);
-	if (IS_ENABLED(CONFIG_POSIX_THREADS)) {
-		zassert_equal(ret, _POSIX_VERSION, "sysconf returned unexpected value %ld", ret);
-	} else {
-		zassert_equal(ret, -1L, "sysconf returned unexpected value %ld", ret);
-	}
-}
diff --git a/tests/posix/single_process/src/uname.c b/tests/posix/single_process/src/uname.c
deleted file mode 100644
index 35171981d93..00000000000
--- a/tests/posix/single_process/src/uname.c
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (c) 2023 meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <sys/utsname.h>
-#include <unistd.h>
-#include <zephyr/ztest.h>
-
-ZTEST(posix_single_process, test_uname)
-{
-	struct utsname info;
-
-	zassert_ok(uname(&info));
-	zassert_ok(strncmp(info.sysname, "Zephyr", sizeof(info.sysname)));
-	zassert_ok(strncmp(info.machine, CONFIG_ARCH, sizeof(info.machine)));
-}
diff --git a/tests/posix/single_process/testcase.yaml b/tests/posix/single_process/testcase.yaml
deleted file mode 100644
index e4d31eaa3e3..00000000000
--- a/tests/posix/single_process/testcase.yaml
+++ /dev/null
@@ -1,38 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - single_process
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_riscv64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.single_process:
-    extra_configs:
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.posix.single_process.armclang_std_libc:
-    toolchain_allow: armclang
-    extra_configs:
-      - CONFIG_ARMCLANG_STD_LIBC=y
-  portability.posix.single_process.arcmwdtlib:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_ARCMWDT_LIBC=y
-  portability.posix.single_process.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.posix.single_process.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.single_process.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/spinlocks/CMakeLists.txt b/tests/posix/spinlocks/CMakeLists.txt
deleted file mode 100644
index 66006e8c52f..00000000000
--- a/tests/posix/spinlocks/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_spinlocks)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/spinlocks/prj.conf b/tests/posix/spinlocks/prj.conf
deleted file mode 100644
index 5858c68f176..00000000000
--- a/tests/posix/spinlocks/prj.conf
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_SPIN_LOCKS=y
diff --git a/tests/posix/spinlocks/src/main.c b/tests/posix/spinlocks/src/main.c
deleted file mode 100644
index 40ac2de3900..00000000000
--- a/tests/posix/spinlocks/src/main.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-
-#include <zephyr/ztest.h>
-#include <zephyr/sys/util.h>
-
-ZTEST(posix_spinlocks, test_spin_init_destroy)
-{
-	pthread_spinlock_t lock;
-
-	zassert_equal(pthread_spin_init(NULL, PTHREAD_PROCESS_PRIVATE), EINVAL,
-		      "pthread_spin_init() did not return EINVAL with NULL lock pointer");
-	zassert_equal(pthread_spin_init(&lock, 42), EINVAL,
-		      "pthread_spin_init() did not return EINVAL with invalid pshared");
-	zassert_equal(pthread_spin_destroy(NULL), EINVAL,
-		      "pthread_spin_destroy() did not return EINVAL with NULL lock pointer");
-
-	zassert_ok(pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE), "pthread_spin_init() failed");
-	zassert_ok(pthread_spin_destroy(&lock), "pthread_spin_destroy() failed");
-}
-
-ZTEST(posix_spinlocks, test_spin_descriptor_leak)
-{
-	pthread_spinlock_t lock[CONFIG_MAX_PTHREAD_SPINLOCK_COUNT];
-
-	for (size_t j = 0; j < 2; ++j) {
-		for (size_t i = 0; i < ARRAY_SIZE(lock); ++i) {
-			zassert_ok(pthread_spin_init(&lock[i], PTHREAD_PROCESS_PRIVATE),
-				   "failed to initialize spinlock %zu (rep %zu)", i, j);
-		}
-
-		zassert_equal(pthread_spin_init(&lock[CONFIG_MAX_PTHREAD_SPINLOCK_COUNT],
-						PTHREAD_PROCESS_PRIVATE),
-			      ENOMEM,
-			      "should not be able to initialize more than "
-			      "CONFIG_MAX_PTHREAD_SPINLOCK_COUNT spinlocks");
-
-		for (size_t i = 0; i < ARRAY_SIZE(lock); ++i) {
-			zassert_ok(pthread_spin_destroy(&lock[i]),
-				   "failed to destroy spinlock %zu (rep %zu)", i, j);
-		}
-	}
-}
-
-ZTEST(posix_spinlocks, test_spin_lock_unlock)
-{
-	pthread_spinlock_t lock;
-
-	zassert_equal(pthread_spin_lock(NULL), EINVAL,
-		      "pthread_spin_lock() did not return EINVAL with NULL lock pointer");
-	zassert_equal(pthread_spin_trylock(NULL), EINVAL,
-		      "pthread_spin_lock() did not return EINVAL with NULL lock pointer");
-	zassert_equal(pthread_spin_unlock(NULL), EINVAL,
-		      "pthread_spin_lock() did not return EINVAL with NULL lock pointer");
-
-	zassert_ok(pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE), "pthread_spin_init() failed");
-
-	zassert_ok(pthread_spin_lock(&lock), "pthread_spin_lock() failed");
-	zassert_ok(pthread_spin_unlock(&lock), "pthread_spin_lock() failed");
-
-	zassert_ok(pthread_spin_trylock(&lock), "pthread_spin_trylock() failed");
-	zassert_ok(pthread_spin_unlock(&lock), "pthread_spin_unlock() failed");
-
-	zassert_ok(pthread_spin_destroy(&lock), "pthread_spin_init() failed");
-	zassert_equal(pthread_spin_destroy(&lock), EINVAL, "pthread_spin_unlock() did not fail");
-}
-
-ZTEST_SUITE(posix_spinlocks, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/spinlocks/testcase.yaml b/tests/posix/spinlocks/testcase.yaml
deleted file mode 100644
index 4729a0c7a6e..00000000000
--- a/tests/posix/spinlocks/testcase.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - spinlocks
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_x86_64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.spinlocks: {}
-  portability.posix.spinlocks.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.spinlocks.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.spinlocks.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
-  portability.posix.spinlocks.no_spin_validate:
-    extra_configs:
-      - CONFIG_SPIN_VALIDATE=n
diff --git a/tests/posix/threads_ext/CMakeLists.txt b/tests/posix/threads_ext/CMakeLists.txt
deleted file mode 100644
index 2c3e19d4647..00000000000
--- a/tests/posix/threads_ext/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_threads_ext)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
diff --git a/tests/posix/threads_ext/prj.conf b/tests/posix/threads_ext/prj.conf
deleted file mode 100644
index a99c02d5935..00000000000
--- a/tests/posix/threads_ext/prj.conf
+++ /dev/null
@@ -1,3 +0,0 @@
-CONFIG_ZTEST=y
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_THREADS_EXT=y
diff --git a/tests/posix/threads_ext/src/main.c b/tests/posix/threads_ext/src/main.c
deleted file mode 100644
index 501a424c1ca..00000000000
--- a/tests/posix/threads_ext/src/main.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define BIOS_FOOD           0xB105F00D
-#define SCHED_INVALID       4242
-#define INVALID_DETACHSTATE 7373
-
-static bool attr_valid;
-static pthread_attr_t attr;
-static const pthread_attr_t uninit_attr;
-
-ZTEST(posix_threads_ext, test_pthread_attr_getguardsize)
-{
-	size_t guardsize;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getguardsize(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getguardsize(NULL, &guardsize), EINVAL);
-			zassert_equal(pthread_attr_getguardsize(&uninit_attr, &guardsize), EINVAL);
-		}
-		zassert_equal(pthread_attr_getguardsize(&attr, NULL), EINVAL);
-	}
-
-	guardsize = BIOS_FOOD;
-	zassert_ok(pthread_attr_getguardsize(&attr, &guardsize));
-	zassert_not_equal(guardsize, BIOS_FOOD);
-}
-
-ZTEST(posix_threads_ext, test_pthread_attr_setguardsize)
-{
-	size_t guardsize = CONFIG_POSIX_PTHREAD_ATTR_GUARDSIZE_DEFAULT;
-	size_t sizes[] = {0, BIT_MASK(CONFIG_POSIX_PTHREAD_ATTR_GUARDSIZE_BITS / 2),
-			  BIT_MASK(CONFIG_POSIX_PTHREAD_ATTR_GUARDSIZE_BITS)};
-
-	/* valid value */
-	zassert_ok(pthread_attr_getguardsize(&attr, &guardsize));
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setguardsize(NULL, SIZE_MAX), EINVAL);
-			zassert_equal(pthread_attr_setguardsize(NULL, guardsize), EINVAL);
-			zassert_equal(pthread_attr_setguardsize((pthread_attr_t *)&uninit_attr,
-								guardsize),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_setguardsize(&attr, SIZE_MAX), EINVAL);
-	}
-
-	ARRAY_FOR_EACH(sizes, i) {
-		zassert_ok(pthread_attr_setguardsize(&attr, sizes[i]));
-		guardsize = ~sizes[i];
-		zassert_ok(pthread_attr_getguardsize(&attr, &guardsize));
-		zassert_equal(guardsize, sizes[i]);
-	}
-}
-
-ZTEST(posix_threads_ext, test_pthread_mutexattr_gettype)
-{
-	int type;
-	pthread_mutexattr_t attr;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(EINVAL, pthread_mutexattr_gettype(&attr, &type));
-		}
-		zassert_equal(EINVAL, pthread_mutexattr_gettype(NULL, NULL));
-		zassert_equal(EINVAL, pthread_mutexattr_gettype(NULL, &type));
-		zassert_equal(EINVAL, pthread_mutexattr_gettype(&attr, NULL));
-	}
-
-	zassert_ok(pthread_mutexattr_init(&attr));
-	zassert_ok(pthread_mutexattr_gettype(&attr, &type));
-	zassert_equal(type, PTHREAD_MUTEX_DEFAULT);
-	zassert_ok(pthread_mutexattr_destroy(&attr));
-}
-
-ZTEST(posix_threads_ext, test_pthread_mutexattr_settype)
-{
-	int type;
-	pthread_mutexattr_t attr;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(EINVAL,
-				      pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT));
-		}
-		zassert_equal(EINVAL, pthread_mutexattr_settype(NULL, 42));
-		zassert_equal(EINVAL, pthread_mutexattr_settype(NULL, PTHREAD_MUTEX_NORMAL));
-		zassert_equal(EINVAL, pthread_mutexattr_settype(&attr, 42));
-	}
-
-	zassert_ok(pthread_mutexattr_init(&attr));
-
-	zassert_ok(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT));
-	zassert_ok(pthread_mutexattr_gettype(&attr, &type));
-	zassert_equal(type, PTHREAD_MUTEX_DEFAULT);
-
-	zassert_ok(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL));
-	zassert_ok(pthread_mutexattr_gettype(&attr, &type));
-	zassert_equal(type, PTHREAD_MUTEX_NORMAL);
-
-	zassert_ok(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE));
-	zassert_ok(pthread_mutexattr_gettype(&attr, &type));
-	zassert_equal(type, PTHREAD_MUTEX_RECURSIVE);
-
-	zassert_ok(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK));
-	zassert_ok(pthread_mutexattr_gettype(&attr, &type));
-	zassert_equal(type, PTHREAD_MUTEX_ERRORCHECK);
-
-	zassert_ok(pthread_mutexattr_destroy(&attr));
-}
-
-static void before(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	zassert_ok(pthread_attr_init(&attr));
-	attr_valid = true;
-}
-
-static void after(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	if (attr_valid) {
-		(void)pthread_attr_destroy(&attr);
-		attr_valid = false;
-	}
-}
-
-ZTEST_SUITE(posix_threads_ext, NULL, NULL, before, after, NULL);
diff --git a/tests/posix/threads_ext/testcase.yaml b/tests/posix/threads_ext/testcase.yaml
deleted file mode 100644
index c1387f17840..00000000000
--- a/tests/posix/threads_ext/testcase.yaml
+++ /dev/null
@@ -1,25 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - threads_ext
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.threads_ext: {}
-  portability.posix.threads_ext.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.threads_ext.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.threads_ext.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/timers/CMakeLists.txt b/tests/posix/timers/CMakeLists.txt
deleted file mode 100644
index b6fd64d6c28..00000000000
--- a/tests/posix/timers/CMakeLists.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_timers)
-
-FILE(GLOB app_sources src/*.c)
-
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
-target_include_directories(app PRIVATE ${ZEPHYR_BASE}/lib/posix/options)
diff --git a/tests/posix/timers/Kconfig b/tests/posix/timers/Kconfig
deleted file mode 100644
index 18b0b82daee..00000000000
--- a/tests/posix/timers/Kconfig
+++ /dev/null
@@ -1,27 +0,0 @@
-# Copyright (c) 2023, Meta
-# SPDX-License-Identifier: Apache-2.0
-
-# Options specific to clock.c / test_realtime
-
-config TEST_CLOCK_RT_ITERATIONS
-	int "Number of iterations to check clock_gettime() reliability"
-	range 10 100
-	default 20
-	help
-	  This option is specific to posix_apis.test_realtime in clock.c
-
-config TEST_CLOCK_RT_SLEEP_MS
-	int "Time to sleep between iterations in milliseconds"
-	range 50 1000
-	default 100
-	help
-	  This option is specific to posix_apis.test_realtime in clock.c
-
-config TEST_CLOCK_RT_ERROR_MS
-	int "Maximum overshoot (error) in milliseconds"
-	range 10 500
-	default 10
-	help
-	  This option is specific to posix_apis.test_realtime in clock.c
-
-source "Kconfig.zephyr"
diff --git a/tests/posix/timers/prj.conf b/tests/posix/timers/prj.conf
deleted file mode 100644
index 1ce3e4c520e..00000000000
--- a/tests/posix/timers/prj.conf
+++ /dev/null
@@ -1,9 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_POSIX_TIMERS=y
-
-# Needed for timer_create() when using SIGEV_THREAD
-CONFIG_DYNAMIC_THREAD=y
-CONFIG_DYNAMIC_THREAD_POOL_SIZE=1
-CONFIG_THREAD_STACK_INFO=y
diff --git a/tests/posix/timers/src/clock.c b/tests/posix/timers/src/clock.c
deleted file mode 100644
index 112196bb1e3..00000000000
--- a/tests/posix/timers/src/clock.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-/* for tp_ge(), tp_diff() */
-#include "posix_clock.h"
-
-#include <sys/time.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-#include <zephyr/logging/log.h>
-
-#define SLEEP_SECONDS 1
-#define CLOCK_INVALID -1
-
-LOG_MODULE_REGISTER(clock_test, LOG_LEVEL_DBG);
-
-/* Set a particular time.  In this case, the output of: `date +%s -d 2018-01-01T15:45:01Z` */
-static const struct timespec ref_ts = {1514821501, NSEC_PER_SEC / 2U};
-
-static const clockid_t clocks[] = {
-#if defined(_POSIX_MONOTONIC_CLOCK)
-	CLOCK_MONOTONIC,
-#endif
-	CLOCK_REALTIME,
-};
-
-static const bool settable[] = {
-	false,
-	true,
-};
-
-ZTEST(posix_timers, test_clock_gettime)
-{
-	struct timespec ts;
-
-	/* ensure argument validation is performed */
-	errno = 0;
-	zassert_equal(clock_gettime(CLOCK_INVALID, &ts), -1);
-	zassert_equal(errno, EINVAL);
-
-	if (false) {
-		/* undefined behaviour */
-		errno = 0;
-		zassert_equal(clock_gettime(clocks[0], NULL), -1);
-		zassert_equal(errno, EINVAL);
-	}
-
-	/* verify that we can call clock_gettime() on supported clocks */
-	ARRAY_FOR_EACH(clocks, i) {
-		ts = (struct timespec){-1, -1};
-		zassert_ok(clock_gettime(clocks[i], &ts));
-		zassert_not_equal(ts.tv_sec, -1);
-		zassert_not_equal(ts.tv_nsec, -1);
-	}
-}
-
-ZTEST(posix_timers, test_clock_settime)
-{
-	int64_t diff_ns;
-	struct timespec ts = {0};
-
-	BUILD_ASSERT(ARRAY_SIZE(settable) == ARRAY_SIZE(clocks));
-
-	/* ensure argument validation is performed */
-	errno = 0;
-	zassert_equal(clock_settime(CLOCK_INVALID, &ts), -1);
-	zassert_equal(errno, EINVAL);
-
-	if (false) {
-		/* undefined behaviour */
-		errno = 0;
-		zassert_equal(clock_settime(CLOCK_REALTIME, NULL), -1);
-		zassert_equal(errno, EINVAL);
-	}
-
-	/* verify nanoseconds */
-	errno = 0;
-	ts = (struct timespec){0, NSEC_PER_SEC};
-	zassert_equal(clock_settime(CLOCK_REALTIME, &ts), -1);
-	zassert_equal(errno, EINVAL);
-	errno = 0;
-	ts = (struct timespec){0, -1};
-	zassert_equal(clock_settime(CLOCK_REALTIME, &ts), -1);
-	zassert_equal(errno, EINVAL);
-
-	ARRAY_FOR_EACH(clocks, i) {
-		if (!settable[i]) {
-			/* should fail attempting to set unsettable clocks */
-			errno = 0;
-			zassert_equal(clock_settime(clocks[i], &ts), -1);
-			zassert_equal(errno, EINVAL);
-			continue;
-		}
-
-		zassert_ok(clock_settime(clocks[i], &ref_ts));
-
-		/* read-back the time */
-		zassert_ok(clock_gettime(clocks[i], &ts));
-		/* dt should be >= 0, but definitely <= 1s */
-		diff_ns = tp_diff(&ts, &ref_ts);
-		zassert_true(diff_ns >= 0 && diff_ns <= NSEC_PER_SEC);
-	}
-}
-
-ZTEST(posix_timers, test_realtime)
-{
-	struct timespec then, now;
-	/*
-	 * For calculating cumulative moving average
-	 * Note: we do not want to assert any individual samples due to scheduler noise.
-	 * The CMA filters out the noise so we can make an assertion (on average).
-	 * https://en.wikipedia.org/wiki/Moving_average#Cumulative_moving_average
-	 */
-	int64_t cma_prev = 0;
-	int64_t cma;
-	int64_t x_i;
-	/* lower and uppoer boundary for assertion */
-	int64_t lo = CONFIG_TEST_CLOCK_RT_SLEEP_MS;
-	int64_t hi = CONFIG_TEST_CLOCK_RT_SLEEP_MS + CONFIG_TEST_CLOCK_RT_ERROR_MS;
-	/* lower and upper watermark */
-	int64_t lo_wm = INT64_MAX;
-	int64_t hi_wm = INT64_MIN;
-
-	/* Loop n times, sleeping a little bit for each */
-	(void)clock_gettime(CLOCK_REALTIME, &then);
-	for (int i = 0; i < CONFIG_TEST_CLOCK_RT_ITERATIONS; ++i) {
-
-		zassert_ok(k_usleep(USEC_PER_MSEC * CONFIG_TEST_CLOCK_RT_SLEEP_MS));
-		(void)clock_gettime(CLOCK_REALTIME, &now);
-
-		/* Make the delta milliseconds. */
-		x_i = tp_diff(&now, &then) / NSEC_PER_MSEC;
-		then = now;
-
-		if (x_i < lo_wm) {
-			/* update low watermark */
-			lo_wm = x_i;
-		}
-
-		if (x_i > hi_wm) {
-			/* update high watermark */
-			hi_wm = x_i;
-		}
-
-		/* compute cumulative running average */
-		cma = (x_i + i * cma_prev) / (i + 1);
-		cma_prev = cma;
-	}
-
-	LOG_INF("n: %d, sleep: %d, margin: %d, lo: %lld, avg: %lld, hi: %lld",
-		CONFIG_TEST_CLOCK_RT_ITERATIONS, CONFIG_TEST_CLOCK_RT_SLEEP_MS,
-		CONFIG_TEST_CLOCK_RT_ERROR_MS, lo_wm, cma, hi_wm);
-	zassert_between_inclusive(cma, lo, hi);
-}
-
-ZTEST(posix_timers, test_clock_getcpuclockid)
-{
-	int ret = 0;
-	clockid_t clock_id = CLOCK_INVALID;
-
-	ret = clock_getcpuclockid((pid_t)0, &clock_id);
-	zassert_equal(ret, 0, "POSIX clock_getcpuclock id failed");
-	zassert_equal(clock_id, CLOCK_PROCESS_CPUTIME_ID, "POSIX clock_getcpuclock id failed");
-
-	ret = clock_getcpuclockid((pid_t)2482, &clock_id);
-	zassert_equal(ret, EPERM, "POSIX clock_getcpuclock id failed");
-}
-
-ZTEST(posix_timers, test_clock_getres)
-{
-	int ret;
-	struct timespec res;
-	const struct timespec one_ns = {
-		.tv_sec = 0,
-		.tv_nsec = 1,
-	};
-
-	struct arg {
-		clockid_t clock_id;
-		struct timespec *res;
-		int expect;
-	};
-
-	const struct arg args[] = {
-		/* permuting over "invalid" inputs */
-		{CLOCK_INVALID, NULL, -1},
-		{CLOCK_INVALID, &res, -1},
-		{CLOCK_REALTIME, NULL, 0},
-		{CLOCK_MONOTONIC, NULL, 0},
-		{CLOCK_PROCESS_CPUTIME_ID, NULL, 0},
-
-		/* all valid inputs */
-		{CLOCK_REALTIME, &res, 0},
-		{CLOCK_MONOTONIC, &res, 0},
-		{CLOCK_PROCESS_CPUTIME_ID, &res, 0},
-	};
-
-	ARRAY_FOR_EACH_PTR(args, arg) {
-		errno = 0;
-		res = (struct timespec){0};
-		ret = clock_getres(arg->clock_id, arg->res);
-		zassert_equal(ret, arg->expect);
-		if (ret != 0) {
-			zassert_equal(errno, EINVAL);
-			continue;
-		}
-		if (arg->res != NULL) {
-			zassert_true(tp_ge(arg->res, &one_ns));
-		}
-	}
-}
diff --git a/tests/posix/timers/src/nanosleep.c b/tests/posix/timers/src/nanosleep.c
deleted file mode 100644
index 98542ab5bc9..00000000000
--- a/tests/posix/timers/src/nanosleep.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (c) 2018 Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stdint.h>
-#include <time.h>
-
-#include <zephyr/sys_clock.h>
-#include <zephyr/ztest.h>
-
-#define SELECT_NANOSLEEP       1
-#define SELECT_CLOCK_NANOSLEEP 0
-
-void common_lower_bound_check(int selection, clockid_t clock_id, int flags, const uint32_t s,
-			      uint32_t ns);
-int select_nanosleep(int selection, clockid_t clock_id, int flags, const struct timespec *rqtp,
-		     struct timespec *rmtp);
-
-static void common_errors(int selection, clockid_t clock_id, int flags)
-{
-	struct timespec rem = {};
-	struct timespec req = {};
-
-	/*
-	 * invalid parameters
-	 */
-	zassert_equal(select_nanosleep(selection, clock_id, flags, NULL, NULL), -1);
-	zassert_equal(errno, EFAULT);
-
-	/* NULL request */
-	errno = 0;
-	zassert_equal(select_nanosleep(selection, clock_id, flags, NULL, &rem), -1);
-	zassert_equal(errno, EFAULT);
-	/* Expect rem to be the same when function returns */
-	zassert_equal(rem.tv_sec, 0, "actual: %d expected: %d", (int)rem.tv_sec, 0);
-	zassert_equal(rem.tv_nsec, 0, "actual: %d expected: %d", (int)rem.tv_nsec, 0);
-
-	/* negative times */
-	errno = 0;
-	req = (struct timespec){.tv_sec = -1, .tv_nsec = 0};
-	zassert_equal(select_nanosleep(selection, clock_id, flags, &req, NULL), -1);
-	zassert_equal(errno, EINVAL);
-
-	errno = 0;
-	req = (struct timespec){.tv_sec = 0, .tv_nsec = -1};
-	zassert_equal(select_nanosleep(selection, clock_id, flags, &req, NULL), -1);
-	zassert_equal(errno, EINVAL);
-
-	errno = 0;
-	req = (struct timespec){.tv_sec = -1, .tv_nsec = -1};
-	zassert_equal(select_nanosleep(selection, clock_id, flags, &req, NULL), -1);
-	zassert_equal(errno, EINVAL);
-
-	/* nanoseconds too high */
-	errno = 0;
-	req = (struct timespec){.tv_sec = 0, .tv_nsec = 1000000000};
-	zassert_equal(select_nanosleep(selection, clock_id, flags, &req, NULL), -1);
-	zassert_equal(errno, EINVAL);
-
-	/*
-	 * Valid parameters
-	 */
-	errno = 0;
-
-	/* Happy path, plus make sure the const input is unmodified */
-	req = (struct timespec){.tv_sec = 1, .tv_nsec = 1};
-	zassert_equal(select_nanosleep(selection, clock_id, flags, &req, NULL), 0);
-	zassert_equal(errno, 0);
-	zassert_equal(req.tv_sec, 1);
-	zassert_equal(req.tv_nsec, 1);
-
-	/* Sleep for 0.0 s. Expect req & rem to be the same when function returns */
-	zassert_equal(select_nanosleep(selection, clock_id, flags, &req, &rem), 0);
-	zassert_equal(errno, 0);
-	zassert_equal(rem.tv_sec, 0, "actual: %d expected: %d", (int)rem.tv_sec, 0);
-	zassert_equal(rem.tv_nsec, 0, "actual: %d expected: %d", (int)rem.tv_nsec, 0);
-
-	/*
-	 * req and rem point to the same timespec
-	 *
-	 * Normative spec says they may be the same.
-	 * Expect rem to be zero after returning.
-	 */
-	req = (struct timespec){.tv_sec = 0, .tv_nsec = 1};
-	zassert_equal(select_nanosleep(selection, clock_id, flags, &req, &req), 0);
-	zassert_equal(errno, 0);
-	zassert_equal(req.tv_sec, 0, "actual: %d expected: %d", (int)req.tv_sec, 0);
-	zassert_equal(req.tv_nsec, 0, "actual: %d expected: %d", (int)req.tv_nsec, 0);
-}
-
-ZTEST(posix_timers, test_nanosleep_errors_errno)
-{
-	common_errors(SELECT_NANOSLEEP, CLOCK_REALTIME, 0);
-}
-
-ZTEST(posix_timers, test_clock_nanosleep_errors_errno)
-{
-	struct timespec rem = {};
-	struct timespec req = {};
-
-	common_errors(SELECT_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, TIMER_ABSTIME);
-
-	/* Absolute timeout in the past. */
-	clock_gettime(CLOCK_MONOTONIC, &req);
-	zassert_equal(clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &req, &rem), 0);
-	zassert_equal(rem.tv_sec, 0, "actual: %d expected: %d", (int)rem.tv_sec, 0);
-	zassert_equal(rem.tv_nsec, 0, "actual: %d expected: %d", (int)rem.tv_nsec, 0);
-
-	/* Absolute timeout in the past relative to the realtime clock. */
-	clock_gettime(CLOCK_REALTIME, &req);
-	zassert_equal(clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &req, &rem), 0);
-	zassert_equal(rem.tv_sec, 0, "actual: %d expected: %d", (int)rem.tv_sec, 0);
-	zassert_equal(rem.tv_nsec, 0, "actual: %d expected: %d", (int)rem.tv_nsec, 0);
-}
-
-ZTEST(posix_timers, test_nanosleep_execution)
-{
-	/* sleep for 1ns */
-	common_lower_bound_check(SELECT_NANOSLEEP, 0, 0, 0, 1);
-
-	/* sleep for 1us + 1ns */
-	common_lower_bound_check(SELECT_NANOSLEEP, 0, 0, 0, 1001);
-
-	/* sleep for 500000000ns */
-	common_lower_bound_check(SELECT_NANOSLEEP, 0, 0, 0, 500000000);
-
-	/* sleep for 1s */
-	common_lower_bound_check(SELECT_NANOSLEEP, 0, 0, 1, 0);
-
-	/* sleep for 1s + 1ns */
-	common_lower_bound_check(SELECT_NANOSLEEP, 0, 0, 1, 1);
-
-	/* sleep for 1s + 1us + 1ns */
-	common_lower_bound_check(SELECT_NANOSLEEP, 0, 0, 1, 1001);
-}
diff --git a/tests/posix/timers/src/nanosleep_common.c b/tests/posix/timers/src/nanosleep_common.c
deleted file mode 100644
index 1b3d70a682d..00000000000
--- a/tests/posix/timers/src/nanosleep_common.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (c) 2018 Friedt Professional Engineering Services, Inc
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <errno.h>
-#include <stdint.h>
-#include <time.h>
-
-#include <zephyr/sys_clock.h>
-#include <zephyr/ztest.h>
-
-#define SELECT_NANOSLEEP       1
-#define SELECT_CLOCK_NANOSLEEP 0
-
-static inline uint64_t cycle_get_64(void)
-{
-	if (IS_ENABLED(CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER)) {
-		return k_cycle_get_64();
-	} else {
-		return k_cycle_get_32();
-	}
-}
-
-int select_nanosleep(int selection, clockid_t clock_id, int flags, const struct timespec *rqtp,
-		     struct timespec *rmtp)
-{
-	if (selection == SELECT_NANOSLEEP) {
-		return nanosleep(rqtp, rmtp);
-	}
-	return clock_nanosleep(clock_id, flags, rqtp, rmtp);
-}
-
-/**
- * @brief Check that a call to nanosleep has yielded execution for some minimum time.
- *
- * Check that the actual time slept is >= the total time specified by @p s (in seconds) and
- * @p ns (in nanoseconds).
- *
- * @note The time specified by @p s and @p ns is assumed to be absolute (i.e. a time-point)
- * when @p selection is set to @ref SELECT_CLOCK_NANOSLEEP. The time is assumed to be relative
- * when @p selection is set to @ref SELECT_NANOSLEEP.
- *
- * @param selection Either @ref SELECT_CLOCK_NANOSLEEP or @ref SELECT_NANOSLEEP
- * @param clock_id The clock to test (e.g. @ref CLOCK_MONOTONIC or @ref CLOCK_REALTIME)
- * @param flags Flags to pass to @ref clock_nanosleep
- * @param s Partial lower bound for yielded time (in seconds)
- * @param ns Partial lower bound for yielded time (in nanoseconds)
- */
-void common_lower_bound_check(int selection, clockid_t clock_id, int flags, const uint32_t s,
-			      uint32_t ns)
-{
-	int r;
-	uint64_t actual_ns = 0;
-	uint64_t exp_ns;
-	uint64_t now;
-	uint64_t then;
-	struct timespec rem = {0, 0};
-	struct timespec req = {s, ns};
-
-	errno = 0;
-	then = cycle_get_64();
-	r = select_nanosleep(selection, clock_id, flags, &req, &rem);
-	now = cycle_get_64();
-
-	zassert_equal(r, 0, "actual: %d expected: %d", r, 0);
-	zassert_equal(errno, 0, "actual: %d expected: %d", errno, 0);
-	zassert_equal(req.tv_sec, s, "actual: %lld expected: %d", (long long)req.tv_sec, s);
-	zassert_equal(req.tv_nsec, ns, "actual: %lld expected: %d", (long long)req.tv_nsec, ns);
-	zassert_equal(rem.tv_sec, 0, "actual: %lld expected: %d", (long long)rem.tv_sec, 0);
-	zassert_equal(rem.tv_nsec, 0, "actual: %lld expected: %d", (long long)rem.tv_nsec, 0);
-
-	switch (selection) {
-	case SELECT_NANOSLEEP:
-		/* exp_ns and actual_ns are relative (i.e. durations) */
-		actual_ns = k_cyc_to_ns_ceil64(now + then);
-		break;
-	case SELECT_CLOCK_NANOSLEEP:
-		/* exp_ns and actual_ns are absolute (i.e. time-points) */
-		actual_ns = k_cyc_to_ns_ceil64(now);
-		break;
-	default:
-		zassert_unreachable();
-		break;
-	}
-
-	exp_ns = (uint64_t)s * NSEC_PER_SEC + ns;
-	/* round up to the nearest microsecond for k_busy_wait() */
-	exp_ns = DIV_ROUND_UP(exp_ns, NSEC_PER_USEC) * NSEC_PER_USEC;
-
-/* The comparison may be incorrect if counter wrap happened. In case of ARC HSDK platforms
- * we have high counter clock frequency (500MHz or 1GHz) so counter wrap quite likely to
- * happen if we wait long enough. As in some test cases we wait more than 1 second, there
- * are significant chances to get false-positive assertion.
- * TODO: switch test for k_cycle_get_64 usage where available.
- */
-#if !defined(CONFIG_SOC_ARC_HSDK) && !defined(CONFIG_SOC_ARC_HSDK4XD)
-	/* lower bounds check */
-	zassert_true(actual_ns >= exp_ns, "actual: %llu expected: %llu", actual_ns, exp_ns);
-#endif
-
-	/* TODO: Upper bounds check when hr timers are available */
-}
diff --git a/tests/posix/timers/src/sleep.c b/tests/posix/timers/src/sleep.c
deleted file mode 100644
index bf5ffaa07f9..00000000000
--- a/tests/posix/timers/src/sleep.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2022, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-
-struct waker_work {
-	k_tid_t tid;
-	struct k_work_delayable dwork;
-};
-static struct waker_work wake_work;
-
-static void waker_func(struct k_work *work)
-{
-	struct waker_work *ww;
-	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
-
-	ww = CONTAINER_OF(dwork, struct waker_work, dwork);
-	k_wakeup(ww->tid);
-}
-K_WORK_DELAYABLE_DEFINE(waker, waker_func);
-
-ZTEST(posix_timers, test_usleep)
-{
-	uint32_t then;
-	uint32_t now;
-
-	/* test usleep works for small values */
-	/* Note: k_usleep(), an implementation detail, is a cancellation point */
-	zassert_equal(0, usleep(0));
-	zassert_equal(0, usleep(1));
-
-	/* sleep for the spec limit */
-	then = k_uptime_get();
-	zassert_equal(0, usleep(USEC_PER_SEC - 1));
-	now = k_uptime_get();
-	zassert_true(((now - then) * USEC_PER_MSEC) / (USEC_PER_SEC - 1) >= 1);
-
-	/* sleep for exactly the limit threshold */
-	zassert_equal(-1, usleep(USEC_PER_SEC));
-	zassert_equal(errno, EINVAL);
-
-	/* sleep for over the spec limit */
-	zassert_equal(-1, usleep((useconds_t)ULONG_MAX));
-	zassert_equal(errno, EINVAL);
-
-	/* test that sleep reports errno = EINTR when woken up */
-	wake_work.tid = k_current_get();
-	k_work_init_delayable(&wake_work.dwork, waker_func);
-	zassert_equal(1, k_work_schedule(&wake_work.dwork, K_USEC(USEC_PER_SEC / 2)));
-	zassert_equal(-1, usleep(USEC_PER_SEC - 1));
-	zassert_equal(EINTR, errno);
-}
diff --git a/tests/posix/timers/src/timer.c b/tests/posix/timers/src/timer.c
deleted file mode 100644
index fc70025ebc7..00000000000
--- a/tests/posix/timers/src/timer.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <signal.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-#include <zephyr/logging/log.h>
-
-#define SECS_TO_SLEEP  2
-#define DURATION_SECS  1
-#define DURATION_NSECS 0
-#define PERIOD_SECS    0
-#define PERIOD_NSECS   100000000
-
-#define TEST_SIGNAL_VAL SIGTSTP
-
-LOG_MODULE_REGISTER(timer_test);
-
-static int exp_count;
-static timer_t timerid = -1;
-
-void handler(union sigval val)
-{
-	++exp_count;
-	LOG_DBG("Handler Signal value %d for %d times", val.sival_int, exp_count);
-	zassert_equal(val.sival_int, TEST_SIGNAL_VAL);
-}
-
-void test_timer(clockid_t clock_id, int sigev_notify)
-{
-	struct sigevent sig = {0};
-	struct itimerspec value, ovalue;
-	struct timespec ts, te;
-	int64_t nsecs_elapsed, secs_elapsed;
-
-	exp_count = 0;
-	sig.sigev_notify = sigev_notify;
-	sig.sigev_notify_function = handler;
-	sig.sigev_value.sival_int = TEST_SIGNAL_VAL;
-
-	/*TESTPOINT: Check if timer is created successfully*/
-	zassert_ok(timer_create(clock_id, &sig, &timerid));
-
-	value.it_value.tv_sec = DURATION_SECS;
-	value.it_value.tv_nsec = DURATION_NSECS;
-	value.it_interval.tv_sec = PERIOD_SECS;
-	value.it_interval.tv_nsec = PERIOD_NSECS;
-	zassert_ok(timer_settime(timerid, 0, &value, &ovalue));
-	usleep(100 * USEC_PER_MSEC);
-	/*TESTPOINT: Check if timer has started successfully*/
-	zassert_ok(timer_gettime(timerid, &value));
-
-	LOG_DBG("Timer fires every %d secs and  %d nsecs", (int)value.it_interval.tv_sec,
-		(int)value.it_interval.tv_nsec);
-	LOG_DBG("Time remaining to fire %d secs and  %d nsecs", (int)value.it_value.tv_sec,
-		(int)value.it_value.tv_nsec);
-
-	zassert_ok(clock_gettime(clock_id, &ts));
-	k_sleep(K_SECONDS(SECS_TO_SLEEP));
-	zassert_ok(clock_gettime(clock_id, &te));
-
-	if (te.tv_nsec >= ts.tv_nsec) {
-		secs_elapsed = te.tv_sec - ts.tv_sec;
-		nsecs_elapsed = te.tv_nsec - ts.tv_nsec;
-	} else {
-		nsecs_elapsed = NSEC_PER_SEC + te.tv_nsec - ts.tv_nsec;
-		secs_elapsed = (te.tv_sec - ts.tv_sec - 1);
-	}
-
-	uint64_t elapsed = secs_elapsed * NSEC_PER_SEC + nsecs_elapsed;
-	uint64_t first_sig = value.it_value.tv_sec * NSEC_PER_SEC + value.it_value.tv_nsec;
-	uint64_t sig_interval = value.it_interval.tv_sec * NSEC_PER_SEC + value.it_interval.tv_nsec;
-	int expected_signal_count = (elapsed - first_sig) / sig_interval + 1;
-
-	/*TESTPOINT: Check if POSIX timer test passed*/
-	zassert_within(exp_count, expected_signal_count, 1, "POSIX timer test has failed %i != %i",
-		       exp_count, expected_signal_count);
-}
-
-ZTEST(posix_timers, test_CLOCK_REALTIME__SIGEV_SIGNAL)
-{
-	test_timer(CLOCK_REALTIME, SIGEV_SIGNAL);
-}
-
-ZTEST(posix_timers, test_CLOCK_REALTIME__SIGEV_THREAD)
-{
-	test_timer(CLOCK_REALTIME, SIGEV_THREAD);
-}
-
-ZTEST(posix_timers, test_CLOCK_MONOTONIC__SIGEV_SIGNAL)
-{
-#if defined(_POSIX_MONOTONIC_CLOCK)
-	test_timer(CLOCK_MONOTONIC, SIGEV_SIGNAL);
-#else
-	ztest_test_skip();
-#endif
-}
-
-ZTEST(posix_timers, test_CLOCK_MONOTONIC__SIGEV_THREAD)
-{
-#if defined(_POSIX_MONOTONIC_CLOCK)
-	test_timer(CLOCK_MONOTONIC, SIGEV_THREAD);
-#else
-	ztest_test_skip();
-#endif
-}
-
-ZTEST(posix_timers, test_timer_overrun)
-{
-	struct sigevent sig = {0};
-	struct itimerspec value;
-
-	sig.sigev_notify = SIGEV_NONE;
-
-	zassert_ok(timer_create(CLOCK_REALTIME, &sig, &timerid));
-
-	/*Set the timer to expire every 500 milliseconds*/
-	value.it_interval.tv_sec = 0;
-	value.it_interval.tv_nsec = 500000000;
-	value.it_value.tv_sec = 0;
-	value.it_value.tv_nsec = 500000000;
-	zassert_ok(timer_settime(timerid, 0, &value, NULL));
-	k_sleep(K_MSEC(2500));
-
-	zassert_equal(timer_getoverrun(timerid), 4, "Number of overruns is incorrect");
-}
-
-ZTEST(posix_timers, test_one_shot__SIGEV_SIGNAL)
-{
-	struct sigevent sig = {0};
-	struct itimerspec value;
-
-	exp_count = 0;
-	sig.sigev_notify = SIGEV_SIGNAL;
-	sig.sigev_notify_function = handler;
-	sig.sigev_value.sival_int = TEST_SIGNAL_VAL;
-
-	zassert_ok(timer_create(CLOCK_MONOTONIC, &sig, &timerid));
-
-	/*Set the timer to expire only once*/
-	value.it_interval.tv_sec = 0;
-	value.it_interval.tv_nsec = 0;
-	value.it_value.tv_sec = 0;
-	value.it_value.tv_nsec = 100 * NSEC_PER_MSEC;
-	zassert_ok(timer_settime(timerid, 0, &value, NULL));
-	k_sleep(K_MSEC(300));
-
-	zassert_equal(exp_count, 1, "Number of expiry is incorrect");
-}
-
-static void after(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	if (timerid != -1) {
-		(void)timer_delete(timerid);
-		timerid = -1;
-	}
-}
-
-ZTEST_SUITE(posix_timers, NULL, NULL, NULL, after, NULL);
diff --git a/tests/posix/timers/testcase.yaml b/tests/posix/timers/testcase.yaml
deleted file mode 100644
index a84873b508b..00000000000
--- a/tests/posix/timers/testcase.yaml
+++ /dev/null
@@ -1,25 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - timers
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.timers: {}
-  portability.posix.timers.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.timers.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.timers.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/xsi_realtime/CMakeLists.txt b/tests/posix/xsi_realtime/CMakeLists.txt
deleted file mode 100644
index fdc713df0d9..00000000000
--- a/tests/posix/xsi_realtime/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(posix_xsi_realtime)
-
-FILE(GLOB app_sources src/*.c)
-
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/tests/posix/xsi_realtime/app.overlay b/tests/posix/xsi_realtime/app.overlay
deleted file mode 100644
index 87ae21b1e64..00000000000
--- a/tests/posix/xsi_realtime/app.overlay
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * Copyright (c) 2023 Nordic Semiconductor ASA
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-/ {
-	ramdisk0 {
-		compatible = "zephyr,ram-disk";
-		disk-name = "RAM";
-		sector-size = <512>;
-		sector-count = <160>;
-	};
-};
diff --git a/tests/posix/xsi_realtime/prj.conf b/tests/posix/xsi_realtime/prj.conf
deleted file mode 100644
index 5b881e9b852..00000000000
--- a/tests/posix/xsi_realtime/prj.conf
+++ /dev/null
@@ -1,17 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_PSE52=y
-CONFIG_XSI_REALTIME=y
-CONFIG_FILE_SYSTEM=y
-CONFIG_POSIX_FILE_SYSTEM=y
-
-CONFIG_FAT_FILESYSTEM_ELM=y
-CONFIG_MAIN_STACK_SIZE=4096
-CONFIG_ZTEST_STACK_SIZE=2048
-
-CONFIG_DYNAMIC_THREAD=y
-CONFIG_THREAD_STACK_INFO=y
-CONFIG_DYNAMIC_THREAD_POOL_SIZE=6
-
-CONFIG_ZVFS_OPEN_IGNORE_MIN=y
-CONFIG_ZVFS_OPEN_MAX=5
diff --git a/tests/posix/xsi_realtime/src/main.c b/tests/posix/xsi_realtime/src/main.c
deleted file mode 100644
index 034517eb783..00000000000
--- a/tests/posix/xsi_realtime/src/main.c
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2025 Marvin Ouma <pancakesdeath@protonmail.com>
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(xsi_realtime, test_sched_getparam)
-{
-	struct sched_param param;
-	int rc = sched_getparam(0, &param);
-	int err = errno;
-
-	zassert_true((rc == -1 && err == ENOSYS));
-}
-
-ZTEST(xsi_realtime, test_sched_getscheduler)
-{
-	int rc = sched_getscheduler(0);
-	int err = errno;
-
-	zassert_true((rc == -1 && err == ENOSYS));
-}
-ZTEST(xsi_realtime, test_sched_setparam)
-{
-	struct sched_param param = {
-		.sched_priority = 2,
-	};
-	int rc = sched_setparam(0, &param);
-	int err = errno;
-
-	zassert_true((rc == -1 && err == ENOSYS));
-}
-
-ZTEST(xsi_realtime, test_sched_setscheduler)
-{
-	struct sched_param param = {
-		.sched_priority = 2,
-	};
-	int policy = 0;
-	int rc = sched_setscheduler(0, policy, &param);
-	int err = errno;
-
-	zassert_true((rc == -1 && err == ENOSYS));
-}
-
-ZTEST(xsi_realtime, test_sched_rr_get_interval)
-{
-	struct timespec interval = {
-		.tv_sec = 0,
-		.tv_nsec = 0,
-	};
-	int rc = sched_rr_get_interval(0, &interval);
-	int err = errno;
-
-	zassert_true((rc == -1 && err == ENOSYS));
-}
-
-ZTEST_SUITE(xsi_realtime, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/xsi_realtime/src/mqueue.c b/tests/posix/xsi_realtime/src/mqueue.c
deleted file mode 100644
index f8fd608f1d3..00000000000
--- a/tests/posix/xsi_realtime/src/mqueue.c
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2024 BayLibre, SAS
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <fcntl.h>
-#include <mqueue.h>
-#include <pthread.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define N_THR            2
-#define MESSAGE_SIZE     16
-#define MESG_COUNT_PERMQ 4
-
-static char queue[16] = "server";
-
-static char send_data[MESSAGE_SIZE] = "timed data send";
-
-/*
- * For platforms that select CONFIG_KERNEL_COHERENCE, the receive buffer can
- * not be on the stack as the k_msgq that underlies the mq_timedsend() will
- * copy directly to the receiver's buffer when there is already a waiting
- * receiver.
- */
-
-static char rec_data[MESSAGE_SIZE];
-
-static void *sender_thread(void *p1)
-{
-	mqd_t mqd;
-	struct timespec curtime;
-
-	mqd = mq_open(queue, O_WRONLY);
-	zassert_ok(clock_gettime(CLOCK_REALTIME, &curtime));
-	curtime.tv_sec += 1;
-	zassert_false(mq_timedsend(mqd, send_data, MESSAGE_SIZE, 0, &curtime),
-		      "Not able to send message in timer");
-	usleep(USEC_PER_MSEC);
-	zassert_false(mq_close(mqd), "unable to close message queue descriptor.");
-	pthread_exit(p1);
-	return NULL;
-}
-
-static void *receiver_thread(void *p1)
-{
-	mqd_t mqd;
-	struct timespec curtime;
-
-	mqd = mq_open(queue, O_RDONLY);
-	zassert_ok(clock_gettime(CLOCK_REALTIME, &curtime));
-	curtime.tv_sec += 1;
-	mq_timedreceive(mqd, rec_data, MESSAGE_SIZE, 0, &curtime);
-	zassert_false(strcmp(rec_data, send_data), "Error in data reception. exp: %s act: %s",
-		      send_data, rec_data);
-	usleep(USEC_PER_MSEC);
-	zassert_false(mq_close(mqd), "unable to close message queue descriptor.");
-	pthread_exit(p1);
-	return NULL;
-}
-
-ZTEST(xsi_realtime, test_mqueue)
-{
-	mqd_t mqd;
-	struct mq_attr attrs;
-	int32_t mode = 0777;
-	int flags = O_RDWR | O_CREAT;
-	void *retval;
-	pthread_t newthread[N_THR];
-
-	attrs.mq_msgsize = MESSAGE_SIZE;
-	attrs.mq_maxmsg = MESG_COUNT_PERMQ;
-
-	mqd = mq_open(queue, flags, mode, &attrs);
-
-	for (int i = 0; i < N_THR; i++) {
-		/* Creating threads */
-		zassert_ok(pthread_create(&newthread[i], NULL,
-					  (i % 2 == 0) ? receiver_thread : sender_thread, NULL));
-	}
-
-	usleep(USEC_PER_MSEC * 10U);
-
-	for (int i = 0; i < N_THR; i++) {
-		pthread_join(newthread[i], &retval);
-	}
-
-	zassert_false(mq_close(mqd), "unable to close message queue descriptor.");
-	zassert_false(mq_unlink(queue), "Not able to unlink Queue");
-}
-
-static bool notification_executed;
-
-void notify_function_basic(union sigval val)
-{
-	mqd_t mqd;
-	bool *executed = (bool *)val.sival_ptr;
-
-	mqd = mq_open(queue, O_RDONLY);
-
-	mq_receive(mqd, rec_data, MESSAGE_SIZE, 0);
-	zassert_ok(strcmp(rec_data, send_data), "Error in data reception. exp: %s act: %s",
-		   send_data, rec_data);
-
-	zassert_ok(mq_close(mqd), "Unable to close message queue descriptor.");
-
-	*executed = true;
-}
-
-ZTEST(xsi_realtime, test_mqueue_notify_basic)
-{
-	mqd_t mqd;
-	struct mq_attr attrs = {
-		.mq_msgsize = MESSAGE_SIZE,
-		.mq_maxmsg = MESG_COUNT_PERMQ,
-	};
-	struct sigevent not = {
-		.sigev_notify = SIGEV_NONE,
-		.sigev_value.sival_ptr = (void *)&notification_executed,
-		.sigev_notify_function = notify_function_basic,
-	};
-	int32_t mode = 0777;
-	int flags = O_RDWR | O_CREAT;
-
-	notification_executed = false;
-	memset(rec_data, 0, MESSAGE_SIZE);
-
-	mqd = mq_open(queue, flags, mode, &attrs);
-
-	zassert_ok(mq_notify(mqd, &not), "Unable to set notification.");
-
-	zassert_ok(mq_send(mqd, send_data, MESSAGE_SIZE, 0), "Unable to send message");
-
-	zassert_true(notification_executed, "Notification not triggered.");
-
-	zassert_ok(mq_close(mqd), "Unable to close message queue descriptor.");
-	zassert_ok(mq_unlink(queue), "Unable to unlink queue");
-}
-
-void notify_function_thread(union sigval val)
-{
-	mqd_t mqd;
-	pthread_t sender = (pthread_t)val.sival_int;
-
-	zassert_not_equal(sender, pthread_self(),
-			  "Notification function should be executed from different thread.");
-
-	mqd = mq_open(queue, O_RDONLY);
-
-	mq_receive(mqd, rec_data, MESSAGE_SIZE, 0);
-	zassert_ok(strcmp(rec_data, send_data), "Error in data reception. exp: %s act: %s",
-		   send_data, rec_data);
-
-	zassert_ok(mq_close(mqd), "Unable to close message queue descriptor.");
-
-	notification_executed = true;
-}
-
-ZTEST(xsi_realtime, test_mqueue_notify_thread)
-{
-	mqd_t mqd;
-	struct mq_attr attrs = {
-		.mq_msgsize = MESSAGE_SIZE,
-		.mq_maxmsg = MESG_COUNT_PERMQ,
-	};
-	struct sigevent not = {
-		.sigev_notify = SIGEV_THREAD,
-		.sigev_value.sival_int = (int)pthread_self(),
-		.sigev_notify_function = notify_function_thread,
-	};
-	int32_t mode = 0777;
-	int flags = O_RDWR | O_CREAT;
-
-	notification_executed = false;
-	memset(rec_data, 0, MESSAGE_SIZE);
-
-	mqd = mq_open(queue, flags, mode, &attrs);
-
-	zassert_ok(mq_notify(mqd, &not), "Unable to set notification.");
-
-	zassert_ok(mq_send(mqd, send_data, MESSAGE_SIZE, 0), "Unable to send message");
-
-	usleep(USEC_PER_MSEC * 100U);
-
-	zassert_true(notification_executed, "Notification not triggered.");
-
-	zassert_ok(mq_close(mqd), "Unable to close message queue descriptor.");
-	zassert_ok(mq_unlink(queue), "Unable to unlink queue");
-}
-
-ZTEST(xsi_realtime, test_mqueue_notify_non_empty_queue)
-{
-	mqd_t mqd;
-	struct mq_attr attrs = {
-		.mq_msgsize = MESSAGE_SIZE,
-		.mq_maxmsg = MESG_COUNT_PERMQ,
-	};
-	struct sigevent not = {
-		.sigev_notify = SIGEV_NONE,
-		.sigev_value.sival_ptr = (void *)&notification_executed,
-		.sigev_notify_function = notify_function_basic,
-	};
-	int32_t mode = 0777;
-	int flags = O_RDWR | O_CREAT;
-
-	notification_executed = false;
-	memset(rec_data, 0, MESSAGE_SIZE);
-
-	mqd = mq_open(queue, flags, mode, &attrs);
-
-	zassert_ok(mq_send(mqd, send_data, MESSAGE_SIZE, 0), "Unable to send message");
-
-	zassert_ok(mq_notify(mqd, &not), "Unable to set notification.");
-
-	zassert_false(notification_executed, "Notification shouldn't be processed.");
-
-	mq_receive(mqd, rec_data, MESSAGE_SIZE, 0);
-	zassert_false(strcmp(rec_data, send_data), "Error in data reception. exp: %s act: %s",
-		      send_data, rec_data);
-
-	memset(rec_data, 0, MESSAGE_SIZE);
-
-	zassert_ok(mq_send(mqd, send_data, MESSAGE_SIZE, 0), "Unable to send message");
-
-	zassert_true(notification_executed, "Notification not triggered.");
-
-	zassert_ok(mq_close(mqd), "Unable to close message queue descriptor.");
-	zassert_ok(mq_unlink(queue), "Unable to unlink queue");
-}
-
-ZTEST(xsi_realtime, test_mqueue_notify_errors)
-{
-	mqd_t mqd;
-	struct mq_attr attrs = {
-		.mq_msgsize = MESSAGE_SIZE,
-		.mq_maxmsg = MESG_COUNT_PERMQ,
-	};
-	struct sigevent not = {
-		.sigev_notify = SIGEV_SIGNAL,
-		.sigev_value.sival_ptr = (void *)&notification_executed,
-		.sigev_notify_function = notify_function_basic,
-	};
-	int32_t mode = 0777;
-	int flags = O_RDWR | O_CREAT;
-
-	zassert_not_ok(mq_notify(NULL, NULL), "Should return -1 and set errno to EBADF.");
-	zassert_equal(errno, EBADF);
-
-	mqd = mq_open(queue, flags, mode, &attrs);
-
-	zassert_not_ok(mq_notify(mqd, NULL), "Should return -1 and set errno to EINVAL.");
-	zassert_equal(errno, EINVAL);
-
-	zassert_not_ok(mq_notify(mqd, &not), "SIGEV_SIGNAL not supported should return -1.");
-	zassert_equal(errno, ENOSYS);
-
-	not.sigev_notify = SIGEV_NONE;
-
-	zassert_ok(mq_notify(mqd, &not),
-		   "Unexpected error while asigning notification to the queue.");
-
-	zassert_not_ok(mq_notify(mqd, &not),
-		       "Can't assign notification when there is another assigned.");
-	zassert_equal(errno, EBUSY);
-
-	zassert_ok(mq_notify(mqd, NULL), "Unable to remove notification from the message queue.");
-
-	zassert_ok(mq_close(mqd), "Unable to close message queue descriptor.");
-	zassert_ok(mq_unlink(queue), "Unable to unlink queue");
-}
-
-ZTEST(xsi_realtime, test_mqueue_open_and_unlink_multiple)
-{
-	const char *q1 = "q1";
-	const char *q2 = "q2";
-
-	mqd_t mqd1, mqd2;
-	struct mq_attr attrs = {
-		.mq_msgsize = MESSAGE_SIZE,
-		.mq_maxmsg = MESG_COUNT_PERMQ,
-	};
-
-	int32_t mode = 0600;
-	int flags = O_RDWR | O_CREAT;
-
-	mqd1 = mq_open(q1, flags, mode, &attrs);
-
-	zassert_ok(mq_unlink(q1), "Unable to unlink q1");
-
-	mqd2 = mq_open(q2, flags, mode, &attrs);
-
-	zassert_ok(mq_unlink(q2), "Unable to unlink q2");
-
-	zassert_ok(mq_close(mqd1), "Unable to close message queue 1 descriptor.");
-	zassert_ok(mq_close(mqd2), "Unable to close message queue 2 descriptor.");
-}
diff --git a/tests/posix/xsi_realtime/src/shm.c b/tests/posix/xsi_realtime/src/shm.c
deleted file mode 100644
index f8b8885f8dc..00000000000
--- a/tests/posix/xsi_realtime/src/shm.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (c) 2024, Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <sys/socket.h>
-
-#include <zephyr/kernel.h>
-#include <zephyr/sys/fdtable.h>
-
-#include <zephyr/ztest.h>
-
-#define _page_size COND_CODE_1(CONFIG_MMU, (CONFIG_MMU_PAGE_SIZE), (CONFIG_POSIX_PAGE_SIZE))
-
-#define SHM_SIZE 8
-
-#define VALID_SHM_PATH     "/foo"
-#define INVALID_SHM_PATH   "foo"
-#define EMPTY_SHM_PATH     ""
-#define TOO_SHORT_SHM_PATH "/"
-
-#define INVALID_MODE 0
-#define VALID_MODE   0666
-
-#define INVALID_FLAGS 0
-#define VALID_FLAGS   (O_RDWR | O_CREAT)
-#define CREATE_FLAGS  VALID_FLAGS
-#define OPEN_FLAGS    (VALID_FLAGS & ~O_CREAT)
-
-/* account for stdin, stdout, stderr */
-#define N (ZVFS_OPEN_SIZE - 3)
-
-/* we need to have at least 2 shared memory objects */
-BUILD_ASSERT(N >= 2, "ZVFS_OPEN_SIZE must be > 4");
-
-ZTEST(xsi_realtime, test_shm_open)
-{
-	int ret;
-	int fd[N];
-	struct stat st;
-
-	{
-		/* degenerate error cases */
-		zassert_not_ok(shm_open(NULL, INVALID_FLAGS, INVALID_MODE));
-		zassert_not_ok(shm_open(NULL, INVALID_FLAGS, VALID_MODE));
-		zassert_not_ok(shm_open(NULL, VALID_FLAGS, INVALID_MODE));
-		zassert_not_ok(shm_open(NULL, VALID_FLAGS, VALID_MODE));
-		zassert_not_ok(shm_open(INVALID_SHM_PATH, VALID_FLAGS, VALID_MODE));
-		zassert_not_ok(shm_open(EMPTY_SHM_PATH, VALID_FLAGS, VALID_MODE));
-		zassert_not_ok(shm_open(TOO_SHORT_SHM_PATH, VALID_FLAGS, VALID_MODE));
-		zassert_not_ok(shm_open(VALID_SHM_PATH, INVALID_FLAGS, INVALID_MODE));
-		zassert_not_ok(shm_open(VALID_SHM_PATH, INVALID_FLAGS, VALID_MODE));
-		zassert_not_ok(shm_open(VALID_SHM_PATH, VALID_FLAGS, INVALID_MODE));
-	}
-
-	/* open / close 1 file descriptor referring to VALID_SHM_PATH */
-	fd[0] = shm_open(VALID_SHM_PATH, VALID_FLAGS, VALID_MODE);
-	zassert_true(fd[0] >= 0, "shm_open(%s, %x, %04o) failed: %d", VALID_SHM_PATH, VALID_FLAGS,
-		     VALID_MODE, errno);
-
-	/* should have size 0 and be a shared memory object */
-	zassert_ok(fstat(fd[0], &st));
-	zassert_equal(st.st_size, 0);
-	zassert_true(S_TYPEISSHM(&st));
-
-	/* technically, the order of close / shm_unlink can be reversed too */
-	zassert_ok(close(fd[0]));
-	ret = shm_unlink(VALID_SHM_PATH);
-	zassert_true(ret == 0 || (ret == -1 && errno == ENOENT),
-		     "unexpected return / errno from shm_unlink: %d / %d", ret, errno);
-
-	/* open / close N file descriptors referring to VALID_SHM_PATH */
-	for (size_t i = 0; i < N; ++i) {
-		fd[i] = shm_open(VALID_SHM_PATH, i == 0 ? CREATE_FLAGS : OPEN_FLAGS, VALID_MODE);
-		zassert_true(fd[i] >= 0, "shm_open(%s, %x, %04o) failed: %d", VALID_SHM_PATH,
-			     VALID_FLAGS, VALID_MODE, errno);
-	}
-	zassert_ok(shm_unlink(VALID_SHM_PATH));
-	for (size_t i = N; i > 0; --i) {
-		zassert_ok(close(fd[i - 1]));
-	}
-}
-
-ZTEST(xsi_realtime, test_shm_unlink)
-{
-	int fd;
-
-	{
-		/* degenerate error cases */
-		zassert_not_ok(shm_unlink(NULL));
-		zassert_not_ok(shm_unlink(INVALID_SHM_PATH));
-		zassert_not_ok(shm_unlink(EMPTY_SHM_PATH));
-		zassert_not_ok(shm_unlink(TOO_SHORT_SHM_PATH));
-	}
-
-	/* open / close 1 file descriptor referring to VALID_SHM_PATH */
-	fd = shm_open(VALID_SHM_PATH, VALID_FLAGS, VALID_MODE);
-	zassert_true(fd >= 0, "shm_open(%s, %x, %04o) failed: %d", VALID_SHM_PATH, VALID_FLAGS,
-		     VALID_MODE, errno);
-	/* technically, the order of close / shm_unlink can be reversed too */
-	zassert_ok(close(fd));
-	zassert_ok(shm_unlink(VALID_SHM_PATH));
-	/* should not be able to re-open the same path without O_CREAT */
-	zassert_not_ok(shm_open(VALID_SHM_PATH, OPEN_FLAGS, VALID_MODE));
-}
-
-ZTEST(xsi_realtime, test_shm_read_write)
-{
-	int fd[N];
-
-	for (size_t i = 0; i < N; ++i) {
-		char cbuf = 0xff;
-
-		fd[i] = shm_open(VALID_SHM_PATH, i == 0 ? CREATE_FLAGS : OPEN_FLAGS, VALID_MODE);
-		zassert_true(fd[i] >= 0, "shm_open(%s, %x, %04o) failed: %d", VALID_SHM_PATH,
-			     VALID_FLAGS, VALID_MODE, errno);
-		if (i == 0) {
-			/* size 0 on create / zero characters written */
-			zassert_equal(write(fd[0], "", 1), 0,
-				      "write() should fail on newly create shm fd with size 0");
-			/* size 0 on create / zero characters read */
-			zassert_equal(read(fd[0], &cbuf, 1), 0,
-				      "read() should fail on newly create shm fd with size 0");
-
-			BUILD_ASSERT(SHM_SIZE >= 1);
-			zassert_ok(ftruncate(fd[0], SHM_SIZE));
-
-			zassert_equal(write(fd[0], "\x42", 1), 1, "write() failed on fd %d: %d\n",
-				      fd[0], errno);
-
-			continue;
-		}
-
-		zassert_equal(read(fd[i], &cbuf, 1), 1, "read() failed on fd %d: %d\n", fd[i],
-			      errno);
-		zassert_equal(cbuf, 0x42,
-			      "Failed to read byte over fd %d: expected: 0x%02x actual: 0x%02x",
-			      fd[i], 0x42, cbuf);
-	}
-
-	for (size_t i = N; i > 0; --i) {
-		zassert_ok(close(fd[i - 1]));
-	}
-
-	zassert_ok(shm_unlink(VALID_SHM_PATH));
-}
-
-ZTEST(xsi_realtime, test_shm_mmap)
-{
-	int fd[N];
-	void *addr[N];
-
-	if (!IS_ENABLED(CONFIG_MMU)) {
-		ztest_test_skip();
-	}
-
-	for (size_t i = 0; i < N; ++i) {
-		fd[i] = shm_open(VALID_SHM_PATH, i == 0 ? CREATE_FLAGS : OPEN_FLAGS, VALID_MODE);
-		zassert_true(fd[i] >= 0, "shm_open(%s, %x, %04o) failed : %d", VALID_SHM_PATH,
-			     VALID_FLAGS, VALID_MODE, errno);
-
-		if (i == 0) {
-			/* cannot map shm of size zero */
-			zassert_not_ok(mmap(NULL, _page_size, PROT_READ | PROT_WRITE, MAP_SHARED,
-					    fd[0], 0));
-
-			zassert_ok(ftruncate(fd[0], _page_size));
-		}
-
-		addr[i] = mmap(NULL, _page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd[i], 0);
-		zassert_not_equal(MAP_FAILED, addr[i], "mmap() failed: %d", errno);
-
-		if ((i & 1) == 0) {
-			memset(addr[0], i & 0xff, _page_size);
-		} else {
-			zassert_mem_equal(addr[i], addr[i - 1], _page_size);
-		}
-	}
-
-	for (size_t i = N; i > 0; --i) {
-		zassert_ok(close(fd[i - 1]));
-	}
-
-	for (size_t i = N; i > 0; --i) {
-		zassert_ok(munmap(addr[i - 1], _page_size));
-		/*
-		 * Note: for some reason, in Zephyr, unmapping a physical page once, removes all
-		 * virtual mappings. When that behaviour changes, remove the break below and adjust
-		 * shm.c accordingly.
-		 */
-		break;
-	}
-
-	zassert_ok(shm_unlink(VALID_SHM_PATH));
-}
diff --git a/tests/posix/xsi_realtime/src/sync_io.c b/tests/posix/xsi_realtime/src/sync_io.c
deleted file mode 100644
index b801d3f3ff1..00000000000
--- a/tests/posix/xsi_realtime/src/sync_io.c
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation.
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <string.h>
-#include <fcntl.h>
-#include <ff.h>
-#include <zephyr/fs/fs.h>
-#include <unistd.h>
-#include <zephyr/ztest.h>
-
-static const char test_str[] = "Hello World!";
-
-#define FATFS_MNTP "/RAM:"
-#define TEST_FILE  FATFS_MNTP "/testfile.txt"
-
-static FATFS fat_fs;
-
-static struct fs_mount_t fatfs_mnt = {
-	.type = FS_FATFS,
-	.mnt_point = FATFS_MNTP,
-	.fs_data = &fat_fs,
-};
-
-static void test_mount(void)
-{
-	int res;
-
-	res = fs_mount(&fatfs_mnt);
-	zassert_ok(res, "Error mounting fs [%d]\n", res);
-}
-
-void test_unmount(void)
-{
-	int res;
-
-	res = fs_unmount(&fatfs_mnt);
-	zassert_ok(res, "Error unmounting fs [%d]", res);
-}
-
-static int file_open(void)
-{
-	int res;
-
-	res = open(TEST_FILE, O_CREAT | O_RDWR, 0660);
-	zassert_not_equal(res, -1, "Error opening file [%d], errno [%d]", res, errno);
-	return res;
-}
-
-static int file_write(int file)
-{
-	ssize_t brw;
-	off_t res;
-
-	res = lseek(file, 0, SEEK_SET);
-	zassert_ok((int)res, "lseek failed [%d]\n", (int)res);
-
-	brw = write(file, (char *)test_str, strlen(test_str));
-	zassert_ok((int)res, "Failed writing to file [%d]\n", (int)brw);
-
-	zassert_ok(brw < strlen(test_str),
-		   "Unable to complete write. Volume full. Number of bytes written: [%d]\n",
-		   (int)brw);
-	return res;
-}
-
-/**
- * @brief Test for POSIX fsync API
- *
- * @details Test sync the file through POSIX fsync API.
- */
-ZTEST(xsi_realtime, test_fs_sync)
-{
-	test_mount();
-	int res = 0;
-	int file = file_open();
-
-	res = file_write(file);
-	res = fsync(file);
-	zassert_ok(res, "Failed to sync file: %d, errno = %d\n", res, errno);
-	zassert_ok(close(file), "Failed to close file");
-	test_unmount();
-}
-
-/**
- * @brief Test for POSIX fdatasync API
- *
- * @details Test sync the file through POSIX fdatasync API.
- */
-ZTEST(xsi_realtime, test_fs_datasync)
-{
-	test_mount();
-	int res = 0;
-	int file = file_open();
-
-	res = file_write(file);
-	res = fdatasync(file);
-	zassert_ok(res, "Failed to sync file: %d, errno = %d\n", res, errno);
-	zassert_ok(close(file), "Failed to close file");
-	test_unmount();
-}
diff --git a/tests/posix/xsi_realtime/testcase.yaml b/tests/posix/xsi_realtime/testcase.yaml
deleted file mode 100644
index c7bf8ff6465..00000000000
--- a/tests/posix/xsi_realtime/testcase.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - xsi_realtime
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  min_flash: 64
-  min_ram: 96
-  integration_platforms:
-    - qemu_x86
-    - qemu_cortex_a53
-    - qemu_riscv64
-  platform_exclude:
-    # linker_zephyr_pre0.cmd:140: syntax error (??)
-    - qemu_xtensa/dc233c
-    - native_sim
-    - native_sim/native/64
-tests:
-  portability.posix.xsi_realtime: {}
-  portability.posix.xsi_realtime.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.xsi_realtime.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.xsi_realtime.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/xsi_single_process/CMakeLists.txt b/tests/posix/xsi_single_process/CMakeLists.txt
deleted file mode 100644
index 105e382e5ea..00000000000
--- a/tests/posix/xsi_single_process/CMakeLists.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(xsi_single_process)
-
-FILE(GLOB app_sources src/*.c)
-
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
-target_include_directories(app PRIVATE ${ZEPHYR_BASE}/lib/posix/options)
diff --git a/tests/posix/xsi_single_process/prj.conf b/tests/posix/xsi_single_process/prj.conf
deleted file mode 100644
index c97ddc7dbff..00000000000
--- a/tests/posix/xsi_single_process/prj.conf
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_XSI=y
-CONFIG_XSI_SINGLE_PROCESS=y
diff --git a/tests/posix/xsi_single_process/src/gethostid.c b/tests/posix/xsi_single_process/src/gethostid.c
deleted file mode 100644
index 1316b3a6ebe..00000000000
--- a/tests/posix/xsi_single_process/src/gethostid.c
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(xsi_single_process, test_gethostid)
-{
-	long id = gethostid();
-
-	if (id == -ENOSYS) {
-		printk("CONFIG_HWINFO not implemented for %s\n", CONFIG_BOARD);
-		ztest_test_skip();
-	}
-
-	uint32_t id32 = gethostid();
-
-	zassert_equal((uint32_t)id, id32, "gethostid() returned inconsistent values %u (exp: %u)",
-			(uint32_t)id, id32);
-}
diff --git a/tests/posix/xsi_single_process/src/gettimeofday.c b/tests/posix/xsi_single_process/src/gettimeofday.c
deleted file mode 100644
index 2470bc17334..00000000000
--- a/tests/posix/xsi_single_process/src/gettimeofday.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2018 Intel Corporation
- * Copyright (c) 2023, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include "posix_clock.h"
-
-#include <sys/time.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(xsi_single_process, test_gettimeofday)
-{
-	struct timeval tv;
-	struct timespec ts;
-	struct timespec rts;
-
-	if (false) {
-		/* undefined behaviour */
-		errno = 0;
-		zassert_equal(gettimeofday(NULL, NULL), -1);
-		zassert_equal(errno, EINVAL);
-	}
-
-	/* Validate gettimeofday API */
-	zassert_ok(gettimeofday(&tv, NULL));
-	zassert_ok(clock_gettime(CLOCK_REALTIME, &rts));
-
-	/* TESTPOINT: Check if time obtained from
-	 * gettimeofday is same or more than obtained
-	 * from clock_gettime
-	 */
-	tv_to_ts(&tv, &ts);
-	zassert_true(tp_ge(&rts, &ts));
-}
diff --git a/tests/posix/xsi_single_process/src/main.c b/tests/posix/xsi_single_process/src/main.c
deleted file mode 100644
index 2b1c54b4399..00000000000
--- a/tests/posix/xsi_single_process/src/main.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <zephyr/ztest.h>
-
-ZTEST_SUITE(xsi_single_process, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/xsi_single_process/src/putenv.c b/tests/posix/xsi_single_process/src/putenv.c
deleted file mode 100644
index 2b05eeca6e0..00000000000
--- a/tests/posix/xsi_single_process/src/putenv.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (c) 2025 Tenstorrent AI ULC
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include <errno.h>
-#include <stdlib.h>
-
-#include <zephyr/ztest.h>
-
-ZTEST(xsi_single_process, test_putenv)
-{
-	char buf[64];
-
-	{
-		/* degenerate cases */
-		static const char *const cases[] = {
-			NULL, "", "=", "abc", "42", "=abc",
-			/*
-			 * Note:
-			 * There are many poorly-formatted environment variable names and values
-			 * that are invalid (from the perspective of a POSIX shell), but still
-			 * accepted by setenv() and subsequently putenv().
-			 *
-			 * See also tests/posix/single_process/src/env.c
-			 * See also lib/posix/shell/env.c:101
-			 */
-		};
-
-		ARRAY_FOR_EACH(cases, i) {
-			char *s;
-
-			if (cases[i] == NULL) {
-				s = NULL;
-			} else {
-				strncpy(buf, cases[i], sizeof(buf));
-				buf[sizeof(buf) - 1] = '\0';
-				s = buf;
-			}
-
-			errno = 0;
-			zexpect_equal(-1, putenv(s), "putenv(%s) unexpectedly succeeded", s);
-			zexpect_not_equal(0, errno, "putenv(%s) did not set errno", s);
-		}
-	}
-
-	{
-		/* valid cases */
-		static const char *const cases[] = {
-			"FOO=bar",
-		};
-
-		ARRAY_FOR_EACH(cases, i) {
-			strncpy(buf, cases[i], sizeof(buf));
-			buf[sizeof(buf) - 1] = '\0';
-
-			zexpect_ok(putenv(buf), "putenv(%s) failed: %d", buf, errno);
-		}
-	}
-}
diff --git a/tests/posix/xsi_single_process/testcase.yaml b/tests/posix/xsi_single_process/testcase.yaml
deleted file mode 100644
index 96a21c401fa..00000000000
--- a/tests/posix/xsi_single_process/testcase.yaml
+++ /dev/null
@@ -1,39 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - xsi
-    - single_process
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_cortex_m0
-  min_ram: 16
-tests:
-  portability.xsi.single_process:
-    extra_configs:
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.xsi.single_process.armclang_std_libc:
-    toolchain_allow: armclang
-    extra_configs:
-      - CONFIG_ARMCLANG_STD_LIBC=y
-  portability.xsi.single_process.arcmwdtlib:
-    toolchain_allow: arcmwdt
-    extra_configs:
-      - CONFIG_ARCMWDT_LIBC=y
-  portability.xsi.single_process.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-      - CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256
-  portability.xsi.single_process.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-      - CONFIG_NEWLIB_LIBC_MIN_REQUIRED_HEAP_SIZE=256
-  portability.xsi.single_process.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/xsi_streams/CMakeLists.txt b/tests/posix/xsi_streams/CMakeLists.txt
deleted file mode 100644
index 271e84e6fc7..00000000000
--- a/tests/posix/xsi_streams/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(xsi_streams)
-
-FILE(GLOB app_sources src/main.c)
-
-target_sources(app PRIVATE ${app_sources})
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/tests/posix/xsi_streams/prj.conf b/tests/posix/xsi_streams/prj.conf
deleted file mode 100644
index 27b21b9a542..00000000000
--- a/tests/posix/xsi_streams/prj.conf
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_XSI=y
-CONFIG_XSI_STREAMS=y
diff --git a/tests/posix/xsi_streams/src/main.c b/tests/posix/xsi_streams/src/main.c
deleted file mode 100644
index ff665857286..00000000000
--- a/tests/posix/xsi_streams/src/main.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2024 Abhinav Srivastava
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-#include <zephyr/ztest.h>
-#include <stropts.h>
-#include <errno.h>
-
-ZTEST(xsi_streams, test_putmsg)
-{
-	const struct strbuf *ctrl = NULL;
-	const struct strbuf *data = NULL;
-	int fd = -1;
-	int ret = putmsg(fd, ctrl, data, 0);
-
-	zassert_equal(ret, -1, "Expected return value -1, got %d", ret);
-	zassert_equal(errno, ENOSYS, "Expected errno ENOSYS, got %d", errno);
-}
-
-ZTEST(xsi_streams, test_fdetach)
-{
-	char *path = NULL;
-	int ret = fdetach(path);
-
-	zassert_equal(ret, -1, "Expected return value -1, got %d", ret);
-	zassert_equal(errno, ENOSYS, "Expected errno ENOSYS, got %d", errno);
-}
-
-ZTEST(xsi_streams, test_fattach)
-{
-	char *path = NULL;
-	int fd = -1;
-	int ret = fattach(fd, path);
-
-	zassert_equal(ret, -1, "Expected return value -1, got %d", ret);
-	zassert_equal(errno, ENOSYS, "Expected errno ENOSYS, got %d", errno);
-}
-
-ZTEST(xsi_streams, test_getmsg)
-{
-	struct strbuf *ctrl = NULL;
-	struct strbuf *data = NULL;
-	int fd = -1;
-	int ret = getmsg(fd, ctrl, data, 0);
-
-	zassert_equal(ret, -1, "Expected return value -1, got %d", ret);
-	zassert_equal(errno, ENOSYS, "Expected errno ENOSYS, got %d", errno);
-}
-
-ZTEST(xsi_streams, test_getpmsg)
-{
-	struct strbuf *ctrl = NULL;
-	struct strbuf *data = NULL;
-	int fd = -1;
-	int ret = getpmsg(fd, ctrl, data, 0, 0);
-
-	zassert_equal(ret, -1, "Expected return value -1, got %d", ret);
-	zassert_equal(errno, ENOSYS, "Expected errno ENOSYS, got %d", errno);
-}
-
-ZTEST(xsi_streams, test_isastream)
-{
-	int fd = -1;
-	int ret = isastream(fd);
-
-	zassert_equal(ret, -1, "Expected return value -1, got %d", ret);
-	zassert_equal(errno, ENOSYS, "Expected errno ENOSYS, got %d", errno);
-}
-
-ZTEST_SUITE(xsi_streams, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/xsi_streams/testcase.yaml b/tests/posix/xsi_streams/testcase.yaml
deleted file mode 100644
index 06b40f1c2e8..00000000000
--- a/tests/posix/xsi_streams/testcase.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - xsi_streams
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_riscv64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.xsi_streams: {}
-  portability.posix.xsi_streams.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.xsi_streams.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.xsi_streams.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/xsi_system_logging/CMakeLists.txt b/tests/posix/xsi_system_logging/CMakeLists.txt
deleted file mode 100644
index 0ffcfefeb11..00000000000
--- a/tests/posix/xsi_system_logging/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(xsi_system_logging)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/tests/posix/xsi_system_logging/prj.conf b/tests/posix/xsi_system_logging/prj.conf
deleted file mode 100644
index 6271bea065e..00000000000
--- a/tests/posix/xsi_system_logging/prj.conf
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_XSI=y
-CONFIG_XSI_SYSTEM_LOGGING=y
diff --git a/tests/posix/xsi_system_logging/src/main.c b/tests/posix/xsi_system_logging/src/main.c
deleted file mode 100644
index e85213d163c..00000000000
--- a/tests/posix/xsi_system_logging/src/main.c
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <syslog.h>
-#undef LOG_ERR
-#include <unistd.h>
-#include <zephyr/ztest.h>
-
-#define N_PRIOS  8
-/* avoid clashing with Zephyr's LOG_ERR() */
-#define _LOG_ERR 3
-
-ZTEST(xsi_system_logging, test_syslog)
-{
-	int prios[N_PRIOS] = {
-		LOG_EMERG,   LOG_ALERT,  LOG_CRIT, _LOG_ERR,
-		LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG,
-	};
-
-	openlog("syslog", LOG_PID | LOG_CONS | LOG_NOWAIT, LOG_LOCAL7);
-	(void)setlogmask(LOG_MASK(-1));
-
-	for (size_t i = 0; i < N_PRIOS; ++i) {
-		syslog(i, "syslog priority %d", prios[i]);
-	}
-
-	closelog();
-
-	/* yield briefly to logging thread */
-	usleep(100000);
-}
-
-ZTEST_SUITE(xsi_system_logging, NULL, NULL, NULL, NULL, NULL);
diff --git a/tests/posix/xsi_system_logging/testcase.yaml b/tests/posix/xsi_system_logging/testcase.yaml
deleted file mode 100644
index 54d6790ae75..00000000000
--- a/tests/posix/xsi_system_logging/testcase.yaml
+++ /dev/null
@@ -1,26 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - xsi.system.logging
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  integration_platforms:
-    - qemu_riscv64
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.xsi.system.logging: {}
-  portability.xsi.system.logging.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.xsi.system.logging.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.xsi.system.logging.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
diff --git a/tests/posix/xsi_threads_ext/CMakeLists.txt b/tests/posix/xsi_threads_ext/CMakeLists.txt
deleted file mode 100644
index 85401ed21d3..00000000000
--- a/tests/posix/xsi_threads_ext/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: Apache-2.0
-
-cmake_minimum_required(VERSION 3.20.0)
-find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
-project(xsi_threads_ext)
-
-target_sources(app PRIVATE src/main.c)
-
-target_compile_options(app PRIVATE -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L)
-target_compile_options(app PRIVATE -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700)
diff --git a/tests/posix/xsi_threads_ext/prj.conf b/tests/posix/xsi_threads_ext/prj.conf
deleted file mode 100644
index e628b7fc4e4..00000000000
--- a/tests/posix/xsi_threads_ext/prj.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ZTEST=y
-
-CONFIG_POSIX_AEP_CHOICE_BASE=y
-CONFIG_XSI=y
-CONFIG_XSI_THREADS_EXT=y
-
-CONFIG_DYNAMIC_THREAD_ALLOC=y
-CONFIG_TEST_EXTRA_STACK_SIZE=4096
diff --git a/tests/posix/xsi_threads_ext/src/main.c b/tests/posix/xsi_threads_ext/src/main.c
deleted file mode 100644
index 352ef09e3af..00000000000
--- a/tests/posix/xsi_threads_ext/src/main.c
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Copyright (c) 2024, Meta
- * Copyright (c) 2024, Marvin Ouma <pancakesdeath@protonmail.com>
- *
- * SPDX-License-Identifier: Apache-2.0
- */
-
-#include <pthread.h>
-
-#include <zephyr/sys/util.h>
-#include <zephyr/ztest.h>
-
-#define BIOS_FOOD 0xB105F00D
-
-static bool attr_valid;
-static pthread_attr_t attr;
-static const pthread_attr_t uninit_attr;
-static bool detached_thread_has_finished;
-
-/*
- * This should be discarded by the linker, in this specific testsuite, if
- * CONFIG_DYNAMIC_THREAD_ALLOC is not set
- */
-#define STATIC_THREAD_STACK_SIZE (MAX(1024, PTHREAD_STACK_MIN + CONFIG_TEST_EXTRA_STACK_SIZE))
-static K_THREAD_STACK_DEFINE(static_thread_stack, STATIC_THREAD_STACK_SIZE);
-
-static void *thread_entry(void *arg)
-{
-	bool joinable = (bool)POINTER_TO_UINT(arg);
-
-	if (!joinable) {
-		detached_thread_has_finished = true;
-	}
-
-	return NULL;
-}
-
-static void create_thread_common_entry(const pthread_attr_t *attrp, bool expect_success,
-				       bool joinable, void *(*entry)(void *arg), void *arg)
-{
-	pthread_t th;
-
-	if (!joinable) {
-		detached_thread_has_finished = false;
-	}
-
-	if (expect_success) {
-		zassert_ok(pthread_create(&th, attrp, entry, arg));
-	} else {
-		zassert_not_ok(pthread_create(&th, attrp, entry, arg));
-		return;
-	}
-
-	if (joinable) {
-		zassert_ok(pthread_join(th, NULL), "failed to join joinable thread");
-		return;
-	}
-
-	/* should not be able to join detached thread */
-	zassert_not_ok(pthread_join(th, NULL));
-
-	for (size_t i = 0; i < 10; ++i) {
-		k_msleep(2 * CONFIG_PTHREAD_RECYCLER_DELAY_MS);
-		if (detached_thread_has_finished) {
-			break;
-		}
-	}
-
-	zassert_true(detached_thread_has_finished, "detached thread did not seem to finish");
-}
-
-static void create_thread_common(const pthread_attr_t *attrp, bool expect_success, bool joinable)
-{
-	create_thread_common_entry(attrp, expect_success, joinable, thread_entry,
-				   UINT_TO_POINTER(joinable));
-}
-
-static inline void can_create_thread(const pthread_attr_t *attrp)
-{
-	create_thread_common(attrp, true, true);
-}
-
-ZTEST(xsi_threads_ext, test_pthread_attr_getstack)
-{
-	void *stackaddr = (void *)BIOS_FOOD;
-	size_t stacksize = BIOS_FOOD;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getstack(NULL, NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getstack(NULL, NULL, &stacksize), EINVAL);
-			zassert_equal(pthread_attr_getstack(NULL, &stackaddr, NULL), EINVAL);
-			zassert_equal(pthread_attr_getstack(NULL, &stackaddr, &stacksize), EINVAL);
-			zassert_equal(pthread_attr_getstack(&uninit_attr, &stackaddr, &stacksize),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_getstack(&attr, NULL, NULL), EINVAL);
-		zassert_equal(pthread_attr_getstack(&attr, NULL, &stacksize), EINVAL);
-		zassert_equal(pthread_attr_getstack(&attr, &stackaddr, NULL), EINVAL);
-	}
-
-	zassert_ok(pthread_attr_getstack(&attr, &stackaddr, &stacksize));
-	zassert_not_equal(stackaddr, (void *)BIOS_FOOD);
-	zassert_not_equal(stacksize, BIOS_FOOD);
-}
-
-ZTEST(xsi_threads_ext, test_pthread_attr_setstack)
-{
-	void *stackaddr;
-	size_t stacksize;
-	void *new_stackaddr;
-	size_t new_stacksize;
-
-	/* valid values */
-	zassert_ok(pthread_attr_getstack(&attr, &stackaddr, &stacksize));
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setstack(NULL, NULL, 0), EACCES);
-			zassert_equal(pthread_attr_setstack(NULL, NULL, stacksize), EINVAL);
-			zassert_equal(pthread_attr_setstack(NULL, stackaddr, 0), EINVAL);
-			zassert_equal(pthread_attr_setstack(NULL, stackaddr, stacksize), EINVAL);
-			zassert_equal(pthread_attr_setstack((pthread_attr_t *)&uninit_attr,
-							    stackaddr, stacksize),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_setstack(&attr, NULL, 0), EACCES);
-		zassert_equal(pthread_attr_setstack(&attr, NULL, stacksize), EACCES);
-		zassert_equal(pthread_attr_setstack(&attr, stackaddr, 0), EINVAL);
-	}
-
-	/* ensure we can create and join a thread with the default attrs */
-	can_create_thread(&attr);
-
-	/* set stack / addr to the current values of stack / addr */
-	zassert_ok(pthread_attr_setstack(&attr, stackaddr, stacksize));
-	can_create_thread(&attr);
-
-	/* qemu_x86 seems to be unable to set thread stacks to be anything less than 4096 */
-	if (!IS_ENABLED(CONFIG_X86)) {
-		/*
-		 * check we can set a smaller stacksize
-		 * should not require dynamic reallocation
-		 * size may get rounded up to some alignment internally
-		 */
-		zassert_ok(pthread_attr_setstack(&attr, stackaddr, stacksize - 1));
-		/* ensure we read back the same values as we specified */
-		zassert_ok(pthread_attr_getstack(&attr, &new_stackaddr, &new_stacksize));
-		zassert_equal(new_stackaddr, stackaddr);
-		zassert_equal(new_stacksize, stacksize - 1);
-		can_create_thread(&attr);
-	}
-
-	if (IS_ENABLED(CONFIG_DYNAMIC_THREAD_ALLOC)) {
-		/* ensure we can set a dynamic stack */
-		k_thread_stack_t *stack;
-
-		stack = k_thread_stack_alloc(2 * stacksize, 0);
-		zassert_not_null(stack);
-
-		zassert_ok(pthread_attr_setstack(&attr, (void *)stack, 2 * stacksize));
-		/* ensure we read back the same values as we specified */
-		zassert_ok(pthread_attr_getstack(&attr, &new_stackaddr, &new_stacksize));
-		zassert_equal(new_stackaddr, (void *)stack);
-		zassert_equal(new_stacksize, 2 * stacksize);
-		can_create_thread(&attr);
-	}
-}
-
-ZTEST(xsi_threads_ext, test_pthread_set_get_concurrency)
-{
-	/* EINVAL if the value specified by new_level is negative */
-	zassert_equal(EINVAL, pthread_setconcurrency(-42));
-
-	/*
-	 * Note: the special value 0 indicates the implementation will
-	 * maintain the concurrency level at its own discretion.
-	 *
-	 * pthread_getconcurrency() should return a value of 0 on init.
-	 */
-	zassert_equal(0, pthread_getconcurrency());
-
-	for (int i = 0; i <= CONFIG_MP_MAX_NUM_CPUS; ++i) {
-		zassert_ok(pthread_setconcurrency(i));
-		/* verify parameter is saved */
-		zassert_equal(i, pthread_getconcurrency());
-	}
-
-	/* EAGAIN if the a system resource to be exceeded */
-	zassert_equal(EAGAIN, pthread_setconcurrency(CONFIG_MP_MAX_NUM_CPUS + 1));
-}
-
-ZTEST(xsi_threads_ext, test_pthread_attr_getstacksize)
-{
-	size_t stacksize = BIOS_FOOD;
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_getstacksize(NULL, NULL), EINVAL);
-			zassert_equal(pthread_attr_getstacksize(NULL, &stacksize), EINVAL);
-			zassert_equal(pthread_attr_getstacksize(&uninit_attr, &stacksize), EINVAL);
-		}
-		zassert_equal(pthread_attr_getstacksize(&attr, NULL), EINVAL);
-	}
-
-	zassert_ok(pthread_attr_getstacksize(&attr, &stacksize));
-	zassert_not_equal(stacksize, BIOS_FOOD);
-}
-
-ZTEST(xsi_threads_ext, test_pthread_attr_setstacksize)
-{
-	size_t stacksize;
-	size_t new_stacksize;
-
-	/* valid size */
-	zassert_ok(pthread_attr_getstacksize(&attr, &stacksize));
-
-	/* degenerate cases */
-	{
-		if (false) {
-			/* undefined behaviour */
-			zassert_equal(pthread_attr_setstacksize(NULL, 0), EINVAL);
-			zassert_equal(pthread_attr_setstacksize(NULL, stacksize), EINVAL);
-			zassert_equal(pthread_attr_setstacksize((pthread_attr_t *)&uninit_attr,
-								stacksize),
-				      EINVAL);
-		}
-		zassert_equal(pthread_attr_setstacksize(&attr, 0), EINVAL);
-	}
-
-	/* ensure we can spin up a thread with the default stack size */
-	can_create_thread(&attr);
-
-	/* set stack / addr to the current values of stack / addr */
-	zassert_ok(pthread_attr_setstacksize(&attr, stacksize));
-	/* ensure we can read back the values we just set */
-	zassert_ok(pthread_attr_getstacksize(&attr, &new_stacksize));
-	zassert_equal(new_stacksize, stacksize);
-	can_create_thread(&attr);
-
-	/* qemu_x86 seems to be unable to set thread stacks to be anything less than 4096 */
-	if (!IS_ENABLED(CONFIG_X86)) {
-		zassert_ok(pthread_attr_setstacksize(&attr, stacksize - 1));
-		/* ensure we can read back the values we just set */
-		zassert_ok(pthread_attr_getstacksize(&attr, &new_stacksize));
-		zassert_equal(new_stacksize, stacksize - 1);
-		can_create_thread(&attr);
-	}
-
-	if (IS_ENABLED(CONFIG_DYNAMIC_THREAD_ALLOC)) {
-		zassert_ok(pthread_attr_setstacksize(&attr, 2 * stacksize));
-		/* ensure we read back the same values as we specified */
-		zassert_ok(pthread_attr_getstacksize(&attr, &new_stacksize));
-		zassert_equal(new_stacksize, 2 * stacksize);
-		can_create_thread(&attr);
-	}
-}
-
-static void before(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	zassert_ok(pthread_attr_init(&attr));
-	if (!IS_ENABLED(CONFIG_DYNAMIC_THREAD_ALLOC)) {
-		zassert_ok(pthread_attr_setstack(&attr, &static_thread_stack,
-						 STATIC_THREAD_STACK_SIZE));
-	}
-	attr_valid = true;
-}
-
-static void after(void *arg)
-{
-	ARG_UNUSED(arg);
-
-	if (attr_valid) {
-		(void)pthread_attr_destroy(&attr);
-		attr_valid = false;
-	}
-}
-
-ZTEST_SUITE(xsi_threads_ext, NULL, NULL, before, after, NULL);
diff --git a/tests/posix/xsi_threads_ext/testcase.yaml b/tests/posix/xsi_threads_ext/testcase.yaml
deleted file mode 100644
index 7849b1580d8..00000000000
--- a/tests/posix/xsi_threads_ext/testcase.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
-common:
-  filter: not CONFIG_NATIVE_LIBC
-  tags:
-    - posix
-    - xsi_threads_ext
-  # 1 tier0 platform per supported architecture
-  platform_key:
-    - arch
-    - simulation
-  min_flash: 64
-  min_ram: 32
-tests:
-  portability.posix.xsi_threads_ext: {}
-  portability.posix.xsi_threads_ext.minimal:
-    extra_configs:
-      - CONFIG_MINIMAL_LIBC=y
-  portability.posix.xsi_threads_ext.newlib:
-    filter: TOOLCHAIN_HAS_NEWLIB == 1
-    extra_configs:
-      - CONFIG_NEWLIB_LIBC=y
-  portability.posix.xsi_threads_ext.picolibc:
-    tags: picolibc
-    filter: CONFIG_PICOLIBC_SUPPORTED
-    extra_configs:
-      - CONFIG_PICOLIBC=y
-  portability.posix.xsi_threads_ext.static_stack:
-    extra_configs:
-      - CONFIG_DYNAMIC_THREAD_ALLOC=n
